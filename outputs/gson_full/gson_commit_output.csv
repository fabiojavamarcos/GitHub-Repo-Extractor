Issue_Num,Author_Login,File_Name,Patch_Text,Commit_Message,Commit_Title
634,Jake Wharton,['README.md'],"@@ -16,9 +16,9 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
 
 *Gson Documentation*
   * Gson [API](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/index.html): Javadocs for the current Gson release
-  * Gson [user guide](http://sites.google.com/site/gson/gson-user-guide user guide): This guide contains examples on how to use Gson in your code.
+  * Gson [user guide](http://sites.google.com/site/gson/gson-user-guide): This guide contains examples on how to use Gson in your code.
   * Gson [Roadmap](https://sites.google.com/site/gson/gson-roadmap): Details on upcoming releases 
-  * Gson [design document](https://sites.google.com/site/gson/gson-design-document design document): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+  * Gson [design document](https://sites.google.com/site/gson/gson-design-document): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
 
 Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
 , ",Closes #633. ,Correct 'user guide' and 'design document' Markdown links.
652,Sebastian Chlan,['gson/src/main/java/com/google/gson/FieldNamingPolicy.java'],"@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import java.lang.reflect.Field;
+import java.util.Locale;
 
 /**
  * An enumeration that defines a few standard naming conventions for JSON field names.
@@ -88,7 +89,7 @@ public String translateName(Field f) {
    */
   LOWER_CASE_WITH_UNDERSCORES() {
     public String translateName(Field f) {
-      return separateCamelCase(f.getName(), ""_"").toLowerCase();
+      return separateCamelCase(f.getName(), ""_"").toLowerCase(Locale.ENGLISH);
     }
   },
 
@@ -111,7 +112,7 @@ public String translateName(Field f) {
    */
   LOWER_CASE_WITH_DASHES() {
     public String translateName(Field f) {
-      return separateCamelCase(f.getName(), ""-"").toLowerCase();
+      return separateCamelCase(f.getName(), ""-"").toLowerCase(Locale.ENGLISH);
     }
   };
 , ","### Description

When using `LOWER_CASE_WITH_DASHES` or `LOWER_CASE_WITH_UNDERSCORES` as FieldNamingPolicy it could happen that certain fields won't get serialized/deserialized. 
I've seen that behavior on devices with a turkish (`tr-TR`) locale. `toLowerCase()` uses the device's locale and converts an `I` into an `ı`. ([JavaDoc](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#toLowerCase%28%29))
### Example

A field with the name: 

```
...
int lowerId = 8;
....
```

will turn into:

```
{ ... 'lower-ıd':8 ... }
```
### Recreation steps

Check out the first commit (299ee89) and run the test with the following JVM flags:  `-Duser.language=tr -Duser.region=TR`
### References

https://code.google.com/p/google-gson/issues/detail?id=541
http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#toLowerCase()",Fix issues if runing in an environment with a Turkish locale
657,Jake Wharton,['gson/src/main/java/com/google/gson/TypeAdapter.java'],"@@ -211,9 +211,13 @@ public final void toJson(Writer out, T value) throws IOException {
    * @param value the Java object to convert. May be null.
    * @since 2.2
    */
-  public final String toJson(T value) throws IOException {
+  public final String toJson(T value) {
     StringWriter stringWriter = new StringWriter();
-    toJson(stringWriter, value);
+    try {
+      toJson(stringWriter, value);
+    } catch (IOException e) {
+      throw new AssertionError(e); // No I/O writing to a StringWriter.
+    }
     return stringWriter.toString();
   }
 , ",NaN,There is no I/O writing to a StringWriter.
658,Jake Wharton,['.travis.yml'],"@@ -0,0 +1,21 @@
+language: java
+
+jdk:
+  - oraclejdk7
+  - oraclejdk8
+
+install: mvn -f gson install -DskipTests=true
+script: mvn -f gson test
+
+branches:
+  except:
+    - gh-pages
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2, ",NaN,Add Travis CI build.
659,Jake Wharton,['.gitignore'],"@@ -0,0 +1,16 @@
+.classpath
+.project
+.settings
+eclipsebin
+
+target
+pom.xml.*
+release.properties
+
+.idea
+*.iml
+*.ipr
+*.iws
+classes
+
+.DS_Store, ",NaN,"Add gitignore for Maven, Eclipse, IDEA, and OSX files."
664,Stefan Ferstl,"['gson/pom.xml', 'gson/src/main/java/com/google/gson/Gson.java']","@@ -49,6 +49,12 @@
     <url>http://www.google.com</url>
   </organization>
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <version>3.0.0</version>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>, @@ -31,6 +31,8 @@
 import java.util.List;
 import java.util.Map;
 
+import javax.annotation.concurrent.ThreadSafe;
+
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -96,6 +98,7 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
+@ThreadSafe
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
 , ","This PR solves Issue #613 that I submitted several months ago on Google Code.

Summary:
- Add an optional dependency to com.google.code.findbugs:jsr305.
  The optional scope is used in order to avoid introducing a new
  transitive dependency to the jsr305 library. This is fine because the 
  @ThreadSafe annotation has only a documentary purpose and it is not
  retained at runtime.
- Annotate the Gson class as @ThreadSafe",Add a JSR-305 @ThreadSafe annotation to the Gson class
667,Adam Tanner,"['gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'gson/src/test/java/com/google/gson/stream/JsonWriterTest.java']","@@ -420,6 +420,23 @@ public JsonWriter value(String value) throws IOException {
     return this;
   }
 
+  /**
+   * Writes {@code value} directly to the writer without quoting or
+   * escaping.
+   *
+   * @param value the literal string value, or null to encode a null literal.
+   * @return this writer.
+   */
+  public JsonWriter jsonValue(String value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue(false);
+    out.append(value);
+    return this;
+  }
+
   /**
    * Encodes {@code null}.
    *, @@ -126,6 +126,18 @@ public void testNullStringValue() throws IOException {
     assertEquals(""{\""a\"":null}"", stringWriter.toString());
   }
 
+  public void testJsonValue() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginObject();
+    jsonWriter.name(""a"");
+    jsonWriter.jsonValue(""{\""b\"":true}"");
+    jsonWriter.name(""c"");
+    jsonWriter.value(1);
+    jsonWriter.endObject();
+    assertEquals(""{\""a\"":{\""b\"":true},\""c\"":1}"", stringWriter.toString());
+  }
+
   public void testNonFiniteDoubles() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);, ","Add a polymorphic version of `value(String value)` that takes an additional boolean argument (`encode`) that can be used to write the string directly to the underlying writer without modification, while maintaining the state of the `JsonWriter` so that it can continue to be written to.

The intended use case for this is when building JSON that contains a pre-serialized JSON string as a value in an object or array.

Alternative API ideas/open questions:
-  Should a separate method be used instead of a polymorphic version of `value(String)`? Maybe something like `rawValue(String)`?",JsonWriter#value supports opaque JSON values.
669,Adam Tanner,['gson/src/test/java/com/google/gson/DefaultInetAddressTypeAdapterTest.java'],"@@ -35,11 +35,11 @@ protected void setUp() throws Exception {
   }
   
   public void testInetAddressSerializationAndDeserialization() throws Exception {
-    InetAddress localhost = InetAddress.getLocalHost();
-    String localInetAddress = gson.toJson(localhost);
-    assertEquals(""\"""" + localhost.getHostAddress() + ""\"""", localInetAddress);
+    InetAddress address = InetAddress.getByName(""8.8.8.8"");
+    String jsonAddress = gson.toJson(address);
+    assertEquals(""\""8.8.8.8\"""", jsonAddress);
     
-    InetAddress value = gson.fromJson(localInetAddress, InetAddress.class);
-    assertEquals(localhost, value);
+    InetAddress value = gson.fromJson(jsonAddress, InetAddress.class);
+    assertEquals(value, address);
   } 
 }, ","Calling InetAddress.getLocalHost() will cause a lookup to occur that may
fail with a java.net.UnknownHostException if the system the test is
running on is not configured correctly.

This is often fixed by echoing ""127.0.0.1 $HOSTNAME"" to /etc/hosts, but
in this case it seems easier to pick a static IP string to avoid the
lookup entirely and prevent false negatives in the test.",Replace localhost lookup with static IP to fix test.
670,Adam Tanner,['gson/pom.xml'],"@@ -11,7 +11,7 @@
     <artifactId>oss-parent</artifactId>
     <version>9</version>
   </parent>
-  <url>http://code.google.com/p/google-gson/</url>
+  <url>https://github.com/google/gson</url>
   <description>Google Gson library</description>
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -24,13 +24,14 @@
     </license>
   </licenses>
   <scm>
-    <connection>scm:svn:http://google-gson.googlecode.com/svn/trunk/gson</connection>
-    <developerConnection>scm:svn:https://google-gson.googlecode.com/svn/trunk/gson</developerConnection>
-    <url>http://google-gson.googlecode.com/svn/trunk/gson</url>
+    <connection>scm:git:https://github.com/google/gson.git</connection>
+    <developerConnection>scm:git:https://github.com/google/gson.git</developerConnection>
+    <url>https://github.com/google/gson</url>
+    <tag>gson-${project.version}</tag>
   </scm>
   <issueManagement>
-    <system>Google Code Issue Tracking</system>
-    <url>http://code.google.com/p/google-gson/issues/list</url>
+    <system>Github Issue Tracking</system>
+    <url>https://github.com/google/gson/issues</url>
   </issueManagement>
   <distributionManagement>
     <snapshotRepository>
@@ -140,7 +141,7 @@
               <Bundle-RequiredExecutionEnvironment>J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8</Bundle-RequiredExecutionEnvironment>
               <Export-Package><![CDATA[com.google.gson;version=${project.version}, com.google.gson.annotations;version=${project.version}, com.google.gson.reflect;version=${project.version}, com.google.gson.stream;version=${project.version}, com.google.gson.internal;version=${project.version}, com.google.gson.internal.bind;version=${project.version}]]></Export-Package>
               <Bundle-Version>${project.version}</Bundle-Version>
-              <Bundle-ContactAddress>http://code.google.com/p/google-gson/</Bundle-ContactAddress>
+              <Bundle-ContactAddress>https://github.com/google/gson</Bundle-ContactAddress>
               <Bundle-Vendor>Google Gson Project</Bundle-Vendor>
               <Bundle-Name>${project.name}</Bundle-Name>
               <Bundle-Description>${project.description}</Bundle-Description>
@@ -220,7 +221,6 @@
         <!-- version>2.5</version -->
         <configuration>
           <arguments>-DenableCiProfile=true</arguments>
-          <tagBase>https://google-gson.googlecode.com/svn/tags</tagBase>
         </configuration>
       </plugin>
       <plugin>
@@ -249,4 +249,3 @@
     </developer>
   </developers>
 </project>
-, ","Not sure if this is entirely correct, but thought this might be blocking new releases so I figured I'd give it a shot. Let me know if this looks right.

Related: #668 ",Change references to Google Code to Github in pom.xml.
671,,['gson/src/test/java/com/google/gson/functional/JsonArrayTest.java'],"@@ -127,6 +127,22 @@ public void testMixedPrimitiveAddition() {
     assertEquals(""[\""a\"",\""apple\"",12121,\""o\"",null,null,12.232,2323]"", jsonArray.toString());
   }
 
+  public void testNullPrimitiveAddition() {
+    JsonArray jsonArray = new JsonArray();
+
+    jsonArray.add((Character) null);
+    jsonArray.add((Boolean) null);
+    jsonArray.add((Integer) null);
+    jsonArray.add((Double) null);
+    jsonArray.add((Float) null);
+    jsonArray.add((BigInteger) null);
+    jsonArray.add((String) null);
+    jsonArray.add((Boolean) null);
+    jsonArray.add((Number) null);
+
+    assertEquals(""[null,null,null,null,null,null,null,null,null]"", jsonArray.toString());
+  }
+
   public void testSameAddition() {
     JsonArray jsonArray = new JsonArray();
 , ","Overloaded the ""add(...)"" method in JsonArray to support directly putting in primitives as arguments.

Now instead of inserting them in the old overly verbose way:

``` java
JsonArray array = new JsonArray();
array.add(new JsonPrimitive(true));
array.add(new JsonPrimitive(12));
array.add(new JsonPrimitive(""hello""));
array.add(new JsonPrimitive('c'));
```

You can do:

``` java
JsonArray array = new JsonArray();
array.add(true);
array.add(12);
array.add(""hello"");
array.add('c');
```",Support for adding primitives directly to JsonArray instances
674,Lars Vogel,['gson/README'],"@@ -4,4 +4,4 @@ equivalent Java object. Gson can work with arbitrary Java objects including
 pre-existing objects that you do not have source-code of.
 
 Complete Gson documentation is available at its project page 
-http://code.google.com/p/google-gson
+https://github.com/google/gson, ",NaN,Readme points to the new homepage at Github
681,Lachlan Coote,"['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java', 'extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java']","@@ -235,6 +235,6 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
         }
         Streams.write(clone, out);
       }
-    };
+    }.nullSafe();
   }
 }, @@ -167,6 +167,25 @@ public void testSerializeCollidingTypeFieldName() {
     }
   }
 
+  public void testSerializeWrappedNullValue() {
+    TypeAdapterFactory billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)
+        .registerSubtype(CreditCard.class)
+        .registerSubtype(BankTransfer.class);    
+    Gson gson = new GsonBuilder()
+        .registerTypeAdapterFactory(billingAdapter)
+        .create();    
+    String serialized = gson.toJson(new BillingInstrumentWrapper(null), BillingInstrumentWrapper.class);
+    BillingInstrumentWrapper deserialized = gson.fromJson(serialized, BillingInstrumentWrapper.class);
+    assertNull(deserialized.instrument);
+  }
+
+  static class BillingInstrumentWrapper {
+    BillingInstrument instrument;
+    BillingInstrumentWrapper(BillingInstrument instrument) {
+      this.instrument = instrument;
+    }
+  }
+
   static class BillingInstrument {
     private final String ownerName;
     BillingInstrument(String ownerName) {, ",NaN,fix #680 - make RuntimeTypeAdapterFactory null-safe
684,Inderjeet Singh,"['gson/pom.xml', 'gson/src/main/java/com/google/gson/Gson.java']","@@ -50,12 +50,6 @@
     <url>http://www.google.com</url>
   </organization>
   <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <version>3.0.0</version>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>, @@ -31,8 +31,6 @@
 import java.util.List;
 import java.util.Map;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -98,7 +96,6 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
-@ThreadSafe
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
 , ",Reverts google/gson#664,"Revert ""Add a JSR-305 @ThreadSafe annotation to the Gson class"""
685,Inderjeet Singh,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -56,7 +56,8 @@
 /**
  * This is the main class for using Gson. Gson is typically used by first constructing a
  * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}
- * methods on it.
+ * methods on it. Gson instances are Thread-safe so you can reuse them freely across multiple
+ * threads.
  *
  * <p>You can create a Gson instance by invoking {@code new Gson()} if the default configuration
  * is all you need. You can also use {@link GsonBuilder} to build a Gson instance with various, ",NaN,Updated Gson Javadoc to indicate thread-safety.
688,Michael Evans,['gson/src/main/java/com/google/gson/annotations/SerializedName.java'],"@@ -64,7 +64,7 @@
  * @author Joel Leitch
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.FIELD)
+@Target({ElementType.FIELD, ElementType.METHOD})
 public @interface SerializedName {
 
   /**, ",Closes #687 ,Add METHOD target for use with AutoValue's abstract property methods
689,Vladislav Bauer,"['gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java', 'gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'gson/src/main/java/com/google/gson/internal/Primitives.java', 'gson/src/main/java/com/google/gson/internal/Streams.java', 'gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/test/java/com/google/gson/common/MoreAsserts.java']","@@ -30,6 +30,10 @@
  * @author Joel Leitch
  */
 public final class $Gson$Preconditions {
+  private $Gson$Preconditions() {
+    throw new UnsupportedOperationException();
+  }
+
   public static <T> T checkNotNull(T obj) {
     if (obj == null) {
       throw new NullPointerException();, @@ -43,7 +43,9 @@
 public final class $Gson$Types {
   static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
 
-  private $Gson$Types() {}
+  private $Gson$Types() {
+    throw new UnsupportedOperationException();
+  }
 
   /**
    * Returns a new parameterized type, applying {@code typeArguments} to, @@ -29,7 +29,9 @@
  * @author Kevin Bourrillion
  */
 public final class Primitives {
-  private Primitives() {}
+  private Primitives() {
+    throw new UnsupportedOperationException();
+  }
 
   /** A map from primitive types to their corresponding wrapper types. */
   private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;, @@ -33,6 +33,10 @@
  * Reads and writes GSON parse trees over streams.
  */
 public final class Streams {
+  private Streams() {
+    throw new UnsupportedOperationException();
+  }
+
   /**
    * Takes a reader in any state and returns the next value as a JsonElement.
    */, @@ -55,7 +55,9 @@
  * Type adapters for basic types.
  */
 public final class TypeAdapters {
-  private TypeAdapters() {}
+  private TypeAdapters() {
+    throw new UnsupportedOperationException();
+  }
 
   @SuppressWarnings(""rawtypes"")
   public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {, @@ -69,4 +69,5 @@ public static void assertEqualsAndHashCode(Object a, Object b) {
     Assert.assertFalse(a.equals(null));
     Assert.assertFalse(a.equals(new Object()));
   }
+
 }, ","I think that constructors from util classes should pass the following rules (best practices):
1. Each util class should have only the one constructor without parameters.
2. Constructor should be private.
3. Code should not have possibility to instantiate this class even using reflection mechanism (UnsupportedOperationException)",Add unit tests for constructors from util classes
693,Inderjeet Singh,['gson/src/test/java/com/google/gson/functional/PrimitiveTest.java'],"@@ -198,6 +198,19 @@ public void testDoubleNoFractAsStringRepresentationDeserialization() {
     assertEquals(expected.doubleValue(), actual1);
   }
 
+  public void testDoubleArrayDeserialization() {
+      String json = ""[0.0, 0.004761904761904762, 3.4013606962703525E-4, 7.936508173034305E-4,""
+              + ""0.0011904761904761906, 0.0]"";
+      double[] values = gson.fromJson(json, double[].class);
+      assertEquals(6, values.length);
+      assertEquals(0.0, values[0]);
+      assertEquals(0.004761904761904762, values[1]);
+      assertEquals(3.4013606962703525E-4, values[2]);
+      assertEquals(7.936508173034305E-4, values[3]);
+      assertEquals(0.0011904761904761906, values[4]);
+      assertEquals(0.0, values[5]);
+  }
+
   public void testLargeDoubleDeserialization() {
     String doubleValue = ""1.234567899E8"";
     Double expected = Double.valueOf(doubleValue);, ",NaN,Added tests for deserialization of double array
694,Benjamin AUGUSTIN,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -410,6 +410,10 @@ private void checkValidFloatingPoint(double value) {
    *  System.out.println(""Num JSON reads"" + stats.numReads);
    *  System.out.println(""Num JSON writes"" + stats.numWrites);
    *  }</pre>
+   *  Note that this call will skip all factories registered before {@code skipPast}. In case of
+   *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure
+   *  that the order of registration does not prevent this method from reaching a factory they 
+   *  would expect to reply from this call.
    *  Note that since you can not override type adapter factories for String and Java primitive
    *  types, our stats factory will not count the number of String or primitives that will be
    *  read or written., ","### Problem:

`getDelegateAdapter` is not only skipping the passed in TypeAdapterFactory but all the previous one in the registered list. It seems unlikely that this is expected behaviour as this is not documented and makes this feature dependant on the order of the registration of the given factories.
#### Example:

``` java
TypeAdapterFactoryA factoryA = new TypeAdapterFactoryA()
new GsonBuilder()
                .registerTypeAdapterFactory(factoryA)
                .registerTypeAdapterFactory(new TypeAdapterFactoryB(factoryA))
                .create()
```

If TypeAdapterFactoryB calls `getDelegateAdapter(factoryA, ...)` and TypeAdapterFactoryA calls `getDelegateAdapter(this, ...) then TypeAdapterFactoryB is not invoked back.

Inverting order in creation makes the resolution work as expected.

``` java
TypeAdapterFactoryA factoryA = new TypeAdapterFactoryA()
TypeAdapterFactoryB factoryB = new TypeAdapterFactoryB(factoryA)
new GsonBuilder()
                .registerTypeAdapterFactory(factoryB)
                .registerTypeAdapterFactory(factoryA)
                .create()
```
### Proposed solution (not working):

Only skipping the factory passed in parameter.",getDelegateAdapter is order dependant and skips more than one typeAdapterFactory.
698,Inderjeet Singh,['gson/pom.xml'],"@@ -110,7 +110,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.2</version>
+        <version>3.3</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
@@ -119,7 +119,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>2.5</version>
+        <version>2.6</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -175,7 +175,7 @@
          <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.1</version>
+         <version>2.10.3</version>
          <executions>
            <execution>
              <id>attach-javadocs</id>
@@ -197,7 +197,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.9</version>
+         <version>2.10</version>
          <configuration>
            <downloadSources>true</downloadSources>
            <downloadJavadocs>true</downloadJavadocs>
@@ -219,7 +219,7 @@
       </plugin>
       <plugin>
         <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.5.1</version>
+        <version>2.5.5</version>
         <configuration>
           <descriptor>assembly-descriptor.xml</descriptor>
           <finalName>google-gson-${project.version}</finalName>, ",NaN,updated maven plugin versions to latest
699,Inderjeet Singh,"['gson/pom.xml', 'gson/src/main/java/com/google/gson/annotations/SerializedName.java', 'gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java', 'gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/test/java/com/google/gson/functional/SerializedNameTest.java']","@@ -3,7 +3,7 @@
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
   <packaging>jar</packaging>
-  <version>2.3.2-SNAPSHOT</version>
+  <version>2.4-SNAPSHOT</version>
   <inceptionYear>2008</inceptionYear>
   <name>Gson</name>
   <parent>, @@ -33,30 +33,43 @@
  *
  * <p>Here is an example of how this annotation is meant to be used:</p>
  * <pre>
- * public class SomeClassWithFields {
- *   &#64SerializedName(""name"") private final String someField;
- *   private final String someOtherField;
+ * public class MyClass {
+ *   &#64SerializedName(""name"") String a;
+ *   &#64SerializedName(value=""name1"", alternate={""name2"", ""name3""}) String b;
+ *   String c;
  *
- *   public SomeClassWithFields(String a, String b) {
- *     this.someField = a;
- *     this.someOtherField = b;
+ *   public MyClass(String a, String b, String c) {
+ *     this.a = a;
+ *     this.b = b;
+ *     this.c = c;
  *   }
  * }
  * </pre>
  *
  * <p>The following shows the output that is generated when serializing an instance of the
  * above example class:</p>
  * <pre>
- * SomeClassWithFields objectToSerialize = new SomeClassWithFields(""a"", ""b"");
+ * MyClass target = new MyClass(""v1"", ""v2"", ""v3"");
  * Gson gson = new Gson();
- * String jsonRepresentation = gson.toJson(objectToSerialize);
- * System.out.println(jsonRepresentation);
+ * String json = gson.toJson(target);
+ * System.out.println(json);
  *
  * ===== OUTPUT =====
- * {""name"":""a"",""someOtherField"":""b""}
+ * {""name"":""v1"",""name1"":""v2"",""c"":""v3""}
  * </pre>
  *
  * <p>NOTE: The value you specify in this annotation must be a valid JSON field name.</p>
+ * While deserializing, all values specified in the annotation will be deserialized into the field.
+ * For example:
+ * <pre>
+ *   MyClass target = gson.fromJson(""{'name1':'v1'}"", MyClass.class);
+ *   assertEquals(""v1"", target.b);
+ *   target = gson.fromJson(""{'name2':'v2'}"", MyClass.class);
+ *   assertEquals(""v2"", target.b);
+ *   target = gson.fromJson(""{'name3':'v3'}"", MyClass.class);
+ *   assertEquals(""v3"", target.b);
+ * </pre>
+ * Note that MyClass.b is now deserialized from either name1, name2 or name3.
  *
  * @see com.google.gson.FieldNamingPolicy
  *
@@ -68,7 +81,9 @@
 public @interface SerializedName {
 
   /**
-   * @return the desired name of the field when it is serialized
+   * @return the desired names of the field when it is deserialized or serialized. All of the specified names will be deserialized from.
+   *   The specified first name is what is used for serialization.
    */
   String value();
+  String[] alternate() default {};
 }, @@ -16,6 +16,16 @@
 
 package com.google.gson.internal.bind;
 
+import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
@@ -32,13 +42,6 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -63,13 +66,24 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);
   }
 
-  private String getFieldName(Field f) {
+  /** first element holds the default name */
+  private List<String> getFieldNames(Field f) {
     return getFieldName(fieldNamingPolicy, f);
   }
 
-  static String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {
+  /** first element holds the default name */
+  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {
     SerializedName serializedName = f.getAnnotation(SerializedName.class);
-    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();
+    List<String> fieldNames = new LinkedList<String>();
+    if (serializedName == null) {
+      fieldNames.add(fieldNamingPolicy.translateName(f));
+    } else {
+      fieldNames.add(serializedName.value());
+      for (String alternate : serializedName.alternate()) {
+        fieldNames.add(alternate);
+      }
+    }
+    return fieldNames;
   }
 
   public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
@@ -139,9 +153,16 @@ public boolean writeField(Object value) throws IOException, IllegalAccessExcepti
         }
         field.setAccessible(true);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
-        BoundField boundField = createBoundField(context, field, getFieldName(field),
-            TypeToken.get(fieldType), serialize, deserialize);
-        BoundField previous = result.put(boundField.name, boundField);
+        List<String> fieldNames = getFieldNames(field);
+        BoundField previous = null;
+        for (int i = 0; i < fieldNames.size(); ++i) {
+          String name = fieldNames.get(i);
+          if (i != 0) serialize = false; // only serialize the default name
+          BoundField boundField = createBoundField(context, field, name,
+              TypeToken.get(fieldType), serialize, deserialize);
+          BoundField replaced = result.put(name, boundField);
+          if (previous == null) previous = replaced;
+        }
         if (previous != null) {
           throw new IllegalArgumentException(declaredType
               + "" declares multiple JSON fields named "" + previous.name);, @@ -727,6 +727,9 @@ public EnumTypeAdapter(Class<T> classOfT) {
           SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
           if (annotation != null) {
             name = annotation.value();
+            for (String alternate : annotation.alternate()) {
+              nameToConstant.put(alternate, constant);
+            }
           }
           nameToConstant.put(name, constant);
           constantToName.put(constant, name);, @@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import junit.framework.TestCase;
+
+public final class SerializedNameTest extends TestCase {
+  private final Gson gson = new Gson();
+
+  public void testFirstNameIsChosenForSerialization() {
+    MyClass target = new MyClass(""v1"", ""v2"");
+    // Ensure name1 occurs exactly once, and name2 and name3 dont appear
+    assertEquals(""{\""name\"":\""v1\"",\""name1\"":\""v2\""}"", gson.toJson(target));
+  }
+
+  public void testMultipleNamesDeserializedCorrectly() {
+    assertEquals(""v1"", gson.fromJson(""{'name':'v1'}"", MyClass.class).a);
+
+    // Both name1 and name2 gets deserialized to b
+    assertEquals(""v11"", gson.fromJson(""{'name1':'v11'}"", MyClass.class).b);
+    assertEquals(""v2"", gson.fromJson(""{'name2':'v2'}"", MyClass.class).b);
+    assertEquals(""v3"", gson.fromJson(""{'name3':'v3'}"", MyClass.class).b);
+  }
+
+  public void testMultipleNamesInTheSameString() {
+    // The last value takes precedence
+    assertEquals(""v3"", gson.fromJson(""{'name1':'v1','name2':'v2','name3':'v3'}"", MyClass.class).b);
+  }
+
+  private static final class MyClass {
+    @SerializedName(""name"") String a;
+    @SerializedName(value=""name1"", alternate={""name2"", ""name3""}) String b;
+    MyClass(String a, String b) {
+      this.a = a;
+      this.b = b;
+    }
+  }
+}, ",NaN,Implemented support for multiple values for SerializedName annotation.
700,Jesse Wilson,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -246,6 +246,11 @@ public Gson() {
     this.factories = Collections.unmodifiableList(factories);
   }
 
+  /** Returns true if this Gson instance writes fields with null values. */
+  public boolean serializeNulls() {
+    return serializeNulls;
+  }
+
   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
     if (serializeSpecialFloatingPointValues) {
       return TypeAdapters.DOUBLE;, ",Useful for frameworks that build on Gson.,Expose serializeNulls with an accessor.
704,Jake Wharton,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -247,11 +247,6 @@ public Gson() {
     this.factories = Collections.unmodifiableList(factories);
   }
 
-  /** Returns true if this Gson instance writes fields with null values. */
-  public boolean serializeNulls() {
-    return serializeNulls;
-  }
-
   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {
     if (serializeSpecialFloatingPointValues) {
       return TypeAdapters.DOUBLE;
@@ -648,10 +643,9 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
   }
 
   /**
-   * Returns a new JSON writer configured for this GSON and with the non-execute
-   * prefix if that is configured.
+   * Returns a new JSON writer configured for the settings on this Gson instance.
    */
-  private JsonWriter newJsonWriter(Writer writer) throws IOException {
+  public JsonWriter newJsonWriter(Writer writer) throws IOException {
     if (generateNonExecutableJson) {
       writer.write(JSON_NON_EXECUTABLE_PREFIX);
     }, ",This is more future proof to ensure that consumers holding on to TypeAdapters for efficiency can always encode JSON in the same way as if the Gson instance was used directly.,Expose newJsonWriter wrapper instead of just options.
705,Inderjeet Singh,['gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java'],"@@ -26,6 +26,7 @@
 public final class LazilyParsedNumber extends Number {
   private final String value;
 
+  /** @param value must not be null */
   public LazilyParsedNumber(String value) {
     this.value = value;
   }
@@ -78,23 +79,18 @@ private Object writeReplace() throws ObjectStreamException {
 
   @Override
   public int hashCode() {
-    return value == null ? 0 : value.hashCode();
+    return value.hashCode();
   }
 
   @Override
   public boolean equals(Object obj) {
     if (this == obj) {
       return true;
     }
-    if (obj == null || !(obj instanceof LazilyParsedNumber)) {
-      return false;
+    if (obj instanceof LazilyParsedNumber) {
+      LazilyParsedNumber other = (LazilyParsedNumber) obj;
+      return value == other.value || value.equals(other.value);
     }
-    LazilyParsedNumber other = (LazilyParsedNumber) obj;
-    return equals(value, other.value);
-  }
-
-  private static boolean equals(Object obj1, Object obj2) {
-    if (obj1 == null) return obj2 == null;
-    return obj1 == obj2 || obj1.equals(obj2);
+    return false;
   }
 }, ",https://github.com/google/gson/issues/627,Implemented equals and hashcode for LazilyParsedNumber to fix
706,Inderjeet Singh,['gson/src/main/java/com/google/gson/stream/JsonWriter.java'],"@@ -77,7 +77,7 @@
  * This code encodes the above structure: <pre>   {@code
  *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
  *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, ""UTF-8""));
- *     writer.setIndentSpaces(4);
+ *     writer.setIndent(""    "");
  *     writeMessagesArray(writer, messages);
  *     writer.close();
  *   }, ",https://github.com/google/gson/issues/623,Fixed javadoc for JsonWriter as reported in
707,Dushyant Mistry,['gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java'],"@@ -122,7 +122,7 @@ public T construct() {
 
   /**
    * Constructors for common interface types like Map and List and their
-   * subytpes.
+   * subtypes.
    */
   @SuppressWarnings(""unchecked"") // use runtime checks to guarantee that 'T' is what it is
   private <T> ObjectConstructor<T> newDefaultImplementationConstructor(, ",s/subytpes/subtypes/g,typo
709,Roman Mazur,['gson/src/main/java/com/google/gson/annotations/SerializedName.java'],"@@ -81,9 +81,11 @@
 public @interface SerializedName {
 
   /**
-   * @return the desired names of the field when it is deserialized or serialized. All of the specified names will be deserialized from.
-   *   The specified first name is what is used for serialization.
+   * @return the desired name of the field when it is serialized or deserialized
    */
   String value();
+  /**
+   * @return the alternative names of the field when it is deserialized
+   */
   String[] alternate() default {};
 }, ",In #699 the approach was changed but docs were left for the first implementation.,Fix javadoc of SerializedName
710,,['proto/pom.xml'],"@@ -55,7 +55,7 @@
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.3.1</version>
+      <version>2.4</version>
       <scope>compile</scope>
     </dependency>
 , ","The current ProtoTypeAdapter is quite old, doesn't work for a few things correctly (I don't remember what exactly but it had some failures when I tried to use it), so I decided to update it and to make it better.

This version of ProtoTypeAdapter now:
- Lets you customize the proto field name serialization per field
- Lets you use different cases for serialization (e.g. you could use UpperCamelCase for your proto field names and willing to serialize them using LowerHyphen)
- Lets you choose to serialize enum values with their value (0, 1, 2, ...) instead of their name.

We've been using it in prod for a while, I added quite a few unit tests to make sure everything works properly.",Updating the ProtoTypeAdapter to support custom field names/values annotations
715,,['examples/android-proguard-example/proguard.cfg'],"@@ -1,77 +1,3 @@
-##---------------Begin: proguard configuration common for all Android apps ----------
--optimizationpasses 5
--dontusemixedcaseclassnames
--dontskipnonpubliclibraryclasses
--dontskipnonpubliclibraryclassmembers
--dontpreverify
--verbose
--dump class_files.txt
--printseeds seeds.txt
--printusage unused.txt
--printmapping mapping.txt
--optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
-
--allowaccessmodification
--keepattributes *Annotation*
--renamesourcefileattribute SourceFile
--keepattributes SourceFile,LineNumberTable
--repackageclasses ''
-
--keep public class * extends android.app.Activity
--keep public class * extends android.app.Application
--keep public class * extends android.app.Service
--keep public class * extends android.content.BroadcastReceiver
--keep public class * extends android.content.ContentProvider
--keep public class * extends android.app.backup.BackupAgentHelper
--keep public class * extends android.preference.Preference
--keep public class com.android.vending.licensing.ILicensingService
--dontnote com.android.vending.licensing.ILicensingService
-
-# Explicitly preserve all serialization members. The Serializable interface
-# is only a marker interface, so it wouldn't save them.
--keepclassmembers class * implements java.io.Serializable {
-    static final long serialVersionUID;
-    private static final java.io.ObjectStreamField[] serialPersistentFields;
-    private void writeObject(java.io.ObjectOutputStream);
-    private void readObject(java.io.ObjectInputStream);
-    java.lang.Object writeReplace();
-    java.lang.Object readResolve();
-}
-
-# Preserve all native method names and the names of their classes.
--keepclasseswithmembernames class * {
-    native <methods>;
-}
-
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet);
-}
-
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet, int);
-}
-
-# Preserve static fields of inner classes of R classes that might be accessed
-# through introspection.
--keepclassmembers class **.R$* {
-  public static <fields>;
-}
-
-# Preserve the special static methods that are required in all enumeration classes.
--keepclassmembers enum * {
-    public static **[] values();
-    public static ** valueOf(java.lang.String);
-}
-
--keep public class * {
-    public protected *;
-}
-
--keep class * implements android.os.Parcelable {
-  public static final android.os.Parcelable$Creator *;
-}
-##---------------End: proguard configuration common for all Android apps ----------
-
 ##---------------Begin: proguard configuration for Gson  ----------
 # Gson uses generic type information stored in a class file when working with fields. Proguard
 # removes such information by default, so configure it to keep all of it., ",That will avoid committing the generated/ folder that is useless in the repository.,Moved the .gitignore file to a more appropriate place
719,Jesse Wilson,"['gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java']","@@ -16,6 +16,22 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonIOException;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.annotations.SerializedName;
+import com.google.gson.internal.LazilyParsedNumber;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -34,23 +50,6 @@
 import java.util.StringTokenizer;
 import java.util.UUID;
 
-import com.google.gson.Gson;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonIOException;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
-import com.google.gson.TypeAdapter;
-import com.google.gson.TypeAdapterFactory;
-import com.google.gson.annotations.SerializedName;
-import com.google.gson.internal.LazilyParsedNumber;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-
 /**
  * Type adapters for basic types.
  */
@@ -815,12 +814,33 @@ public void write(JsonWriter out, T value) throws IOException {
     };
   }
 
-  public static <TT> TypeAdapterFactory newTypeHierarchyFactory(
-      final Class<TT> clazz, final TypeAdapter<TT> typeAdapter) {
+  /**
+   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm
+   * that the deserialized type matches the type requested.
+   */
+  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(
+      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {
     return new TypeAdapterFactory() {
       @SuppressWarnings(""unchecked"")
-      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
-        return clazz.isAssignableFrom(typeToken.getRawType()) ? (TypeAdapter<T>) typeAdapter : null;
+      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {
+        final Class<? super T2> requestedType = typeToken.getRawType();
+        if (!clazz.isAssignableFrom(requestedType)) {
+          return null;
+        }
+        return (TypeAdapter<T2>) new TypeAdapter<T1>() {
+          @Override public void write(JsonWriter out, T1 value) throws IOException {
+            typeAdapter.write(out, value);
+          }
+
+          @Override public T1 read(JsonReader in) throws IOException {
+            T1 result = typeAdapter.read(in);
+            if (result != null && !requestedType.isInstance(result)) {
+              throw new JsonSyntaxException(""Expected a "" + requestedType.getName()
+                  + "" but was "" + result.getClass().getName());
+            }
+            return result;
+          }
+        };
       }
       @Override public String toString() {
         return ""Factory[typeHierarchy="" + clazz.getName() + "",adapter="" + typeAdapter + ""]"";, @@ -15,6 +15,21 @@
  */
 package com.google.gson.functional;
 
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Type;
@@ -40,24 +55,8 @@
 import java.util.TimeZone;
 import java.util.TreeSet;
 import java.util.UUID;
-
 import junit.framework.TestCase;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.TypeAdapter;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
-
 /**
  * Functional test for Json serialization and deserialization for common classes for which default
  * support is provided in Gson. The tests for Map types are available in {@link MapTest}.
@@ -479,7 +478,8 @@ public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws E
     Gson gson = new GsonBuilder()
         .setDateFormat(pattern)
         .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
-          public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+          public Date deserialize(JsonElement json, Type typeOfT,
+              JsonDeserializationContext context)
               throws JsonParseException {
             return new Date(1315806903103L);
           }
@@ -618,6 +618,16 @@ public void testJsonNullDeserialization() {
     assertEquals(JsonNull.INSTANCE, gson.fromJson(""null"", JsonNull.class));
   }
 
+  public void testJsonElementTypeMismatch() {
+    try {
+      gson.fromJson(""\""abc\"""", JsonObject.class);
+      fail();
+    } catch (JsonSyntaxException expected) {
+      assertEquals(""Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive"",
+          expected.getMessage());
+    }
+  }
+
   private static class ClassWithBigDecimal {
     BigDecimal value;
     ClassWithBigDecimal(String value) {, ","Otherwise if we have a type hierarchy adapter for Vehicle, and we
attempt to decode a JSON string as a Car, we get the right exception
if the JSON string is actually decoded as a Truck.",Fix type hierarchy adapters to do a runtime check.
724,Chris Conroy,['proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java'],"@@ -20,6 +20,7 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Converter;
+import com.google.common.collect.MapMaker;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;
@@ -44,10 +45,10 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * GSON type adapter for protocol buffers that knows how to serialize enums either by using their
@@ -190,6 +191,9 @@ public static Builder newBuilder() {
   private static final com.google.protobuf.Descriptors.FieldDescriptor.Type ENUM_TYPE =
       com.google.protobuf.Descriptors.FieldDescriptor.Type.ENUM;
 
+  private static final ConcurrentMap<String, Map<Class<?>, Method>> mapOfMapOfMethods =
+      new MapMaker().makeMap();
+
   private final EnumSerialization enumSerialization;
   private final Converter<String, String> fieldNameSerializationFormat;
   private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
@@ -380,18 +384,23 @@ private EnumValueDescriptor findValueByNameAndExtension(EnumDescriptor desc,
     }
   }
 
-  private static Method getCachedMethod(Class<?> clazz, String methodName)
-      throws NoSuchMethodException {
-    if (!mapOfMapOfMethods.containsKey(methodName)) {
-      mapOfMapOfMethods.put(methodName, new HashMap<Class<?>, Method>());
-    }
+  private static Method getCachedMethod(Class<?> clazz, String methodName,
+      Class<?>... methodParamTypes) throws NoSuchMethodException {
     Map<Class<?>, Method> mapOfMethods = mapOfMapOfMethods.get(methodName);
-    if (!mapOfMethods.containsKey(clazz)) {
-      mapOfMethods.put(clazz, clazz.getMethod(methodName));
+    if (mapOfMethods == null) {
+      mapOfMethods = new MapMaker().makeMap();
+      Map<Class<?>, Method> previous =
+          mapOfMapOfMethods.putIfAbsent(methodName, mapOfMethods);
+      mapOfMethods = previous == null ? mapOfMethods : previous;
+    }
+
+    Method method = mapOfMethods.get(clazz);
+    if (method == null) {
+      method = clazz.getMethod(methodName, methodParamTypes);
+      mapOfMethods.putIfAbsent(clazz, method);
+      // NB: it doesn't matter which method we return in the event of a race.
     }
-    return mapOfMethods.get(clazz);
+    return method;
   }
 
-  private static Map<String, Map<Class<?>, Method>> mapOfMapOfMethods =
-      new HashMap<String, Map<Class<?>, Method>>();
 }, ",NaN,Thread safe method cache
729,Inderjeet Singh,['gson/pom.xml'],"@@ -189,7 +189,7 @@
            <includePackageNames>com.google.gson</includePackageNames>
            <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
             <links>
-             <link>http://docs.oracle.com/javase/1.5.0/docs/api/</link>
+             <link>http://docs.oracle.com/javase/6/docs/api/</link>
            </links>
            <version>true</version>
            <show>protected</show>, ",Added Overrides for methods implementing an interface.,updated minimum JDK version to 1.6.
730,Inderjeet Singh,"['gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java', 'gson/src/test/java/com/google/gson/functional/MapTest.java']","@@ -16,10 +16,6 @@
 
 package com.google.gson.internal;
 
-import com.google.gson.InstanceCreator;
-import com.google.gson.JsonIOException;
-import com.google.gson.reflect.TypeToken;
-
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.ParameterizedType;
@@ -37,6 +33,14 @@
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentNavigableMap;
+import java.util.concurrent.ConcurrentSkipListMap;
+
+import com.google.gson.InstanceCreator;
+import com.google.gson.JsonIOException;
+import com.google.gson.reflect.TypeToken;
 
 /**
  * Returns a function that can construct an instance of a requested type.
@@ -58,7 +62,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);
     if (typeCreator != null) {
       return new ObjectConstructor<T>() {
-        public T construct() {
+        @Override public T construct() {
           return typeCreator.createInstance(type);
         }
       };
@@ -70,7 +74,7 @@ public T construct() {
         (InstanceCreator<T>) instanceCreators.get(rawType);
     if (rawTypeCreator != null) {
       return new ObjectConstructor<T>() {
-        public T construct() {
+        @Override public T construct() {
           return rawTypeCreator.createInstance(type);
         }
       };
@@ -98,7 +102,7 @@ public T construct() {
       }
       return new ObjectConstructor<T>() {
         @SuppressWarnings(""unchecked"") // T is the same raw type as is requested
-        public T construct() {
+        @Override public T construct() {
           try {
             Object[] args = null;
             return (T) constructor.newInstance(args);
@@ -130,14 +134,14 @@ public T construct() {
     if (Collection.class.isAssignableFrom(rawType)) {
       if (SortedSet.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new TreeSet<Object>();
           }
         };
       } else if (EnumSet.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
           @SuppressWarnings(""rawtypes"")
-          public T construct() {
+          @Override public T construct() {
             if (type instanceof ParameterizedType) {
               Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
               if (elementType instanceof Class) {
@@ -152,42 +156,54 @@ public T construct() {
         };
       } else if (Set.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new LinkedHashSet<Object>();
           }
         };
       } else if (Queue.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new LinkedList<Object>();
           }
         };
       } else {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new ArrayList<Object>();
           }
         };
       }
     }
 
     if (Map.class.isAssignableFrom(rawType)) {
-      if (SortedMap.class.isAssignableFrom(rawType)) {
+      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {
+        return new ObjectConstructor<T>() {
+          @Override public T construct() {
+            return (T) new ConcurrentSkipListMap<Object, Object>();
+          }
+        };
+      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {
+        return new ObjectConstructor<T>() {
+          @Override public T construct() {
+            return (T) new ConcurrentHashMap<Object, Object>();
+          }
+        };
+      } else if (SortedMap.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new TreeMap<Object, Object>();
           }
         };
       } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
           TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new LinkedHashMap<Object, Object>();
           }
         };
       } else {
         return new ObjectConstructor<T>() {
-          public T construct() {
+          @Override public T construct() {
             return (T) new LinkedTreeMap<String, Object>();
           }
         };
@@ -202,7 +218,7 @@ public T construct() {
     return new ObjectConstructor<T>() {
       private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
       @SuppressWarnings(""unchecked"")
-      public T construct() {
+      @Override public T construct() {
         try {
           Object newInstance = unsafeAllocator.newInstance(rawType);
           return (T) newInstance;, @@ -16,6 +16,18 @@
 
 package com.google.gson.functional;
 
+import java.lang.reflect.Type;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentNavigableMap;
+import java.util.concurrent.ConcurrentSkipListMap;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
@@ -33,14 +45,6 @@
 
 import junit.framework.TestCase;
 
-import java.lang.reflect.Type;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
-
 /**
  * Functional test for Json serialization and deserialization for Maps
  *
@@ -179,6 +183,46 @@ public void testSortedMap() throws Exception {
     assertEquals(""456"", map.get(123));
   }
 
+  public void testConcurrentMap() throws Exception {
+    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();
+    ConcurrentMap<Integer, String> map = gson.fromJson(""{\""123\"":\""456\""}"", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals(""456"", map.get(123));
+    String json = gson.toJson(map);
+    assertEquals(""{\""123\"":\""456\""}"", json);
+  }
+
+  public void testConcurrentHashMap() throws Exception {
+    Type typeOfMap = new TypeToken<ConcurrentHashMap<Integer, String>>() {}.getType();
+    ConcurrentHashMap<Integer, String> map = gson.fromJson(""{\""123\"":\""456\""}"", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals(""456"", map.get(123));
+    String json = gson.toJson(map);
+    assertEquals(""{\""123\"":\""456\""}"", json);
+  }
+
+  public void testConcurrentNavigableMap() throws Exception {
+    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();
+    ConcurrentNavigableMap<Integer, String> map = gson.fromJson(""{\""123\"":\""456\""}"", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals(""456"", map.get(123));
+    String json = gson.toJson(map);
+    assertEquals(""{\""123\"":\""456\""}"", json);
+  }
+
+  public void testConcurrentSkipListMap() throws Exception {
+    Type typeOfMap = new TypeToken<ConcurrentSkipListMap<Integer, String>>() {}.getType();
+    ConcurrentSkipListMap<Integer, String> map = gson.fromJson(""{\""123\"":\""456\""}"", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals(""456"", map.get(123));
+    String json = gson.toJson(map);
+    assertEquals(""{\""123\"":\""456\""}"", json);
+  }
+
   public void testParameterizedMapSubclassSerialization() {
     MyParameterizedMap<String, String> map = new MyParameterizedMap<String, String>(10);
     map.put(""a"", ""b"");, ",…vigableMap. This fixes https://github.com/google/gson/issues/624,Added support to serialize/deserialize ConcurrentMap and ConcurrentNa…
731,Inderjeet Singh,['gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentLocksTest.java'],"@@ -29,7 +29,7 @@
 import junit.framework.TestCase;
 
 /**
- * Functional test for Json serialization and deserialization for java.util.concurrent.locks classes
+ * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
  */
 public class JavaUtilConcurrentLocksTest extends TestCase {
   private Gson gson;, ",…IntegerArray.,"Added support for AtomicInteger, AtomicBoolean, AtomicLong and Atomic…"
732,Inderjeet Singh,['gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java'],"@@ -31,7 +31,7 @@
 /**
  * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
  */
-public class JavaUtilConcurrentLocksTest extends TestCase {
+public class JavaUtilConcurrentAtomicTest extends TestCase {
   private Gson gson;
 
   @Override, ",NaN,renamed JavaUtilConcurrentLocksTest to JavaUtilConcurrentAtomicTest
733,Inderjeet Singh,['gson/src/test/java/com/google/gson/functional/JavaUtilTest.java'],"@@ -17,6 +17,7 @@
 package com.google.gson.functional;
 
 import java.util.Currency;
+import java.util.Properties;
 
 import com.google.gson.Gson;
 
@@ -49,4 +50,13 @@ public void testCurrency() throws Exception {
   private static class CurrencyHolder {
     Currency value;
   }
+
+  public void testProperties() {
+    Properties props = gson.fromJson(""{'a':'v1','b':'v2'}"", Properties.class);
+    assertEquals(""v1"", props.getProperty(""a""));
+    assertEquals(""v2"", props.getProperty(""b""));
+    String json = gson.toJson(props);
+    assertTrue(json.contains(""\""a\"":\""v1\""""));
+    assertTrue(json.contains(""\""b\"":\""v2\""""));
+  }
 }, ",NaN,"Supported Currency and added additional tests for Vector, Stack and Properties."
738,Inderjeet Singh,"['gson/src/main/java/com/google/gson/internal/Excluder.java', 'gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java']","@@ -62,7 +62,7 @@
     try {
       return (Excluder) super.clone();
     } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
+      throw new AssertionError(e);
     }
   }
 , @@ -241,7 +241,7 @@ private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundF
           }
         }
       } catch (IllegalAccessException e) {
-        throw new AssertionError();
+        throw new AssertionError(e);
       }
       out.endObject();
     }, ",NaN,Added details and causes while throwing AssertionError
740,,['gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java'],"@@ -345,42 +345,4 @@ private static int indexOfNonDigit(String string, int offset) {
         return string.length();
     }
 
-    public static void main(String[] args)
-    {
-        final int REPS = 250000;
-        while (true) {
-            long start = System.currentTimeMillis();
-            int resp = test1(REPS, 3);
-            long msecs = System.currentTimeMillis() - start;
-            System.out.println(""Pow (""+resp+"") -> ""+msecs+"" ms"");
-
-            start = System.currentTimeMillis();
-            resp = test2(REPS, 3);
-            msecs = System.currentTimeMillis() - start;
-            System.out.println(""Iter (""+resp+"") -> ""+msecs+"" ms"");
-        }
-    }
-
-    static int test1(int reps, int pow)
-    {
-        int resp = 3;
-        while (--reps >= 0) {
-            resp = (int) Math.pow(10, pow);
-        }
-        return resp;
-    }
-
-    static int test2(int reps, int pow)
-    {
-        int resp = 3;
-        while (--reps >= 0) {
-            resp = 10;
-            int p = pow;
-
-            while (--p > 0) {
-                resp *= 10;
-            }
-        }
-        return resp;
-    }
 }, ","Added support for all ISO8601 formats, including milliseconds. You already have `UtcDateTypeAdapter` in `gson-extras` project, which was using the code from https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java to parse dates. Therefore I did the same, I created an utils class in gson project with that code and made it used by `DateTypeAdapter` and `DefaultDateTypeAdapter`",ISO8601 Date deserialization
743,Pi Delport,['README.md'],"@@ -16,9 +16,9 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
 
 *Gson Documentation*
   * Gson [API](http://google.github.io/gson/apidocs/): Javadocs for the current Gson release
-  * Gson [user guide](http://sites.google.com/site/gson/gson-user-guide): This guide contains examples on how to use Gson in your code.
-  * Gson [Roadmap](https://sites.google.com/site/gson/gson-roadmap): Details on upcoming releases 
-  * Gson [design document](https://sites.google.com/site/gson/gson-design-document): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+  * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
+  * Gson [Roadmap](https://github.com/google/gson/blob/master/ReleaseProcess.md): Details on upcoming releases 
+  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
 
 Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
 , ",NaN,README: Update old Google Sites links to GitHub
745,Misha Brukman,"['README.md', 'UserGuide.md']","@@ -5,7 +5,7 @@ Gson can work with arbitrary Java objects including pre-existing objects that yo
 There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
 
 *Gson Goals*
-  * Provide simple toJson() and fromJson() methods to convert Java objects to JSON and vice-versa
+  * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects, @@ -52,17 +52,17 @@ Gson can work with arbitrary Java objects including pre-existing objects that yo
 
 Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class [PerformanceTest](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java).
 
-*   Strings: Deserialized strings of over 25MB without any problems (see <span style=""font-family:courier new,monospace"">disabled_testStringDeserializationPerformance</span> method in <span style=""font-family:courier new,monospace"">PerformanceTest</span>)
+*   Strings: Deserialized strings of over 25MB without any problems (see `disabled_testStringDeserializationPerformance` method in `PerformanceTest`)
 
 *   Large collections:
 
-*   Serialized a collection of 1.4 million objects (see <span style=""font-family:courier new,monospace"">disabled_testLargeCollectionSerialization</span> method in <span style=""font-family:courier new,monospace"">PerformanceTest</span>)
+*   Serialized a collection of 1.4 million objects (see `disabled_testLargeCollectionSerialization` method in `PerformanceTest`)
 
-*   Deserialized a collection of 87,000 objects (see <span style=""font-family:courier new,monospace"">disabled_testLargeCollectionDeserialization</span> in <span style=""font-family:courier new,monospace"">PerformanceTest</span>)
+*   Deserialized a collection of 87,000 objects (see `disabled_testLargeCollectionDeserialization` in `PerformanceTest`)
 
 *   Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.
 
-Note: Delete the <span style=""font-family:courier new,monospace"">disabled_</span> prefix to run these tests. We use this prefix to prevent running these tests every time we run junit tests.
+Note: Delete the `disabled_` prefix to run these tests. We use this prefix to prevent running these tests every time we run junit tests.
 
 ## <a name=""TOC-Gson-Users""></a>Gson Users
 
@@ -211,20 +211,20 @@ Collection<Integer> ints2 = gson.fromJson(json, collectionType);
 ints2 is same as ints
 ```
 
-Fairly hideous: note how we define the type of collection
-Unfortunately, no way to get around this in Java</font></span>
+Fairly hideous: note how we define the type of collection.
+Unfortunately, there is no way to get around this in Java.
 
 #### <a name=""TOC-Collections-Limitations""></a>Collections Limitations
 
 *   Can serialize collection of arbitrary objects but can not deserialize from it
 *   Because there is no way for the user to indicate the type of the resulting object
 *   While deserializing, Collection must be of a specific generic type
 
-All of this makes sense, and is rarely a problem when following good Java coding practices
+All of this makes sense, and is rarely a problem when following good Java coding practices.
 
 ### <a name=""TOC-Serializing-and-Deserializing-Generic-Types""></a>Serializing and Deserializing Generic Types
 
-When you call `toJson(obj)`, Gson calls `obj.getClass()` to get information on the fields to serialize. Similarly, you can typically pass <span style=""font-family:courier new,monospace"">MyClass.class</span> object in the <span style=""font-family:courier new,monospace"">fromJson(json, MyClass.class)</span> method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:
+When you call `toJson(obj)`, Gson calls `obj.getClass()` to get information on the fields to serialize. Similarly, you can typically pass `MyClass.class` object in the `fromJson(json, MyClass.class)` method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:
 ```
 class Foo<T> {
   T value;
@@ -236,9 +236,9 @@ gson.toJson(foo); // May not serialize foo.value correctly
 gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
 ```
 
-The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, <span style=""font-family:courier new,monospace"">Foo.class</span>. This means that Gson has no way of knowing that this is an object of type Foo<Bar>, and not just plain Foo.
+The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
 
-You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [TypeToken](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
+You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
 ```
 Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
 gson.toJson(foo, fooType);
@@ -348,22 +348,21 @@ Often you want to register a single handler for all generic types corresponding
   *   Essentially write out the id value
 
 *   Deserialization is very similar but not exactly the same
-  *   Need to call <span style=""font-family:courier new,monospace"">""new Id(Class<T>, String)""</span> which returns an instance of Id<T>
+  *   Need to call `new Id(Class<T>, String)` which returns an instance of `Id<T>`
 
-Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say <span style=""font-family:courier new,monospace"">Id<RequiresSpecialHandling></span> needed special handling).
-The <span style=""font-family:courier new,monospace"">Type</span> parameter for the <span style=""font-family:courier new,monospace"">toJson</span> and <span style=""font-family:courier new,monospace"">fromJson</span> contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type
+Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say `Id<RequiresSpecialHandling>` needed special handling).
+The `Type` parameter for the `toJson` and `fromJson` contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.
 
 ### <a name=""TOC-Writing-an-Instance-Creator""></a>Writing an Instance Creator
 
-While deserializing an Object, Gson needs to create a default instance of the class
-Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor
+While deserializing an Object, Gson needs to create a default instance of the class.
+Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.
 
 *   Doesn't matter whether public or private
 
 Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor
 
-**
-Instance Creator Example**
+**Instance Creator Example**
 
 ```
 private class MoneyInstanceCreator implements InstanceCreator<Money> {
@@ -393,7 +392,7 @@ class MyListInstanceCreator implements InstanceCreator<MyList<?>> {
   }
 }
 ```
-However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the <span style=""font-family:courier new,monospace"">createInstance</span> method. Here is an example:
+However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the `createInstance` method. Here is an example:
 ```
 public class Id<T> {
   private final Class<T> classOfId;
@@ -413,15 +412,15 @@ class IdInstanceCreator implements InstanceCreator<Id<?>> {
 }
 ```
 
-In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, <span style=""font-family:courier new,monospace"">type</span>. The <span style=""font-family:courier new,monospace"">type</span> object in this case is the Java parameterized type representation of <span style=""font-family:courier new,monospace"">Id<Foo></span> where the actual instance should be bound to <span style=""font-family:courier new,monospace"">Id<Foo></span>. Since <span style=""font-family:courier new,monospace"">Id</span> class has just one parameterized type parameter, <span style=""font-family:courier new,monospace"">T</span>, we use the zeroth element of the type array returned by <span style=""font-family:courier new,monospace"">getActualTypeArgument()</span> which will hold <span style=""font-family:courier new,monospace"">Foo.class</span> in this case.
+In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, `type`. The `type` object in this case is the Java parameterized type representation of `Id<Foo>` where the actual instance should be bound to `Id<Foo>`. Since `Id` class has just one parameterized type parameter, `T`, we use the zeroth element of the type array returned by `getActualTypeArgument()` which will hold `Foo.class` in this case.
 
 ### <a name=""TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format""></a>Compact Vs. Pretty Printing for JSON Output Format
 
 The default JSON output that is provide by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, ""null"" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the [Null Object Support](#TOC-Null-Object-Support) section for information on configure Gson to output all null values.
 
-If you like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default <span style=""font-family:courier new,monospace"">JsonPrintFormatter</span> that has default line length of 80 character, 2 character indentation, and 4 character right margin.
+If you like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default `JsonPrintFormatter` that has default line length of 80 character, 2 character indentation, and 4 character right margin.
 
-The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the <span style=""font-family:courier new,monospace"">JsonCompactFormatter</span>:
+The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the `JsonCompactFormatter`:
 ```
 Gson gson = new GsonBuilder().setPrettyPrinting().create();
 String jsonOutput = gson.toJson(someObject);
@@ -465,7 +464,7 @@ null
 ```
 ### <a name=""TOC-Versioning-Support""></a>Versioning Support
 
-Multiple versions of the same object can be maintained by using [@Since](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/annotations/Since.java ""@Since"") annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your <span style=""font-family:courier new,monospace"">Gson</span> instance to ignore any field/object that is greater than some version number. If no version is set on the <span style=""font-family:courier new,monospace"">Gson</span> instance then it will serialize and deserialize all fields and classes regardless of the version.
+Multiple versions of the same object can be maintained by using [@Since](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/annotations/Since.java ""@Since"") annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your `Gson` instance to ignore any field/object that is greater than some version number. If no version is set on the `Gson` instance then it will serialize and deserialize all fields and classes regardless of the version.
 ```
 public class VersionedClass {
   @Since(1.1) private final String newerField;
@@ -517,11 +516,11 @@ Gson gson = new GsonBuilder()
 
 #### <a name=""TOC-Gson-s-Expose""></a>Gson's @Expose
 
-This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using <span style=""font-family:courier new,monospace"">new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</span>. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
+This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using `new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()`. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
 
 #### <a name=""TOC-User-Defined-Exclusion-Strategies""></a>User Defined Exclusion Strategies
 
-If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [<span style=""font-family:courier new,monospace"">ExclusionStrategy</span>](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
 
 The following example shows how to exclude fields marked with a specific ""@Foo"" annotation and excludes top-level types (or declared field type) of class String.
 ```
@@ -575,7 +574,7 @@ The following example shows how to exclude fields marked with a specific ""@Foo""
 ```
 ### <a name=""TOC-JSON-Field-Naming-Support""></a>JSON Field Naming Support
 
-Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e. camel cased names starting with lower case --- ""sampleFieldNameInJava"") to a Json field name (i.e. sample_field_name_in_java or SampleFieldNameInJava). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
+Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
 
 It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise ""Runtime"" exceptions if an invalid field name is provided as the annotation value.
 , ",Also fixed minor grammar issues.,Added code formatting; removed HTML tags.
746,Misha Brukman,"['LICENSE', 'README.md']","@@ -1,13 +1,202 @@
-Copyright 2008 Google Inc. 
 
-Licensed under the Apache License, Version 2.0 (the ""License"");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
 
-    http://www.apache.org/licenses/LICENSE-2.0
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an ""AS IS"" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+   1. Definitions.
+
+      ""License"" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      ""Licensor"" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      ""Legal Entity"" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      ""control"" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      ""You"" (or ""Your"") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      ""Source"" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      ""Object"" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      ""Work"" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      ""Derivative Works"" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      ""Contribution"" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, ""submitted""
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as ""Not a Contribution.""
+
+      ""Contributor"" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a ""NOTICE"" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an ""AS IS"" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets ""[]""
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same ""printed page"" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the ""License"");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an ""AS IS"" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License., @@ -24,3 +24,23 @@ Please use the [google-gson Google group](http://groups.google.com/group/google-
 
 *Gson-related Content Created by Third Parties*
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
+
+*License*
+
+Gson is released under the [Apache 2.0 license](LICENSE).
+
+```
+Copyright 2008 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```, ",NaN,Add full license text for Apache License 2.0
747,Misha Brukman,['UserGuide.md'],"@@ -38,39 +38,35 @@
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
 
-Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.
 
 ## <a name=""TOC-Goals-for-Gson""></a>Goals for Gson
 
-*   Provide easy to use mechanisms like `toString()` and constructor (factory method) to convert Java to JSON and vice-versa
-*   Allow pre-existing unmodifiable objects to be converted to and from JSON
-*   Allow custom representations for objects
-*   Support arbitrarily complex object
-*   Generate compact and readability JSON output
+* Provide easy to use mechanisms like `toString()` and constructor (factory method) to convert Java to JSON and vice-versa
+* Allow pre-existing unmodifiable objects to be converted to and from JSON
+* Allow custom representations for objects
+* Support arbitrarily complex objects
+* Generate compact and readability JSON output
 
 ## <a name=""TOC-Gson-Performance-and-Scalability""></a>Gson Performance and Scalability
 
-Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class [PerformanceTest](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java).
+Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class [`PerformanceTest`](gson/src/test/java/com/google/gson/metrics/PerformanceTest.java).
 
-*   Strings: Deserialized strings of over 25MB without any problems (see `disabled_testStringDeserializationPerformance` method in `PerformanceTest`)
+* Strings: Deserialized strings of over 25MB without any problems (see `disabled_testStringDeserializationPerformance` method in `PerformanceTest`)
+* Large collections:
+  * Serialized a collection of 1.4 million objects (see `disabled_testLargeCollectionSerialization` method in `PerformanceTest`)
+  * Deserialized a collection of 87,000 objects (see `disabled_testLargeCollectionDeserialization` in `PerformanceTest`)
+* Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.
 
-*   Large collections:
-
-*   Serialized a collection of 1.4 million objects (see `disabled_testLargeCollectionSerialization` method in `PerformanceTest`)
-
-*   Deserialized a collection of 87,000 objects (see `disabled_testLargeCollectionDeserialization` in `PerformanceTest`)
-
-*   Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.
-
-Note: Delete the `disabled_` prefix to run these tests. We use this prefix to prevent running these tests every time we run junit tests.
+Note: Delete the `disabled_` prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.
 
 ## <a name=""TOC-Gson-Users""></a>Gson Users
 
 Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details [here](https://sites.google.com/site/gson/gson-users).
 
 ## <a name=""TOC-Using-Gson""></a>Using Gson
 
-The primary class to use is [Gson](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/Gson.java ""Gson"") which you can just create by calling new Gson(). There is also a class [GsonBuilder](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/GsonBuilder.java ""GsonBuilder"") available that can be used to create a Gson instance with various settings like version control and so on.
+The primary class to use is [`Gson`](gson/src/main/java/com/google/gson/Gson.java) which you can just create by calling `new Gson()`. There is also a class [`GsonBuilder`](gson/src/main/java/com/google/gson/GsonBuilder.java) available that can be used to create a Gson instance with various settings like version control and so on.
 
 The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.
 
@@ -135,14 +131,14 @@ BagOfPrimitives obj2 =gson.fromJson(json, BagOfPrimitives.class);
 
 #### <a name=""TOC-Finer-Points-with-Objects""></a>**Finer Points with Objects**
 
-*   It is perfectly fine (and recommended) to use private fields
-*   There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
-*   If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
-*   This implementation handles nulls correctly
-*   While serialization, a null field is skipped from the output
-*   While deserialization, a missing entry in JSON results in setting the corresponding field in the object to null
-*   If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
-*   Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
+* It is perfectly fine (and recommended) to use private fields
+* There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
+* If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
+* This implementation handles nulls correctly
+* While serialization, a null field is skipped from the output
+* While deserialization, a missing entry in JSON results in setting the corresponding field in the object to null
+* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
+* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
 
 ### <a name=""TOC-Nested-Classes-including-Inner-Classes-""></a>Nested Classes (including Inner Classes)
 
@@ -216,9 +212,9 @@ Unfortunately, there is no way to get around this in Java.
 
 #### <a name=""TOC-Collections-Limitations""></a>Collections Limitations
 
-*   Can serialize collection of arbitrary objects but can not deserialize from it
-*   Because there is no way for the user to indicate the type of the resulting object
-*   While deserializing, Collection must be of a specific generic type
+* Can serialize collection of arbitrary objects but can not deserialize from it
+* Because there is no way for the user to indicate the type of the resulting object
+* While deserializing, Collection must be of a specific generic type
 
 All of this makes sense, and is rarely a problem when following good Java coding practices.
 
@@ -273,13 +269,13 @@ class Event {
 
 You can serialize the collection with Gson without doing anything specific: `toJson(collection)` would write out the desired output.
 
-However, deserialization with `fromJson(json, Collection.class)` will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in fromJson. So, you have three options:
+However, deserialization with `fromJson(json, Collection.class)` will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in `fromJson()`. So, you have three options:
 
-Option 1: Use Gson's parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use Gson.fromJson() on each of the array elements.This is the preferred approach. [Here is an example](http://code.google.com/p/google-gson/source/browse/trunk/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java) that demonstrates how to do this.
+1. Use Gson's parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use `Gson.fromJson()` on each of the array elements.This is the preferred approach. [Here is an example](extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java) that demonstrates how to do this.
 
-Option 2: Register a type adapter for Collection.class that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.
+2. Register a type adapter for `Collection.class` that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.
 
-Option 3: Register a type adapter for MyCollectionMemberType and use fromJson with Collection<MyCollectionMemberType>
+3. Register a type adapter for `MyCollectionMemberType` and use `fromJson()` with `Collection<MyCollectionMemberType>`.
 
 This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type `Collection<MyCollectionMemberType>`.
 
@@ -288,20 +284,20 @@ This approach is practical only if the array appears as a top-level element or i
 Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
 Here is a list of such classes:
 
-1.  `java.net.URL` to match it with strings like ""http://code.google.com/p/google-gson/"".
-2.  `java.net.URI` to match it with strings like ""/p/google-gson/"".
+1. `java.net.URL` to match it with strings like `""https://github.com/google/gson/""`
+2. `java.net.URI` to match it with strings like `""/google/gson/""`
 
-You can also find source-code for some commonly used classes such as JodaTime at [this page](https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1).
+You can also find source code for some commonly used classes such as JodaTime at [this page](https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1).
 
 ### <a name=""TOC-Custom-Serialization-and-Deserialization""></a>Custom Serialization and Deserialization
 
 Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
 Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:
 
-*   Json Serialiers: Need to define custom serialization for an object
-*   Json Deserializers: Needed to define custom deserialization for a type
+* Json Serialiers: Need to define custom serialization for an object
+* Json Deserializers: Needed to define custom deserialization for a type
 
-*   Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
+* Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
 ```
 GsonBuilder gson = new GsonBuilder();
 gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
@@ -343,22 +339,21 @@ Gson calls `deserialize` when it needs to deserialize a JSON string fragment int
 
 Often you want to register a single handler for all generic types corresponding to a raw type
 
-*   For example, suppose you have an ""Id"" class for Id representation/translation (i.e. an internal vs. external representation).
-*   `Id<T>` type that has same serialization for all generic types
-  *   Essentially write out the id value
-
-*   Deserialization is very similar but not exactly the same
-  *   Need to call `new Id(Class<T>, String)` which returns an instance of `Id<T>`
+* For example, suppose you have an `Id` class for id representation/translation (i.e. an internal vs. external representation).
+* `Id<T>` type that has same serialization for all generic types
+  * Essentially write out the id value
+* Deserialization is very similar but not exactly the same
+  * Need to call `new Id(Class<T>, String)` which returns an instance of `Id<T>`
 
 Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say `Id<RequiresSpecialHandling>` needed special handling).
-The `Type` parameter for the `toJson` and `fromJson` contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.
+The `Type` parameter for the `toJson()` and `fromJson()` contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.
 
 ### <a name=""TOC-Writing-an-Instance-Creator""></a>Writing an Instance Creator
 
 While deserializing an Object, Gson needs to create a default instance of the class.
 Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.
 
-*   Doesn't matter whether public or private
+* Doesn't matter whether public or private
 
 Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor
 
@@ -374,8 +369,8 @@ private class MoneyInstanceCreator implements InstanceCreator<Money> {
 
 Type could be of a corresponding generic type
 
-*   Very useful to invoke constructors which need specific generic type information
-*   For example, if the `Id` class stores the class for which the Id is being created
+* Very useful to invoke constructors which need specific generic type information
+* For example, if the `Id` class stores the class for which the Id is being created
 
 #### <a name=""TOC-InstanceCreator-for-a-Parameterized-Type""></a>InstanceCreator for a Parameterized Type
 
@@ -464,7 +459,7 @@ null
 ```
 ### <a name=""TOC-Versioning-Support""></a>Versioning Support
 
-Multiple versions of the same object can be maintained by using [@Since](http://code.google.com/p/google-gson/source/browse/trunk/gson/src/main/java/com/google/gson/annotations/Since.java ""@Since"") annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your `Gson` instance to ignore any field/object that is greater than some version number. If no version is set on the `Gson` instance then it will serialize and deserialize all fields and classes regardless of the version.
+Multiple versions of the same object can be maintained by using [@Since](gson/src/main/java/com/google/gson/annotations/Since.java) annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your `Gson` instance to ignore any field/object that is greater than some version number. If no version is set on the `Gson` instance then it will serialize and deserialize all fields and classes regardless of the version.
 ```
 public class VersionedClass {
   @Since(1.1) private final String newerField;
@@ -520,9 +515,9 @@ This feature provides a way where you can mark certain fields of your objects to
 
 #### <a name=""TOC-User-Defined-Exclusion-Strategies""></a>User Defined Exclusion Strategies
 
-If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
 
-The following example shows how to exclude fields marked with a specific ""@Foo"" annotation and excludes top-level types (or declared field type) of class String.
+The following example shows how to exclude fields marked with a specific `@Foo` annotation and excludes top-level types (or declared field type) of class `String`.
 ```
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ElementType.FIELD})
@@ -605,9 +600,9 @@ If you have a need for custom naming policy ([see this discussion](http://groups
 
 Sometimes you need to share state across custom serializers/deserializers ([see this discussion](http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb)). You can use the following three strategies to accomplish this:
 
-1.  Store shared state in static fields
-2.  Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state
-3.  Use Java ThreadLocal
+1. Store shared state in static fields
+2. Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state
+3. Use Java `ThreadLocal`
 
 1 and 2 are not thread-safe options, but 3 is.
 
@@ -621,4 +616,4 @@ See the [Gson design document](https://sites.google.com/site/gson/gson-design-do
 
 ## <a name=""TOC-Future-Enhancements-to-Gson""></a>Future Enhancements to Gson
 
-For the latest list of proposed enhancements or if you'd like to suggest new ones, see the [Issues section](http://code.google.com/p/google-gson/issues/list ""Issues section"") under the project website.
+For the latest list of proposed enhancements or if you'd like to suggest new ones, see the [Issues section](https://github.com/google/gson/issues) under the project website., ","- Removed extra spacing after bullets in list
- Removed extra blank lines; fixed indentation
- Fixed all links (including examples) to code.google.com to use github.com
  instead; deep links to code.google.com redirect to top-level GitHub project
  page, thus rendering them useless
- Removed extra strings in Markdown link targets
- Fixed capitalization and grammar
- Added more code formatting","Docs fixes: markdown, links, formatting."
748,Misha Brukman,['ReleaseProcess.md'],"@@ -3,54 +3,105 @@
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
-2. Edit pom.xml and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
+2. Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
 3. Ensure all changelists are code-reviewed and have +1
-4. Ensure that your ~/.m2/settings.xml is configured properly (see steps below)
-5. cd gson. Ensure there are no open files and all changes are committed. 
+4. Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
+5. `cd gson`; ensure there are no open files and all changes are committed.
 6. Run `mvn release:clean`
 7. Do a dry run: `mvn release:prepare -DdryRun=true`
 8. Start the release: `mvn release:prepare`
-  * Answer questions: usually the defaults are fine. 
-  * This will do a full build, change version from -SNAPSHOT to the released version, commit and create the tags. It will then change the version to -SNAPSHOT for the next release.
-9. Ensure you have defined `sonatype-nexus-staging` in your maven `settings.xml` and run `mvn -s /home/<username>/.m2/settings.xml  release:perform`
-10. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and javadoc jars.
-  * `cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2  /tmp; cd /tmp/1.7.2`
-  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2-javadoc.jar -Dclassifier=javadoc`
-  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2-sources.jar -Dclassifier=sources`
-  * `mvn gpg:sign-and-deploy-file -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ -DrepositoryId=sonatype-nexus-staging -DpomFile=gson-1.7.2.pom -Dfile=gson-1.7.2.jar`
-11. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+  * Answer questions: usually the defaults are fine.
+  * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
+9. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
+
+   ```bash
+   mvn -s /home/<username>/.m2/settings.xml release:perform
+   ```
+
+10. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
+
+  ```bash
+  cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
+  cd /tmp/1.7.2
+
+  mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2-javadoc.jar \
+      -Dclassifier=javadoc
+
+  mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2-sources.jar \
+      -Dclassifier=sources
+
+  mvn gpg:sign-and-deploy-file \
+      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
+      -DrepositoryId=sonatype-nexus-staging \
+      -DpomFile=gson-1.7.2.pom \
+      -Dfile=gson-1.7.2.jar
+  ```
+
+11. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
 12. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
 13. Publishing Javadocs
-  * Switch to the branch `gh-pages`
-  * `jar xvf /tmp/2.5/gson-2.5-javadoc.jar`
-  * `git commit -m 'updated javadocs to 2.5'`
+
+  ```bash
+  # Switch to the branch `gh-pages`
+  git checkout gh-pages
+
+  # Unpack the generated Javadoc
+  jar xvf /tmp/2.5/gson-2.5-javadoc.jar
+
+  # Commit the new Javadoc
+  git commit -m 'Updated Javadoc to 2.5'
+
+  # Push changes to GitHub
+  git push
+  ```
+
 14. Update the version in the [Using Gson with Maven2 page](https://sites.google.com/site/gson/gson-user-guide/using-gson-with-maven2)
 15. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
 16. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
 17. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current ""stable"" release.
 
 ## Configuring a machine for deployment to Sonatype Repository
 
-(Borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease)).
+This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
 
 1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
 2. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
 3. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
 4. Now for deploying a snapshot repository, use `mvn deploy`.
 
 ## Getting Maven Publishing Privileges
-Based on Gson group thread: https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion
 
-1. Signup for a Sonatype account following instructions under 2) at https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
+Based on [Gson group thread](https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion):
+
+1. [Sign up for a Sonatype account](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide) following instructions under (2) on that page
 2. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
 
 ## Running Benchmarks or Tests on Android
-Download vogar
-Put `adb` on your `$PATH` and run:
-`vogar --benchmark --classpath gson.jar path/to/Benchmark.java`
 
-For example, here is how to run the CollectionsDeserializationBenchmark:
+* Download vogar
+* Put `adb` on your `$PATH` and run:
+
+  ```bash
+  vogar --benchmark --classpath gson.jar path/to/Benchmark.java
+  ```
+
+For example, here is how to run the [CollectionsDeserializationBenchmark](gson/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java):
 
-`export ANDROID_HOME=~/apps/android-sdk-mac_x86
+```bash
+export ANDROID_HOME=~/apps/android-sdk-mac_x86
 export PATH=$PATH:$ANDROID_HOME/platform-tools/:$ANDROID_HOME/android-sdk-mac_x86/tools/
-$VOGAR_HOME/bin/vogar  --benchmark --sourcepath ../gson/src/main/java/  src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java -- --vm ""app_process -Xgc:noconcurrent,app_process""`
+$VOGAR_HOME/bin/vogar \
+    --benchmark \
+    --sourcepath ../gson/src/main/java/ \
+    src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java \
+    -- \
+    --vm ""app_process -Xgc:noconcurrent,app_process""
+```, ","- Formatted multi-line and complex commands via multi-line blocks and
  line-wrapping for readability and ease of copy-pasting
- Hid URLs behind text links for readability and brevity
- Added missing code formatting, both inline and blocks

You can see what the new page looks like in its entirety via [my branch](https://github.com/mbrukman/gson/blob/docs-release-process/ReleaseProcess.md).",Release process: cleanups and formatting fixes
749,Misha Brukman,['UserGuide.md'],"@@ -26,7 +26,7 @@
   * [Versioning Support](#TOC-Versioning-Support)
   * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
     * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
-    * [Gson's @Expose](#TOC-Gson-s-Expose)
+    * [Gson's `@Expose`](#TOC-Gson-s-Expose)
     * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
   * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
   * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
@@ -72,7 +72,8 @@ The Gson instance does not maintain any state while invoking Json operations. So
 
 ## <a name=""TOC-Gson-With-Maven""></a>Using Gson with Maven
 To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:
-```
+
+```xml
 <dependencies>
     <!--  Gson: Java to Json conversion -->
     <dependency>
@@ -83,19 +84,21 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     </dependency>
 </dependencies>
 ```
+
 That is it, now your maven project is Gson enabled. 
 
 ### <a name=""TOC-Primitives-Examples""></a>Primitives Examples
-```
-(Serialization)
+
+```java
+// Serialization
 Gson gson = new Gson();
-gson.toJson(1);            ==> prints 1
-gson.toJson(""abcd"");       ==> prints ""abcd""
-gson.toJson(new Long(10)); ==> prints 10
+gson.toJson(1);            // ==> 1
+gson.toJson(""abcd"");       // ==> ""abcd""
+gson.toJson(new Long(10)); // ==> 10
 int[] values = { 1 };
-gson.toJson(values);       ==> prints [1]
+gson.toJson(values);       // ==> [1]
 
-(Deserialization)
+// Deserialization
 int one = gson.fromJson(""1"", int.class);
 Integer one = gson.fromJson(""1"", Integer.class);
 Long one = gson.fromJson(""1"", Long.class);
@@ -105,7 +108,8 @@ String anotherStr = gson.fromJson(""[\""abc\""]"", String.class);
 ```
 
 ### <a name=""TOC-Object-Examples""></a>Object Examples
-```
+
+```java
 class BagOfPrimitives {
   private int value1 = 1;
   private String value2 = ""abc"";
@@ -114,19 +118,21 @@ class BagOfPrimitives {
     // no-args constructor
   }
 }
-(Serialization)
+
+// Serialization
 BagOfPrimitives obj = new BagOfPrimitives();
 Gson gson = new Gson();
 String json = gson.toJson(obj);  
 
-==> json is {""value1"":1,""value2"":""abc""}
+// ==> json is {""value1"":1,""value2"":""abc""}
 ```
 
 Note that you can not serialize objects with circular references since that will result in infinite recursion.
-```
-(Deserialization)
-BagOfPrimitives obj2 =gson.fromJson(json, BagOfPrimitives.class);
-==> obj2 is just like obj
+
+```java
+// Deserialization
+BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
+// ==> obj2 is just like obj
 ```
 
 #### <a name=""TOC-Finer-Points-with-Objects""></a>**Finer Points with Objects**
@@ -146,7 +152,7 @@ Gson can serialize static nested classes quite easily.
 
 Gson can also deserialize static nested classes. However, Gson can **not** automatically deserialize the **pure inner classes since their no-args constructor also need a reference to the containing Object** which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:
 
-```
+```java
 public class A { 
   public String a; 
 
@@ -160,11 +166,12 @@ public class A {
   } 
 }
 ```
+
 **NOTE**: The above class B can not (by default) be serialized with Gson.
 
 Gson can not deserialize `{""b"":""abc""}` into an instance of B since the class B is an inner class. if it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B. 
 
-```
+```java
 public class InstanceCreatorForB implements InstanceCreator<A.B> {
   private final A a;
   public InstanceCreatorForB(A a)  {
@@ -175,36 +182,40 @@ public class InstanceCreatorForB implements InstanceCreator<A.B> {
   }
 }
 ```
+
 The above is possible, but not recommended.
 
 ### <a name=""TOC-Array-Examples""></a>Array Examples
-```
+
+```java
 Gson gson = new Gson();
 int[] ints = {1, 2, 3, 4, 5};
 String[] strings = {""abc"", ""def"", ""ghi""};
 
-(Serialization)
-gson.toJson(ints);     ==> prints [1,2,3,4,5]
-gson.toJson(strings);  ==> prints [""abc"", ""def"", ""ghi""]
+// Serialization
+gson.toJson(ints);     // ==> [1,2,3,4,5]
+gson.toJson(strings);  // ==> [""abc"", ""def"", ""ghi""]
 
-(Deserialization)
+// Deserialization
 int[] ints2 = gson.fromJson(""[1,2,3,4,5]"", int[].class); 
-==> ints2 will be same as ints
+// ==> ints2 will be same as ints
 ```
+
 We also support multi-dimensional arrays, with arbitrarily complex element types.
 
 ### <a name=""TOC-Collections-Examples""></a>Collections Examples
-```
+
+```java
 Gson gson = new Gson();
 Collection<Integer> ints = Lists.immutableList(1,2,3,4,5);
 
-(Serialization)
-String json = gson.toJson(ints); ==> json is [1,2,3,4,5]
+// Serialization
+String json = gson.toJson(ints);  // ==> json is [1,2,3,4,5]
 
-(Deserialization)
+// Deserialization
 Type collectionType = new TypeToken<Collection<Integer>>(){}.getType();
 Collection<Integer> ints2 = gson.fromJson(json, collectionType);
-ints2 is same as ints
+// ==> ints2 is same as ints
 ```
 
 Fairly hideous: note how we define the type of collection.
@@ -221,7 +232,8 @@ All of this makes sense, and is rarely a problem when following good Java coding
 ### <a name=""TOC-Serializing-and-Deserializing-Generic-Types""></a>Serializing and Deserializing Generic Types
 
 When you call `toJson(obj)`, Gson calls `obj.getClass()` to get information on the fields to serialize. Similarly, you can typically pass `MyClass.class` object in the `fromJson(json, MyClass.class)` method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:
-```
+
+```java
 class Foo<T> {
   T value;
 }
@@ -235,7 +247,8 @@ gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
 The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
 
 You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
-```
+
+```java
 Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
 gson.toJson(foo, fooType);
 
@@ -248,15 +261,18 @@ The idiom used to get `fooType` actually defines an anonymous local inner class
 Sometimes you are dealing with JSON array that contains mixed types. For example:
 `['hello',5,{name:'GREETINGS',source:'guest'}]`
 
-The equivalent Collection containing this is:
-```
+The equivalent `Collection` containing this is:
+
+```java
 Collection collection = new ArrayList();
 collection.add(""hello"");
 collection.add(5);
 collection.add(new Event(""GREETINGS"", ""guest""));
 ```
-Where the Event class is defined as:
-```
+
+where the `Event` class is defined as:
+
+```java
 class Event {
   private String name;
   private String source;
@@ -298,7 +314,8 @@ Gson allows you to register your own custom serializers and deserializers. This
 * Json Deserializers: Needed to define custom deserialization for a type
 
 * Instance Creators: Not needed if no-args constructor is available or a deserializer is registered
-```
+
+```java
 GsonBuilder gson = new GsonBuilder();
 gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
 gson.registerTypeAdapter(MyType.class, new MySerializer());
@@ -311,7 +328,8 @@ gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());
 #### <a name=""TOC-Writing-a-Serializer""></a>Writing a Serializer
 
 Here is an example of how to write a custom serializer for JodaTime `DateTime` class.
-```
+
+```java
 private class DateTimeSerializer implements JsonSerializer<DateTime> {
   public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
     return new JsonPrimitive(src.toString());
@@ -324,7 +342,8 @@ Gson calls `serialize()` when it runs into a `DateTime` object during serializat
 #### <a name=""TOC-Writing-a-Deserializer""></a>Writing a Deserializer
 
 Here is an example of how to write a custom deserializer for JodaTime DateTime class.
-```
+
+```java
 private class DateTimeDeserializer implements JsonDeserializer<DateTime> {
   public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
       throws JsonParseException {
@@ -359,7 +378,7 @@ Typically, Instance Creators are needed when you are dealing with a library clas
 
 **Instance Creator Example**
 
-```
+```java
 private class MoneyInstanceCreator implements InstanceCreator<Money> {
   public Money createInstance(Type type) {
     return new Money(""1000000"", CurrencyCode.USD);
@@ -375,7 +394,8 @@ Type could be of a corresponding generic type
 #### <a name=""TOC-InstanceCreator-for-a-Parameterized-Type""></a>InstanceCreator for a Parameterized Type
 
 Sometimes that the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:
-```
+
+```java
 class MyList<T> extends ArrayList<T> {
 }
 
@@ -387,8 +407,10 @@ class MyListInstanceCreator implements InstanceCreator<MyList<?>> {
   }
 }
 ```
+
 However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the `createInstance` method. Here is an example:
-```
+
+```java
 public class Id<T> {
   private final Class<T> classOfId;
   private final long value;
@@ -425,12 +447,16 @@ String jsonOutput = gson.toJson(someObject);
 The default behaviour that is implemented in Gson is that `null` object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java.
 
 Here's how you would configure a `Gson` instance to output null:
-`Gson gson = new GsonBuilder().serializeNulls().create();`
+
+```java
+Gson gson = new GsonBuilder().serializeNulls().create();
+```
 
 NOTE: when serializing `null`s with Gson, it will add a `JsonNull` element to the `JsonElement` structure. Therefore, this object can be used in custom serialization/deserialization.
 
 Here's an example:
-```
+
+```java
 public class Foo {
   private final String s;
   private final int i;
@@ -452,15 +478,20 @@ System.out.println(json);
 
 json = gson.toJson(null);
 System.out.println(json);
+```
+
+The output is:
 
-======== OUTPUT ========
+```
 {""s"":null,""i"":5}
 null
 ```
+
 ### <a name=""TOC-Versioning-Support""></a>Versioning Support
 
 Multiple versions of the same object can be maintained by using [@Since](gson/src/main/java/com/google/gson/annotations/Since.java) annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your `Gson` instance to ignore any field/object that is greater than some version number. If no version is set on the `Gson` instance then it will serialize and deserialize all fields and classes regardless of the version.
-```
+
+```java
 public class VersionedClass {
   @Since(1.1) private final String newerField;
   @Since(1.0) private final String newField;
@@ -482,8 +513,11 @@ System.out.println();
 gson = new Gson();
 jsonOutput = gson.toJson(someObject);
 System.out.println(jsonOutput);
+```
 
-======== OUTPUT ========
+The output is:
+
+```
 {""newField"":""new"",""field"":""old""}
 
 {""newerField"":""newer"",""newField"":""new"",""field"":""old""}
@@ -496,20 +530,23 @@ Gson supports numerous mechanisms for excluding top-level classes, fields and fi
 #### <a name=""TOC-Java-Modifier-Exclusion""></a>Java Modifier Exclusion
 
 By default, if you mark a field as `transient`, it will be excluded. As well, if a field is marked as `static` then by default it will be excluded. If you want to include some transient fields then you can do the following:
-```
+
+```java
 import java.lang.reflect.Modifier;
 Gson gson = new GsonBuilder()
     .excludeFieldsWithModifiers(Modifier.STATIC)
     .create();
 ```
+
 NOTE: you can use any number of the `Modifier` constants to `excludeFieldsWithModifiers` method. For example:
-```
+
+```java
 Gson gson = new GsonBuilder()
     .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
     .create();
 ```
 
-#### <a name=""TOC-Gson-s-Expose""></a>Gson's @Expose
+#### <a name=""TOC-Gson-s-Expose""></a>Gson's `@Expose`
 
 This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using `new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()`. The Gson instance created will exclude all fields in a class that are not marked with `@Expose` annotation.
 
@@ -518,63 +555,69 @@ This feature provides a way where you can mark certain fields of your objects to
 If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
 
 The following example shows how to exclude fields marked with a specific `@Foo` annotation and excludes top-level types (or declared field type) of class `String`.
-```
-  @Retention(RetentionPolicy.RUNTIME)
-  @Target({ElementType.FIELD})
-  public @interface Foo {
-    // Field tag only annotation
-  }
 
-  public class SampleObjectForTest {
-    @Foo private final int annotatedField;
-    private final String stringField;
-    private final long longField;
-    private final Class<?> clazzField;
+```java
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD})
+public @interface Foo {
+  // Field tag only annotation
+}
 
-    public SampleObjectForTest() {
-      annotatedField = 5;
-      stringField = ""someDefaultValue"";
-      longField = 1234;
-    }
-  }
+public class SampleObjectForTest {
+  @Foo private final int annotatedField;
+  private final String stringField;
+  private final long longField;
+  private final Class<?> clazzField;
 
-  public class MyExclusionStrategy implements ExclusionStrategy {
-    private final Class<?> typeToSkip;
+  public SampleObjectForTest() {
+    annotatedField = 5;
+    stringField = ""someDefaultValue"";
+    longField = 1234;
+  }
+}
 
-    private MyExclusionStrategy(Class<?> typeToSkip) {
-      this.typeToSkip = typeToSkip;
-    }
+public class MyExclusionStrategy implements ExclusionStrategy {
+  private final Class<?> typeToSkip;
 
-    public boolean shouldSkipClass(Class<?> clazz) {
-      return (clazz == typeToSkip);
-    }
+  private MyExclusionStrategy(Class<?> typeToSkip) {
+    this.typeToSkip = typeToSkip;
+  }
 
-    public boolean shouldSkipField(FieldAttributes f) {
-      return f.getAnnotation(Foo.class) != null;
-    }
+  public boolean shouldSkipClass(Class<?> clazz) {
+    return (clazz == typeToSkip);
   }
 
-  public static void main(String[] args) {
-    Gson gson = new GsonBuilder()
-        .setExclusionStrategies(new MyExclusionStrategy(String.class))
-        .serializeNulls()
-        .create();
-    SampleObjectForTest src = new SampleObjectForTest();
-    String json = gson.toJson(src);
-    System.out.println(json);
+  public boolean shouldSkipField(FieldAttributes f) {
+    return f.getAnnotation(Foo.class) != null;
   }
+}
+
+public static void main(String[] args) {
+  Gson gson = new GsonBuilder()
+      .setExclusionStrategies(new MyExclusionStrategy(String.class))
+      .serializeNulls()
+      .create();
+  SampleObjectForTest src = new SampleObjectForTest();
+  String json = gson.toJson(src);
+  System.out.println(json);
+}
+```
+
+The output is:
 
-======== OUTPUT ========
+```
 {""longField"":1234}
 ```
+
 ### <a name=""TOC-JSON-Field-Naming-Support""></a>JSON Field Naming Support
 
 Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
 
 It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise ""Runtime"" exceptions if an invalid field name is provided as the annotation value.
 
 The following is an example of how to use both Gson naming policy features:
-```
+
+```java
 private class SomeObject {
   @SerializedName(""custom_naming"") private final String someField;
   private final String someOtherField;
@@ -589,8 +632,11 @@ SomeObject someObject = new SomeObject(""first"", ""second"");
 Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
 String jsonRepresentation = gson.toJson(someObject);
 System.out.println(jsonRepresentation);
+```
 
-======== OUTPUT ========
+The output is:
+
+```
 {""custom_naming"":""first"",""SomeOtherField"":""second""}
 ```
 , ","This enables GitHub to do proper syntax highlighting, thus improving the
readability of multi-line code blocks. As a result, some changes were required
to make the code blocks syntactically correct, since they're actually parsed by
language-aware parsers; primarily, this meant inserting comments.

You can see what this looks like via [my branch](https://github.com/mbrukman/gson/blob/docs-user-guide/UserGuide.md).",Added language annotations to code blocks.
751,Misha Brukman,['ReleaseProcess.md'],"@@ -3,22 +3,22 @@
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
-2. Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
-3. Ensure all changelists are code-reviewed and have +1
-4. Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
-5. `cd gson`; ensure there are no open files and all changes are committed.
-6. Run `mvn release:clean`
-7. Do a dry run: `mvn release:prepare -DdryRun=true`
-8. Start the release: `mvn release:prepare`
+1. Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
+1. Ensure all changelists are code-reviewed and have +1
+1. Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
+1. `cd gson`; ensure there are no open files and all changes are committed.
+1. Run `mvn release:clean`
+1. Do a dry run: `mvn release:prepare -DdryRun=true`
+1. Start the release: `mvn release:prepare`
   * Answer questions: usually the defaults are fine.
   * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
-9. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
+1. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
 
    ```bash
    mvn -s /home/<username>/.m2/settings.xml release:perform
    ```
 
-10. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
+1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
 
   ```bash
   cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
@@ -45,9 +45,9 @@ The following is a step-by-step procedure for releasing a new version of Google-
       -Dfile=gson-1.7.2.jar
   ```
 
-11. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
-12. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
-13. Publishing Javadocs
+1. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+1. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
+1. Publishing Javadocs
 
   ```bash
   # Switch to the branch `gh-pages`
@@ -63,10 +63,10 @@ The following is a step-by-step procedure for releasing a new version of Google-
   git push
   ```
 
-14. Update the version in the [Using Gson with Maven2 page](https://sites.google.com/site/gson/gson-user-guide/using-gson-with-maven2)
-15. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
-16. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
-17. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current ""stable"" release.
+1. Update the version in the [Using Gson with Maven2 page](https://sites.google.com/site/gson/gson-user-guide/using-gson-with-maven2)
+1. Update [Gson Changelog](https://github.com/google/gson/blob/master/CHANGELOG.md). Also, look at all bugs that were fixed and add a few lines describing what changed in the release.
+1. Create a post on the [Gson Discussion Forum](http://groups.google.com/group/google-gson)
+1. Update the release version in [Wikipedia](http://en.wikipedia.org/wiki/GSON) and update the current ""stable"" release.
 
 ## Configuring a machine for deployment to Sonatype Repository
 , ","Markdown supports automatic list numbering; using this approach makes it easier
to add or remove new items without having to update all the following entries.",Remove explicit step numbers; use autonumbering.
761,Jake Wharton,"['gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/main/java/com/google/gson/Gson.java', 'gson/src/main/java/com/google/gson/TreeTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java', 'gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java', 'gson/src/main/java/com/google/gson/internal/Streams.java', 'gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java', 'gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java', 'gson/src/main/java/com/google/gson/stream/JsonReader.java']","@@ -120,7 +120,7 @@
    * Converts the field name that uses camel-case define word separation into
    * separate words that are separated by the provided {@code separatorString}.
    */
-  private static String separateCamelCase(String name, String separator) {
+  static String separateCamelCase(String name, String separator) {
     StringBuilder translation = new StringBuilder();
     for (int i = 0; i < name.length(); i++) {
       char character = name.charAt(i);
@@ -135,7 +135,7 @@ private static String separateCamelCase(String name, String separator) {
   /**
    * Ensures the JSON field names begins with an upper case letter.
    */
-  private static String upperCaseFirstLetter(String name) {
+  static String upperCaseFirstLetter(String name) {
     StringBuilder fieldNameBuilder = new StringBuilder();
     int index = 0;
     char firstCharacter = name.charAt(index);, @@ -303,7 +303,7 @@ public Gson() {
     };
   }
 
-  private void checkValidFloatingPoint(double value) {
+  static void checkValidFloatingPoint(double value) {
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(value
           + "" is not a valid double value as per JSON specification. To override this""
@@ -459,7 +459,7 @@ private void checkValidFloatingPoint(double value) {
    *  }</pre>
    *  Note that this call will skip all factories registered before {@code skipPast}. In case of
    *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure
-   *  that the order of registration does not prevent this method from reaching a factory they 
+   *  that the order of registration does not prevent this method from reaching a factory they
    *  would expect to reply from this call.
    *  Note that since you can not override type adapter factories for String and Java primitive
    *  types, our stats factory will not count the number of String or primitives that will be, @@ -38,7 +38,7 @@
   /** The delegate is lazily created because it may not be needed, and creating it may fail. */
   private TypeAdapter<T> delegate;
 
-  private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
+  TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
     this.serializer = serializer;
     this.deserializer = deserializer;
@@ -112,7 +112,7 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
     private final JsonSerializer<?> serializer;
     private final JsonDeserializer<?> deserializer;
 
-    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
+    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,
         Class<?> hierarchyType) {
       serializer = typeAdapter instanceof JsonSerializer
           ? (JsonSerializer<?>) typeAdapter, @@ -16,9 +16,6 @@
 
 package com.google.gson.internal;
 
-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
-import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
-
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
@@ -34,6 +31,9 @@
 import java.util.NoSuchElementException;
 import java.util.Properties;
 
+import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
+import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
+
 /**
  * Static methods for working with types.
  *
@@ -212,7 +212,7 @@ public static boolean equals(Type a, Type b) {
     }
   }
 
-  private static int hashCodeOrZero(Object o) {
+  static int hashCodeOrZero(Object o) {
     return o != null ? o.hashCode() : 0;
   }
 
@@ -430,7 +430,7 @@ private static int indexOf(Object[] array, Object toFind) {
         : null;
   }
 
-  private static void checkNotPrimitive(Type type) {
+  static void checkNotPrimitive(Type type) {
     checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
   }
 , @@ -762,6 +762,9 @@ void add(Node<K, V> node) {
     Node<K, V> lastReturned = null;
     int expectedModCount = modCount;
 
+    LinkedTreeMapIterator() {
+    }
+
     public final boolean hasNext() {
       return next != header;
     }, @@ -528,6 +528,9 @@ public V setValue(V value) {
     Node<K, V> lastReturned = null;
     int expectedModCount = modCount;
 
+    LinkedTreeMapIterator() {
+    }
+
     public final boolean hasNext() {
       return next != header;
     }
@@ -624,4 +627,4 @@ public K next() {
   private Object writeReplace() throws ObjectStreamException {
     return new LinkedHashMap<K, V>(this);
   }
-}
\ No newline at end of file
+}, @@ -85,7 +85,7 @@ public static Writer writerForAppendable(Appendable appendable) {
     private final Appendable appendable;
     private final CurrentWrite currentWrite = new CurrentWrite();
 
-    private AppendableWriter(Appendable appendable) {
+    AppendableWriter(Appendable appendable) {
       this.appendable = appendable;
     }
 , @@ -104,7 +104,7 @@
  */
 public final class MapTypeAdapterFactory implements TypeAdapterFactory {
   private final ConstructorConstructor constructorConstructor;
-  private final boolean complexMapKeySerialization;
+  final boolean complexMapKeySerialization;
 
   public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       boolean complexMapKeySerialization) {, @@ -47,7 +47,7 @@
 
   private final Gson gson;
 
-  private ObjectTypeAdapter(Gson gson) {
+  ObjectTypeAdapter(Gson gson) {
     this.gson = gson;
   }
 , @@ -16,16 +16,6 @@
 
 package com.google.gson.internal.bind;
 
-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
 import com.google.gson.FieldNamingStrategy;
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
@@ -42,6 +32,15 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;
 
 /**
  * Type adapter that reflects over the fields and methods of a class.
@@ -127,7 +126,7 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     };
   }
 
-  private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {
+  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {
     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
     if (annotation != null) {
       TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);
@@ -193,7 +192,7 @@ protected BoundField(String name, boolean serialized, boolean deserialized) {
     private final ObjectConstructor<T> constructor;
     private final Map<String, BoundField> boundFields;
 
-    private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
+    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {
       this.constructor = constructor;
       this.boundFields = boundFields;
     }, @@ -242,7 +242,7 @@
   private int lineNumber = 0;
   private int lineStart = 0;
 
-  private int peeked = PEEKED_NONE;
+  int peeked = PEEKED_NONE;
 
   /**
    * A peeked value that was composed entirely of digits with an optional
@@ -462,7 +462,7 @@ public JsonToken peek() throws IOException {
     }
   }
 
-  private int doPeek() throws IOException {
+  int doPeek() throws IOException {
     int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
@@ -1314,11 +1314,11 @@ private boolean fillBuffer(int minimum) throws IOException {
     return false;
   }
 
-  private int getLineNumber() {
+  int getLineNumber() {
     return lineNumber + 1;
   }
 
-  private int getColumnNumber() {
+  int getColumnNumber() {
     return pos - lineStart + 1;
   }
 , ","Removes 14 methods being generated for trampolining to private members which brings the total to 1294 from 1308.

```
-rw-r--r--   1 jw  jw   176K Dec 27 01:39 after.dex
-rw-r--r--   1 jw  jw   221K Dec 27 01:38 after.jar
-rw-r--r--   1 jw  jw   177K Dec 27 01:39 before.dex
-rw-r--r--   1 jw  jw   223K Dec 27 01:39 before.jar
```",Remove synthetic accessors from being generated.
769,Dan Souza,"['gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java', 'gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java']","@@ -113,7 +113,7 @@ public static String format(Date date, boolean millis, TimeZone tz) {
 
     /**
      * Parse a date from ISO-8601 formatted string. It expects a format
-     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]
      * 
      * @param date ISO string to parse in the appropriate format.
      * @param pos The position to start parsing from, updated to where parsing stopped.
@@ -209,6 +209,10 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
                 offset += 1;
             } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
                 String timezoneOffset = date.substring(offset);
+
+                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00
+                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + ""00"";
+
                 offset += timezoneOffset.length();
                 // 18-Jun-2015, tatu: Minor simplification, skip offset of ""+0000""/""+00:00""
                 if (""+0000"".equals(timezoneOffset) || ""+00:00"".equals(timezoneOffset)) {, @@ -130,6 +130,7 @@ public void testDateDeserializationISO8601() throws Exception {
     assertParsed(""1970-01-01T00:00Z"", adapter);
     assertParsed(""1970-01-01T00:00:00+00:00"", adapter);
     assertParsed(""1970-01-01T01:00:00+01:00"", adapter);
+    assertParsed(""1970-01-01T01:00:00+01"", adapter);
   }
   
   public void testDateSerialization() throws Exception {, ","According to RFC, the format is:

time-numoffset    = (""+"" / ""-"") time-hour [["":""] time-minute]

it fixes #768 ",timezones without minutes should be valid according RFC3339
770,Gabriel Borges,['gson/src/main/java/com/google/gson/JsonArray.java'],"@@ -162,7 +162,7 @@ public int size() {
   }
 
   /**
-   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,
+   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,
    * the iterator navigates the elements in the order they were inserted.
    *
    * @return an iterator to navigate the elements of the array., ","Hey, sorry to bother you guys with such an small pull request, but I saw this typo in the documentation and I couldn't let it go.

:stuck_out_tongue_closed_eyes: 
thankss",Fix typo in JsonArray docs
771,Jake Wharton,"['gson/src/main/java/com/google/gson/Gson.java', 'gson/src/main/java/com/google/gson/GsonBuilder.java', 'gson/src/main/java/com/google/gson/stream/JsonReader.java', 'gson/src/test/java/com/google/gson/functional/LeniencyTest.java']","@@ -101,6 +101,12 @@
  */
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
+  static final boolean DEFAULT_LENIENT = false;
+  static final boolean DEFAULT_PRETTY_PRINT = false;
+  static final boolean DEFAULT_ESCAPE_HTML = true;
+  static final boolean DEFAULT_SERIALIZE_NULLS = false;
+  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
+  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
   private static final String JSON_NON_EXECUTABLE_PREFIX = "")]}'\n"";
 
@@ -124,6 +130,7 @@
   private final boolean htmlSafe;
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
+  private final boolean lenient;
 
   final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {
     @SuppressWarnings(""unchecked"")
@@ -177,22 +184,24 @@
    */
   public Gson() {
     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,
-        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,
-        true, false, false, LongSerializationPolicy.DEFAULT,
-        Collections.<TypeAdapterFactory>emptyList());
+        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,
+        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,
+        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,
+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());
   }
 
   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,
       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
-      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,
+      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy,
       List<TypeAdapterFactory> typeAdapterFactories) {
     this.constructorConstructor = new ConstructorConstructor(instanceCreators);
     this.serializeNulls = serializeNulls;
     this.generateNonExecutableJson = generateNonExecutableGson;
     this.htmlSafe = htmlSafe;
     this.prettyPrinting = prettyPrinting;
+    this.lenient = lenient;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -704,6 +713,15 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
     return jsonWriter;
   }
 
+  /**
+   * Returns a new JSON writer configured for the settings on this Gson instance.
+   */
+  public JsonReader newJsonReader(Reader reader) {
+    JsonReader jsonReader = new JsonReader(reader);
+    jsonReader.setLenient(lenient);
+    return jsonReader;
+  }
+
   /**
    * Writes the JSON for {@code jsonElement} to {@code writer}.
    * @throws JsonIOException if there was a problem writing to the writer
@@ -795,7 +813,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @since 1.2
    */
   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {
-    JsonReader jsonReader = new JsonReader(json);
+    JsonReader jsonReader = newJsonReader(json);
     Object object = fromJson(jsonReader, classOfT);
     assertFullConsumption(object, jsonReader);
     return Primitives.wrap(classOfT).cast(object);
@@ -822,7 +840,7 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    */
   @SuppressWarnings(""unchecked"")
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
-    JsonReader jsonReader = new JsonReader(json);
+    JsonReader jsonReader = newJsonReader(json);
     T object = (T) fromJson(jsonReader, typeOfT);
     assertFullConsumption(object, jsonReader);
     return object;, @@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.gson.stream.JsonReader;
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -31,6 +32,14 @@
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 
+import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
+import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
+import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
+import static com.google.gson.Gson.DEFAULT_LENIENT;
+import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
+import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
+import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
+
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
  * options other than the default. For {@link Gson} with default configuration, it is simpler to
@@ -74,15 +83,16 @@
   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */
   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();
-  private boolean serializeNulls;
+  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;
   private String datePattern;
   private int dateStyle = DateFormat.DEFAULT;
   private int timeStyle = DateFormat.DEFAULT;
-  private boolean complexMapKeySerialization;
-  private boolean serializeSpecialFloatingPointValues;
-  private boolean escapeHtmlChars = true;
-  private boolean prettyPrinting;
-  private boolean generateNonExecutableJson;
+  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;
+  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;
+  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;
+  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;
+  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;
+  private boolean lenient = DEFAULT_LENIENT;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -351,6 +361,19 @@ public GsonBuilder setPrettyPrinting() {
     return this;
   }
 
+  /**
+   * By default, Gson is strict and only accepts JSON as specified by
+   * <a href=""http://www.ietf.org/rfc/rfc4627.txt"">RFC 4627</a>. This option makes the parser
+   * liberal in what it accepts.
+   *
+   * @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
+   * @see JsonReader#setLenient(boolean)
+   */
+  public GsonBuilder setLenient() {
+    lenient = true;
+    return this;
+  }
+
   /**
    * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure
    * Gson to pass-through HTML characters as is.
@@ -544,7 +567,7 @@ public Gson create() {
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,
         serializeNulls, complexMapKeySerialization,
-        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,
+        generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
   }
 , @@ -294,7 +294,7 @@ public JsonReader(Reader in) {
   }
 
   /**
-   * Configure this parser to be  be liberal in what it accepts. By default,
+   * Configure this parser to be liberal in what it accepts. By default,
    * this parser is strict and only accepts JSON as specified by <a
    * href=""http://www.ietf.org/rfc/rfc4627.txt"">RFC 4627</a>. Setting the
    * parser to lenient causes it to ignore the following syntax errors:, @@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import java.util.List;
+import junit.framework.TestCase;
+
+import static java.util.Collections.singletonList;
+
+/**
+ * Functional tests for leniency option.
+ */
+public class LeniencyTest extends TestCase {
+
+  private Gson gson;
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    gson = new GsonBuilder().setLenient().create();
+  }
+
+  public void testLenientFromJson() {
+    List<String> json = gson.fromJson(""""
+        + ""[ # One!\n""
+        + ""  'Hi' #Element!\n""
+        + ""] # Array!"", new TypeToken<List<String>>() {}.getType());
+    assertEquals(singletonList(""Hi""), json);
+  }
+}, ",Add a JsonReader factory (for parity with the JsonWriter one) which provides a configured instance using the Gson settings.,Add setting for leniency on Gson instance.
772,Jerzy Chałupski,"['gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java', 'gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java', 'gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java']","@@ -51,18 +51,20 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
       TypeToken<?> fieldType, JsonAdapter annotation) {
     Class<?> value = annotation.value();
+    final TypeAdapter<?> typeAdapter;
     if (TypeAdapter.class.isAssignableFrom(value)) {
-          Class<TypeAdapter<?>> typeAdapter = (Class<TypeAdapter<?>>) value;
-      return constructorConstructor.get(TypeToken.get(typeAdapter)).construct();
-    }
-    if (TypeAdapterFactory.class.isAssignableFrom(value)) {
-          Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;
-      return constructorConstructor.get(TypeToken.get(typeAdapterFactory))
+      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;
+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();
+    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {
+      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;
+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))
           .construct()
           .create(gson, fieldType);
+    } else {
+      throw new IllegalArgumentException(
+          ""@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."");
     }
 
-    throw new IllegalArgumentException(
-        ""@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference."");
+    return typeAdapter.nullSafe();
   }
 }, @@ -133,6 +133,12 @@ public void testSuperclassTypeAdapterNotInvoked() {
     assertFalse(json.contains(""jsonAdapter""));
   }
 
+  public void testNullSafeObjectFromJson() {
+    Gson gson = new Gson();
+    NullableClass fromJson = gson.fromJson(""null"", NullableClass.class);
+    assertNull(fromJson);
+  }
+
   @JsonAdapter(A.JsonAdapter.class)
   private static class A {
     final String value;
@@ -215,6 +221,23 @@ public void testSuperclassTypeAdapterNotInvoked() {
     }
   }
 
+  @JsonAdapter(value = NullableClassJsonAdapter.class)
+  private static class NullableClass {
+  }
+
+  private static class NullableClassJsonAdapter extends TypeAdapter<NullableClass> {
+    @Override
+    public void write(JsonWriter out, NullableClass value) throws IOException {
+      out.value(""nullable"");
+    }
+
+    @Override
+    public NullableClass read(JsonReader in) throws IOException {
+      in.nextString();
+      return new NullableClass();
+    }
+  }
+
   @JsonAdapter(FooJsonAdapter.class)
   private static enum Foo { BAR, BAZ }
   private static class FooJsonAdapter extends TypeAdapter<Foo> {, @@ -200,4 +200,24 @@ public void testJsonAdapterInvokedOnlyForAnnotatedFields() {
       this.part2 = part2;
     }
   }
+
+  public void testJsonAdapterWrappedInNullSafeAsRequested() {
+    Gson gson = new Gson();
+    String fromJson = ""{'part':null}"";
+
+    GadgetWithOptionalPart gadget = gson.fromJson(fromJson, GadgetWithOptionalPart.class);
+    assertNull(gadget.part);
+
+    String toJson = gson.toJson(gadget);
+    assertFalse(toJson.contains(""PartJsonFieldAnnotationAdapter""));
+  }
+
+  private static final class GadgetWithOptionalPart {
+    @JsonAdapter(value = PartJsonFieldAnnotationAdapter.class)
+    final Part part;
+
+    private GadgetWithOptionalPart(Part part) {
+      this.part = part;
+    }
+  }
 }, ",NaN,Add nullsafe option to JsonAdapter annotation
773,Jake Wharton,"['gson/src/main/java/com/google/gson/stream/JsonReader.java', 'gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderTest.java', 'gson/src/test/java/com/google/gson/stream/JsonWriterTest.java']","@@ -24,7 +24,7 @@
 import java.io.Reader;
 
 /**
- * Reads a JSON (<a href=""http://www.ietf.org/rfc/rfc4627.txt"">RFC 4627</a>)
+ * Reads a JSON (<a href=""http://www.ietf.org/rfc/rfc7159.txt"">RFC 7159</a>)
  * encoded value as a stream of tokens. This stream includes both literal
  * values (strings, numbers, booleans, and nulls) as well as the begin and
  * end delimiters of objects and arrays. The tokens are traversed in
@@ -571,9 +571,6 @@ int doPeek() throws IOException {
       checkLenient();
       return peeked = PEEKED_SINGLE_QUOTED;
     case '""':
-      if (stackSize == 1) {
-        checkLenient();
-      }
       return peeked = PEEKED_DOUBLE_QUOTED;
     case '[':
       return peeked = PEEKED_BEGIN_ARRAY;
@@ -583,10 +580,6 @@ int doPeek() throws IOException {
       pos--; // Don't consume the first character in a literal value.
     }
 
-    if (stackSize == 1) {
-      checkLenient(); // Top-level value isn't an array or an object.
-    }
-
     int result = peekKeyword();
     if (result != PEEKED_NONE) {
       return result;, @@ -30,7 +30,7 @@
 import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;
 
 /**
- * Writes a JSON (<a href=""http://www.ietf.org/rfc/rfc4627.txt"">RFC 4627</a>)
+ * Writes a JSON (<a href=""http://www.ietf.org/rfc/rfc7159.txt"">RFC 7159</a>)
  * encoded value to a stream, one token at a time. The stream includes both
  * literal values (strings, numbers, booleans and nulls) as well as the begin
  * and end delimiters of objects and arrays.
@@ -130,7 +130,7 @@
 public class JsonWriter implements Closeable, Flushable {
 
   /*
-   * From RFC 4627, ""All Unicode characters may be placed within the
+   * From RFC 7159, ""All Unicode characters may be placed within the
    * quotation marks except for the characters that must be escaped:
    * quotation mark, reverse solidus, and the control characters
    * (U+0000 through U+001F).""
@@ -222,7 +222,7 @@ public final void setIndent(String indent) {
   /**
    * Configure this writer to relax its syntax rules. By default, this writer
    * only emits well-formed JSON as specified by <a
-   * href=""http://www.ietf.org/rfc/rfc4627.txt"">RFC 4627</a>. Setting the writer
+   * href=""http://www.ietf.org/rfc/rfc7159.txt"">RFC 7159</a>. Setting the writer
    * to lenient permits the following:
    * <ul>
    *   <li>Top-level values of any type. With strict writing, the top-level
@@ -322,7 +322,7 @@ public JsonWriter endObject() throws IOException {
    * bracket.
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
-    beforeValue(true);
+    beforeValue();
     push(empty);
     out.write(openBracket);
     return this;
@@ -415,7 +415,7 @@ public JsonWriter value(String value) throws IOException {
       return nullValue();
     }
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     string(value);
     return this;
   }
@@ -432,7 +432,7 @@ public JsonWriter jsonValue(String value) throws IOException {
       return nullValue();
     }
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.append(value);
     return this;
   }
@@ -451,7 +451,7 @@ public JsonWriter nullValue() throws IOException {
         return this; // skip the name and the value
       }
     }
-    beforeValue(false);
+    beforeValue();
     out.write(""null"");
     return this;
   }
@@ -463,7 +463,7 @@ public JsonWriter nullValue() throws IOException {
    */
   public JsonWriter value(boolean value) throws IOException {
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.write(value ? ""true"" : ""false"");
     return this;
   }
@@ -480,7 +480,7 @@ public JsonWriter value(double value) throws IOException {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.append(Double.toString(value));
     return this;
   }
@@ -492,7 +492,7 @@ public JsonWriter value(double value) throws IOException {
    */
   public JsonWriter value(long value) throws IOException {
     writeDeferredName();
-    beforeValue(false);
+    beforeValue();
     out.write(Long.toString(value));
     return this;
   }
@@ -515,7 +515,7 @@ public JsonWriter value(Number value) throws IOException {
         && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
-    beforeValue(false);
+    beforeValue();
     out.append(string);
     return this;
   }
@@ -608,12 +608,9 @@ private void beforeName() throws IOException {
    * Inserts any necessary separators and whitespace before a literal value,
    * inline array, or inline object. Also adjusts the stack to expect either a
    * closing bracket or another element.
-   *
-   * @param root true if the value is a new array or object, the two values
-   *     permitted as top-level elements.
    */
   @SuppressWarnings(""fallthrough"")
-  private void beforeValue(boolean root) throws IOException {
+  private void beforeValue() throws IOException {
     switch (peek()) {
     case NONEMPTY_DOCUMENT:
       if (!lenient) {
@@ -622,10 +619,6 @@ private void beforeValue(boolean root) throws IOException {
       }
       // fall-through
     case EMPTY_DOCUMENT: // first in document
-      if (!lenient && !root) {
-        throw new IllegalStateException(
-            ""JSON must start with an array or an object."");
-      }
       replaceTop(NONEMPTY_DOCUMENT);
       break;
 , @@ -195,14 +195,6 @@ public void testEmptyString() {
     }
   }
 
-  public void testNoTopLevelObject() {
-    try {
-      new JsonReader(reader(""true"")).nextBoolean();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
   public void testCharacterUnescaping() throws IOException {
     String json = ""[\""a\"",""
         + ""\""a\\\""\"",""
@@ -1227,44 +1219,37 @@ public void testStrictMultipleTopLevelValuesWithSkipValue() throws IOException {
     }
   }
 
-  public void testStrictTopLevelString() {
-    JsonReader reader = new JsonReader(reader(""\""a\""""));
-    try {
-      reader.nextString();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
+  public void testTopLevelValueTypes() throws IOException {
+    JsonReader reader1 = new JsonReader(reader(""true""));
+    assertTrue(reader1.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader1.peek());
 
-  public void testLenientTopLevelString() throws IOException {
-    JsonReader reader = new JsonReader(reader(""\""a\""""));
-    reader.setLenient(true);
-    assertEquals(""a"", reader.nextString());
-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
-  }
+    JsonReader reader2 = new JsonReader(reader(""false""));
+    assertFalse(reader2.nextBoolean());
+    assertEquals(JsonToken.END_DOCUMENT, reader2.peek());
 
-  public void testStrictTopLevelValueType() {
-    JsonReader reader = new JsonReader(reader(""true""));
-    try {
-      reader.nextBoolean();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
+    JsonReader reader3 = new JsonReader(reader(""null""));
+    assertEquals(JsonToken.NULL, reader3.peek());
+    reader3.nextNull();
+    assertEquals(JsonToken.END_DOCUMENT, reader3.peek());
 
-  public void testLenientTopLevelValueType() throws IOException {
-    JsonReader reader = new JsonReader(reader(""true""));
-    reader.setLenient(true);
-    assertEquals(true, reader.nextBoolean());
+    JsonReader reader4 = new JsonReader(reader(""123""));
+    assertEquals(123, reader4.nextInt());
+    assertEquals(JsonToken.END_DOCUMENT, reader4.peek());
+
+    JsonReader reader5 = new JsonReader(reader(""123.4""));
+    assertEquals(123.4, reader5.nextDouble());
+    assertEquals(JsonToken.END_DOCUMENT, reader5.peek());
+
+    JsonReader reader6 = new JsonReader(reader(""\""a\""""));
+    assertEquals(""a"", reader6.nextString());
+    assertEquals(JsonToken.END_DOCUMENT, reader6.peek());
   }
 
-  public void testStrictTopLevelValueTypeWithSkipValue() {
+  public void testTopLevelValueTypeWithSkipValue() throws IOException {
     JsonReader reader = new JsonReader(reader(""true""));
-    try {
-      reader.skipValue();
-      fail();
-    } catch (IOException expected) {
-    }
+    reader.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());
   }
 
   public void testStrictNonExecutePrefix() {
@@ -1524,7 +1509,7 @@ public void testUnterminatedObject() throws IOException {
     } catch (MalformedJsonException expected) {
     }
   }
-  
+
   public void testVeryLongQuotedString() throws IOException {
     char[] stringChars = new char[1024 * 16];
     Arrays.fill(stringChars, 'x');, @@ -25,11 +25,44 @@
 @SuppressWarnings(""resource"")
 public final class JsonWriterTest extends TestCase {
 
-  public void testWrongTopLevelType() throws IOException {
+  public void testTopLevelValueTypes() throws IOException {
+    StringWriter string1 = new StringWriter();
+    JsonWriter writer1 = new JsonWriter(string1);
+    writer1.value(true);
+    writer1.close();
+    assertEquals(""true"", string1.toString());
+
+    StringWriter string2 = new StringWriter();
+    JsonWriter writer2 = new JsonWriter(string2);
+    writer2.nullValue();
+    writer2.close();
+    assertEquals(""null"", string2.toString());
+
+    StringWriter string3 = new StringWriter();
+    JsonWriter writer3 = new JsonWriter(string3);
+    writer3.value(123);
+    writer3.close();
+    assertEquals(""123"", string3.toString());
+
+    StringWriter string4 = new StringWriter();
+    JsonWriter writer4 = new JsonWriter(string4);
+    writer4.value(123.4);
+    writer4.close();
+    assertEquals(""123.4"", string4.toString());
+
+    StringWriter string5 = new StringWriter();
+    JsonWriter writert = new JsonWriter(string5);
+    writert.value(""a"");
+    writert.close();
+    assertEquals(""\""a\"""", string5.toString());
+  }
+
+  public void testInvalidTopLevelTypes() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.name(""hello"");
     try {
-      jsonWriter.value(""a"");
+      jsonWriter.value(""world"");
       fail();
     } catch (IllegalStateException expected) {
     }, ",This allows for top-level value types without the requirement of leniency.,Update reader and writer for RFC 7159.
787,Jesse Wilson,"['gson/pom.xml', 'pom.xml']","@@ -1,246 +1,36 @@
 <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson</artifactId>
-  <packaging>jar</packaging>
-  <version>2.6-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson</name>
+
   <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-    <relativePath />
+    <groupId>com.google.code.gson</groupId>
+    <artifactId>gson-parent</artifactId>
+    <version>2.6-SNAPSHOT</version>
   </parent>
-  <url>https://github.com/google/gson</url>
-  <description>Google Gson: Java to JSON conversion library</description>
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-  </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
-  <scm>
-    <connection>scm:git:https://github.com/google/gson.git</connection>
-    <developerConnection>scm:git:https://github.com/google/gson.git</developerConnection>
-    <url>https://github.com/google/gson</url>
-    <tag>gson-${project.version}</tag>
-  </scm>
-  <issueManagement>
-    <system>Github Issue Tracking</system>
-    <url>https://github.com/google/gson/issues</url>
-  </issueManagement>
-  <distributionManagement>
-    <snapshotRepository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>Sonatype Nexus Snapshots</name>
-      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-    <repository>
-      <id>sonatype-nexus-staging</id>
-      <name>Nexus Release Repository</name>
-      <url>http://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-    </repository>
-  </distributionManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
+
+  <artifactId>gson</artifactId>
+  <name>Gson</name>
+
   <dependencies>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
-  <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.5</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>doclint-java8-disable</id>
-      <activation>
-        <jdk>[1.8,)</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-            <configuration>
-              <additionalparam>-Xdoclint:none</additionalparam>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
+
   <build>
-    <defaultGoal>package</defaultGoal>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.3</version>
-        <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.6</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-            <manifestEntries>
-              <Bundle-RequiredExecutionEnvironment>J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8</Bundle-RequiredExecutionEnvironment>
-              <Export-Package><![CDATA[com.google.gson;version=${project.version}, com.google.gson.annotations;version=${project.version}, com.google.gson.reflect;version=${project.version}, com.google.gson.stream;version=${project.version}, com.google.gson.internal;version=${project.version}, com.google.gson.internal.bind;version=${project.version}]]></Export-Package>
-              <Bundle-Version>${project.version}</Bundle-Version>
-              <Bundle-ContactAddress>https://github.com/google/gson</Bundle-ContactAddress>
-              <Bundle-Vendor>Google Gson Project</Bundle-Vendor>
-              <Bundle-Name>${project.name}</Bundle-Name>
-              <Bundle-Description>${project.description}</Bundle-Description>
-              <Bundle-ClassPath>.</Bundle-ClassPath>
-              <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-              <Bundle-SymbolicName>com.google.gson</Bundle-SymbolicName>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-      <plugin>
-       <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <archive>
-             <manifestEntries>
-               <Eclipse-SourceBundle>com.google.gson;version=""${project.version}""</Eclipse-SourceBundle>
-               <Bundle-SymbolicName>com.google.gson.source</Bundle-SymbolicName>
-               <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-               <Bundle-Version>${project.version}</Bundle-Version>
-             </manifestEntries>
-           </archive>
-         </configuration>
-       </plugin>
-       <plugin>
-         <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.3</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <includePackageNames>com.google.gson</includePackageNames>
-           <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
-            <links>
-             <link>http://docs.oracle.com/javase/6/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>protected</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.10</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <!-- version>2.5</version -->
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.5.5</version>
+        <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <descriptor>assembly-descriptor.xml</descriptor>
-          <finalName>google-gson-${project.version}</finalName>
-          <outputDirectory>target/dist</outputDirectory>
-          <workDirectory>target/assembly/work</workDirectory>
+          <includePackageNames>com.google.gson</includePackageNames>
+          <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
+          <links>
+            <link>http://docs.oracle.com/javase/6/docs/api/</link>
+          </links>
         </configuration>
       </plugin>
     </plugins>
   </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
 </project>, @@ -1,249 +1,97 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+
 <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.google.code.gson</groupId>
-  <artifactId>gson-parent</artifactId>
-  <packaging>pom</packaging>
-  <version>2.6-SNAPSHOT</version>
-  <inceptionYear>2008</inceptionYear>
-  <name>Gson Parent</name>
+
   <parent>
     <groupId>org.sonatype.oss</groupId>
     <artifactId>oss-parent</artifactId>
-    <version>9</version>
-    <relativePath />
+    <version>7</version>
   </parent>
+
+  <groupId>com.google.code.gson</groupId>
+  <artifactId>gson-parent</artifactId>
+  <version>2.6-SNAPSHOT</version>
+  <packaging>pom</packaging>
+
+  <name>Gson Parent</name>
+  <description>Gson JSON library</description>
   <url>https://github.com/google/gson</url>
-  <description>Google Gson library</description>
+
+  <modules>
+    <module>gson</module>
+  </modules>
+
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <java.version>1.7</java.version>
   </properties>
-  <licenses>
-    <license>
-      <name>The Apache Software License, Version 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-      <distribution>repo</distribution>
-    </license>
-  </licenses>
+
   <scm>
+    <url>https://github.com/google/gson/</url>
     <connection>scm:git:https://github.com/google/gson.git</connection>
-    <developerConnection>scm:git:https://github.com/google/gson.git</developerConnection>
-    <url>https://github.com/google/gson</url>
-    <tag>gson-${project.version}</tag>
+    <developerConnection>scm:git:git@github.com:google/gson.git</developerConnection>
+    <tag>HEAD</tag>
   </scm>
+
   <issueManagement>
-    <system>Github Issue Tracking</system>
+    <system>GitHub Issues</system>
     <url>https://github.com/google/gson/issues</url>
   </issueManagement>
-  <distributionManagement>
-    <snapshotRepository>
-      <id>sonatype-nexus-snapshots</id>
-      <name>Sonatype Nexus Snapshots</name>
-      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-    </snapshotRepository>
-    <repository>
-      <id>sonatype-nexus-staging</id>
-      <name>Nexus Release Repository</name>
-      <url>http://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-    </repository>
-  </distributionManagement>
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.2</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-  <modules>
-    <module>gson</module>
-  </modules>
-  <profiles>
-    <!-- Activate PGP signing only when performing a release -->
-    <profile>
-      <id>release-sign-artifacts</id>
-      <activation>
-        <property>
-          <name>performRelease</name>
-          <value>true</value>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-gpg-plugin</artifactId>
-            <version>1.5</version>
-            <executions>
-              <execution>
-                <id>sign-artifacts</id>
-                <phase>verify</phase>
-                <goals>
-                  <goal>sign</goal>
-                </goals>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>doclint-java8-disable</id>
-      <activation>
-        <jdk>[1.8,)</jdk>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-javadoc-plugin</artifactId>
-            <configuration>
-              <additionalparam>-Xdoclint:none</additionalparam>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>junit</groupId>
+        <artifactId>junit</artifactId>
+        <version>3.8.2</version>
+        <scope>test</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
   <build>
-    <defaultGoal>package</defaultGoal>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <version>3.0</version>
+          <configuration>
+            <source>${java.version}</source>
+            <target>${java.version}</target>
+          </configuration>
+        </plugin>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-javadoc-plugin</artifactId>
+          <version>2.10.3</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
     <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.3</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>2.6</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <archive>
-            <addMavenDescriptor>false</addMavenDescriptor>
-            <manifestEntries>
-              <Bundle-RequiredExecutionEnvironment>J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8</Bundle-RequiredExecutionEnvironment>
-              <Export-Package><![CDATA[com.google.gson;version=${project.version}, com.google.gson.annotations;version=${project.version}, com.google.gson.reflect;version=${project.version}, com.google.gson.stream;version=${project.version}, com.google.gson.internal;version=${project.version}, com.google.gson.internal.bind;version=${project.version}]]></Export-Package>
-              <Bundle-Version>${project.version}</Bundle-Version>
-              <Bundle-ContactAddress>https://github.com/google/gson</Bundle-ContactAddress>
-              <Bundle-Vendor>Google Gson Project</Bundle-Vendor>
-              <Bundle-Name>${project.name}</Bundle-Name>
-              <Bundle-Description>${project.description}</Bundle-Description>
-              <Bundle-ClassPath>.</Bundle-ClassPath>
-              <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-              <Bundle-SymbolicName>com.google.gson</Bundle-SymbolicName>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-      <plugin>
-       <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
-         <executions>
-           <execution>
-             <id>attach-sources</id>
-             <phase>verify</phase>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <archive>
-             <manifestEntries>
-               <Eclipse-SourceBundle>com.google.gson;version=""${project.version}""</Eclipse-SourceBundle>
-               <Bundle-SymbolicName>com.google.gson.source</Bundle-SymbolicName>
-               <Bundle-ManifestVersion>2</Bundle-ManifestVersion>
-               <Bundle-Version>${project.version}</Bundle-Version>
-             </manifestEntries>
-           </archive>
-         </configuration>
-       </plugin>
-       <plugin>
-         <!-- TODO(inder): add manifest entry for maven group, artifact, and classifier ids -->
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.3</version>
-         <executions>
-           <execution>
-             <id>attach-javadocs</id>
-             <goals>
-               <goal>jar</goal>
-             </goals>
-           </execution>
-         </executions>
-         <configuration>
-           <includePackageNames>com.google.gson</includePackageNames>
-           <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
-            <links>
-             <link>http://docs.oracle.com/javase/1.5.0/docs/api/</link>
-           </links>
-           <version>true</version>
-           <show>protected</show>
-         </configuration>
-       </plugin>
-       <plugin>
-         <groupId>org.apache.maven.plugins</groupId>
-         <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.10</version>
-         <configuration>
-           <downloadSources>true</downloadSources>
-           <downloadJavadocs>true</downloadJavadocs>
-           <workspace>
-             ../eclipse-ws/
-           </workspace>
-           <workspaceCodeStylesURL>
-             file:///${basedir}/../lib/gson-formatting-styles.xml
-           </workspaceCodeStylesURL>
-         </configuration>
-       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <!-- version>2.5</version -->
-        <configuration>
-          <arguments>-DenableCiProfile=true</arguments>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.5.5</version>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
         <configuration>
-          <descriptor>assembly-descriptor.xml</descriptor>
-          <finalName>google-gson-${project.version}</finalName>
-          <outputDirectory>target/dist</outputDirectory>
-          <workDirectory>target/assembly/work</workDirectory>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
       </plugin>
     </plugins>
   </build>
-  <developers>
-    <developer>
-      <name>Inderjeet Singh</name>
-    </developer>
-    <developer>
-      <name>Joel Leitch</name>
-      <organization>Google Inc.</organization>
-    </developer>
-    <developer>
-      <name>Jesse Wilson</name>
-      <organization>Square Inc.</organization>
-    </developer>
-  </developers>
 </project>, ","A lot of the configuration in these poms has been taken over by improvements
to the Maven release plugin.",Simplify Gson poms.
790,Jesse Wilson,['pom.xml'],"@@ -24,7 +24,7 @@
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <java.version>1.7</java.version>
+    <java.version>1.6</java.version>
   </properties>
 
   <scm>, ",The upgrade to Java 1.7 was a clumsy bug.,Build Gson for Java 1.6.
791,Marcelo Camargo,['examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java'],"@@ -52,6 +52,6 @@ public String getCurrencyCode() {
   @Override
   public String toString() {
     return String.format(""(item: %s, qty: %s, price: %.2f %s)"",
-        name, quantity, priceInMicros/(double)1000000, currencyCode);
+        name, quantity, priceInMicros / 1000000d, currencyCode);
   }
 }, ","· Separated binary operator

This is a very, very, **very** small change, but that unnecessary explicit `(double)` casting with joined expressions on binary operator was affecting my OCD.",Fixed code style to remove explicit casting op.
792,Dongjoon Hyun,"['gson/src/main/java/com/google/gson/FieldAttributes.java', 'gson/src/main/java/com/google/gson/Gson.java', 'gson/src/main/java/com/google/gson/GsonBuilder.java', 'gson/src/test/java/com/google/gson/ParameterizedTypeTest.java', 'gson/src/test/java/com/google/gson/functional/SerializedNameTest.java']","@@ -68,7 +68,7 @@ public String getName() {
    *   private List&lt;String&gt; red;
    * }
    *
-   * Type listParmeterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
+   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
    * </pre>
    *
    * <p>This method would return {@code String.class} for the {@code bar} field and, @@ -78,7 +78,7 @@
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
  * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
- * example for serializing and deserialing a {@code ParameterizedType}:
+ * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
  * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();, @@ -303,7 +303,7 @@ public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrateg
    * Configures Gson to apply a set of exclusion strategies during both serialization and
    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
    * This means that if one of the {@code strategies} suggests that a field (or class) should be
-   * skipped then that field (or object) is skipped during serializaiton/deserialization.
+   * skipped then that field (or object) is skipped during serialization/deserialization.
    *
    * @param strategies the set of strategy object to apply during object (de)serialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern, @@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.
+ * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch, @@ -25,7 +25,7 @@
 
   public void testFirstNameIsChosenForSerialization() {
     MyClass target = new MyClass(""v1"", ""v2"");
-    // Ensure name1 occurs exactly once, and name2 and name3 dont appear
+    // Ensure name1 occurs exactly once, and name2 and name3 don't appear
     assertEquals(""{\""name\"":\""v1\"",\""name1\"":\""v2\""}"", gson.toJson(target));
   }
 , ",NaN,Fix some typos in gson comments.
793,Egor Neliuba,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -94,11 +94,11 @@
  * ""Rectangle""}) are configurable.
  *
  * <h3>Registering Types</h3>
- * Create a {@code RuntimeTypeAdapter} by passing the base type and type field
+ * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
  * name to the {@link #of} factory method. If you don't supply an explicit type
  * field name, {@code ""type""} will be used. <pre>   {@code
- *   RuntimeTypeAdapter<Shape> shapeAdapter
- *       = RuntimeTypeAdapter.of(Shape.class, ""type"");
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapter
+ *       = RuntimeTypeAdapterFactory.of(Shape.class, ""type"");
  * }</pre>
  * Next register all of your subtypes. Every subtype must be explicitly
  * registered. This protects your application from injection attacks. If you
@@ -115,7 +115,7 @@
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
- *   RuntimeTypeAdapter<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)
  *       .registerSubtype(Rectangle.class)
  *       .registerSubtype(Circle.class)
  *       .registerSubtype(Diamond.class);, ",NaN,Fix RuntimeTypeAdapterFactory javadoc
794,Jonathan Paugh,['UserGuide.md'],"@@ -223,11 +223,8 @@ Unfortunately, there is no way to get around this in Java.
 
 #### <a name=""TOC-Collections-Limitations""></a>Collections Limitations
 
-* Can serialize collection of arbitrary objects but can not deserialize from it
-* Because there is no way for the user to indicate the type of the resulting object
-* While deserializing, Collection must be of a specific generic type
-
-All of this makes sense, and is rarely a problem when following good Java coding practices.
+Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type.
+This makes sense, and is rarely a problem when following good Java coding practices.
 
 ### <a name=""TOC-Serializing-and-Deserializing-Generic-Types""></a>Serializing and Deserializing Generic Types
 , ","The section entitled ""Collections Limitations"" contains 3 bullets, but one semantic point, which is confusing.

Make this point in a paragraph instead of a bullet list.",Collapse bullets into a paragraph
797,Sean Bright,"['gson/bnd.bnd', 'gson/pom.xml', 'pom.xml']","@@ -0,0 +1,14 @@
+Bundle-SymbolicName: com.google.gson
+Bundle-Name: ${project.name}
+Bundle-Description: ${project.description}
+Bundle-Vendor: Google Gson Project
+Bundle-ContactAddress: ${project.parent.url}
+Bundle-RequiredExecutionEnvironment: J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8
+
+-removeheaders: Private-Package
+
+-exportcontents:\
+    com.google.gson,\
+    com.google.gson.annotations,\
+    com.google.gson.reflect,\
+    com.google.gson.stream, @@ -31,6 +31,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>biz.aQute.bnd</groupId>
+        <artifactId>bnd-maven-plugin</artifactId>
+        <version>3.1.0</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>bnd-process</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>, @@ -74,6 +74,13 @@
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.10.3</version>
         </plugin>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-jar-plugin</artifactId>
+          <configuration>
+            <useDefaultManifestFile>true</useDefaultManifestFile>
+          </configuration>
+        </plugin>
       </plugins>
     </pluginManagement>
     <plugins>, ","Commit 2016e95 removed the necessary MANIFEST.MF headers for Gson to
resolve in an OSGi environment. This patch restores them.

Fixes #796",Restore OSGi manifest headers
798,Daniel Debert,['README.md'],"@@ -7,28 +7,29 @@ Gson can work with arbitrary Java objects including pre-existing objects that yo
 
 There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
 
-*Gson Goals*
+###*Gson Goals*
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-*Gson Downloads*
+###*Gson Download and Maven*
   * [Gson 2.6.1 Download](http://search.maven.org/#artifactdetails%7Ccom.google.code.gson%7Cgson%7C2.6.1%7Cjar) downloads at Maven Central
+  * For Maven check ""Dependency Information"" tab, on the left side.
 
-*Gson Documentation*
+###*Gson Documentation*
   * Gson [API](http://google.github.io/gson/apidocs/): Javadocs for the current Gson release
   * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
   * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
   * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
 
 Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
 
-*Gson-related Content Created by Third Parties*
+###*Gson-related Content Created by Third Parties*
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
 
-*License*
+###*License*
 
 Gson is released under the [Apache 2.0 license](LICENSE).
 , ",NaN,Minor readability edit
800,Inderjeet Singh,['gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java'],"@@ -15,54 +15,37 @@
  */
 package com.google.gson.regression;
 
-import java.io.IOException;
-import java.util.Objects;
-
 import com.google.gson.Gson;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParser;
-import com.google.gson.JsonPrimitive;
-import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.JsonAdapter;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonWriter;
 
 import junit.framework.TestCase;
 
 public class JsonAdapterNullSafeTest extends TestCase {
-  // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug
-  // because it returns a null type adapter.
-
   private final Gson gson = new Gson();
 
   public void testNullSafeBugSerialize() throws Exception {
-    Device device = new Device(""ec57803e"", 2);
+    Device device = new Device(""ec57803e"");
     gson.toJson(device);
   }
 
   public void testNullSafeBugDeserialize() throws Exception {
-    String json = ""\""{\\\""id\\\"":\\\""ec57803e2\\\"",\\\""category\\\"":2}\"""";
-    Device device = gson.fromJson(json, Device.class);
+    Device device = gson.fromJson(""{'id':'ec57803e2'}"", Device.class);
     assertEquals(""ec57803e2"", device.id);
-    assertEquals(2, device.category);
   }
 
   @JsonAdapter(Device.JsonAdapterFactory.class)
   private static final class Device {
     String id;
-    int category;
-    Device(String id, int category) {
+    Device(String id) {
       this.id = id;
-      this.category = category;
     }
 
-    /**
-     * Write the value as a String, not JSON.
-     */
     static final class JsonAdapterFactory implements TypeAdapterFactory {
+      // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug
+      // because we use it to return a null type adapter on a recursive call.
       private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();
 
       @SuppressWarnings({""unchecked"", ""rawtypes""})
@@ -72,31 +55,7 @@ public void testNullSafeBugDeserialize() throws Exception {
           return null;
         }
         recursiveCall.set(Boolean.TRUE);
-        final TypeAdapter<Device> delegate = (TypeAdapter) gson.getDelegateAdapter(this, type);
-        return (TypeAdapter) new TypeAdapter<Device>() {
-          @Override public void write(JsonWriter out, Device value) throws IOException {
-            delegate.write(out, value);
-          }
-          @Override public Device read(JsonReader in) throws IOException {
-            String json = in.nextString();
-            JsonParser parser = new JsonParser();
-            JsonElement root = parseString(parser, json, null);
-            return root == null ? null : delegate.fromJsonTree(root);
-          }
-          private JsonElement parseString(JsonParser parser, String json, String prevJson)
-              throws IOException { // called recursively
-            JsonElement root = parser.parse(json);
-            if (root instanceof JsonPrimitive) {
-              prevJson = json;
-              json = root.getAsString();
-              if (Objects.equals(json, prevJson)) {
-                throw new JsonSyntaxException(""Unexpected Json: "" + json);
-              }
-              return parseString(parser, json, prevJson);
-            }
-            return root;
-          }
-        };
+        return (TypeAdapter) gson.getDelegateAdapter(this, type);
       }
     }
   }, ",…erFactory.create() returned null.,Fixed a regression in Gson 2.6 where Gson caused NPE if the TypeAdapt…
801,Inderjeet Singh,['pom.xml'],"@@ -101,4 +101,23 @@
       </plugin>
     </plugins>
   </build>
+  <profiles>
+    <profile>
+      <id>doclint-java8-disable</id>
+      <activation>
+        <jdk>[1.8,</jdk>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-javadoc-plugin</artifactId>
+            <configuration>
+              <additionalparam>-Xdoclint:none</additionalparam>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
 </project>, ",NaN,Added JDK 8 doclint exclusion section
802,Inderjeet Singh,"['gson/pom.xml', 'pom.xml']","@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.6.3-SNAPSHOT</version>
+    <version>2.6.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>, @@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.6.3-SNAPSHOT</version>
+  <version>2.6.2-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>, ",… that.,previous mvn release:prepare failed but updated GitHub anyway. Fixing…
806,Vsevolod Tolstopyatov,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -390,10 +390,7 @@ static void checkValidFloatingPoint(double value) {
    */
   @SuppressWarnings(""unchecked"")
   public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
-    if (type == null) {
-      type = (TypeToken<T>) NULL_KEY_SURROGATE;
-    }
-    TypeAdapter<?> cached = typeTokenCache.get(type);
+    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
     if (cached != null) {
       return (TypeAdapter<T>) cached;
     }, ","Internally Gson class uses Collections#synchronizedMap as a thread-safe map for typeTokenCache.
In a highly-contended environment I'm experiencing unpredictable latency spikes, 
while the performance of Gson#toJson degrades significantly even for simple objects. 
It's typical for an application thread to hang on typeTokenCache#get average 3-15 ms in such situations.
See [this](https://gist.github.com/qwwdfsad/a72692ab56a1a946a5fb) benchmark results to observe this problem (results for patch included).

For a more or less generic serialization code it's impossible to use TypeAdapter directly. One of the solutions might be to use thread-local Gson instances, but from programmer's perspective it makes code more obfuscated, requires an additional explanation on why this was done and floods the heap with duplicate objects. Gson is declared as thread-safe, so it seems reasonable to expect fine-grained concurrency level internally.  Moreover, after initial application warmup typeTokenCache becomes a mostly read-only structure (in fact, read-only), so allowing non-blocking reads looks like a perfect fit. 

Provided patch replaces synchronized map with j.u.c.ConcurrentHashMap. The main difference between synchronized map and CHM is null keys prohibition, so implicit code-path for null is added. 
As you can see in benchmark results, even despite of additional code path for null keys, overall throughput increases even in single-threaded case due to absence of explicit synchronization (though JVM optimizes uncontended locks, some overhead is still present), so there is no risks or performance degradation associated with this patch.",Gson synchronized map replaced with concurrent hash map
809,Scott Brown,"['gson/src/main/java/com/google/gson/stream/JsonReader.java', 'gson/src/test/java/com/google/gson/functional/MapTest.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderTest.java']","@@ -951,8 +951,12 @@ public long nextLong() throws IOException {
     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
+      }
       try {
         long result = Long.parseLong(peekedString);
         peeked = PEEKED_NONE;
@@ -1179,8 +1183,12 @@ public int nextInt() throws IOException {
     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
-      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+      if (p == PEEKED_UNQUOTED) {
+        peekedString = nextUnquotedValue();
+      } else {
+        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
+      }
       try {
         result = Integer.parseInt(peekedString);
         peeked = PEEKED_NONE;, @@ -167,6 +167,34 @@ public void testMapDeserializationWithIntegerKeys() {
     assertEquals(""456"", map.get(123));
   }
 
+  public void testMapDeserializationWithUnquotedIntegerKeys() {
+    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();
+    Map<Integer, String> map = gson.fromJson(""{123:\""456\""}"", typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(123));
+    assertEquals(""456"", map.get(123));
+  }
+
+  public void testMapDeserializationWithLongKeys() {
+    long longValue = 9876543210L;
+    String json = String.format(""{\""%d\"":\""456\""}"", longValue);
+    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
+    Map<Long, String> map = gson.fromJson(json, typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(longValue));
+    assertEquals(""456"", map.get(longValue));
+  }
+
+  public void testMapDeserializationWithUnquotedLongKeys() {
+    long longKey = 9876543210L;
+    String json = String.format(""{%d:\""456\""}"", longKey);
+    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();
+    Map<Long, String> map = gson.fromJson(json, typeOfMap);
+    assertEquals(1, map.size());
+    assertTrue(map.containsKey(longKey));
+    assertEquals(""456"", map.get(longKey));
+  }
+
   public void testHashMapDeserialization() throws Exception {
     Type typeOfMap = new TypeToken<HashMap<Integer, String>>() {}.getType();
     HashMap<Integer, String> map = gson.fromJson(""{\""123\"":\""456\""}"", typeOfMap);, @@ -501,7 +501,7 @@ public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException
     try {
       reader.nextInt();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (NumberFormatException expected) {
     }
     assertEquals(""12.34e5x"", reader.nextString());
   }, ","Fixes a bug in JsonReader.nextInt() and JsonReader.nextLong() whereby PEEKED_UNQUOTED is not handled.  This bug caused failure to deserialize maps with Long or Integer keys when the key is unquoted.

This fixes issues #604 and #524 ",allow unquoted long and integer keys
816,valery1707,['README.md'],"@@ -1,6 +1,8 @@
 # google-gson
 
 [![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
+[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson)
+[![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
 Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. , ",NaN,Add some useful badges with automatic version detection: Maven and Javadoc
818,Inderjeet Singh,"['gson/src/main/java/com/google/gson/Gson.java', 'gson/src/main/java/com/google/gson/GsonBuilder.java', 'gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java']","@@ -133,22 +133,6 @@
   private final boolean prettyPrinting;
   private final boolean lenient;
 
-  final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {
-    @SuppressWarnings(""unchecked"")
-    @Override public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-      return (T) fromJson(json, typeOfT);
-    }
-  };
-
-  final JsonSerializationContext serializationContext = new JsonSerializationContext() {
-    @Override public JsonElement serialize(Object src) {
-      return toJsonTree(src);
-    }
-    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
-      return toJsonTree(src, typeOfSrc);
-    }
-  };
-
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
    * following settings:, @@ -29,6 +29,7 @@
 
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
+import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 , @@ -14,31 +14,42 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
+import java.lang.reflect.Type;
 
 /**
  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the
  * tree adapter may be serialization-only or deserialization-only, this class
  * has a facility to lookup a delegate type adapter on demand.
  */
-final class TreeTypeAdapter<T> extends TypeAdapter<T> {
+public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final JsonSerializer<T> serializer;
   private final JsonDeserializer<T> deserializer;
   private final Gson gson;
   private final TypeToken<T> typeToken;
   private final TypeAdapterFactory skipPast;
+  private final GsonContextImpl context = new GsonContextImpl();
 
   /** The delegate is lazily created because it may not be needed, and creating it may fail. */
   private TypeAdapter<T> delegate;
 
-  TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
+  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
     this.serializer = serializer;
     this.deserializer = deserializer;
@@ -55,7 +66,7 @@
     if (value.isJsonNull()) {
       return null;
     }
-    return deserializer.deserialize(value, typeToken.getType(), gson.deserializationContext);
+    return deserializer.deserialize(value, typeToken.getType(), context);
   }
 
   @Override public void write(JsonWriter out, T value) throws IOException {
@@ -67,7 +78,7 @@
       out.nullValue();
       return;
     }
-    JsonElement tree = serializer.serialize(value, typeToken.getType(), gson.serializationContext);
+    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);
     Streams.write(tree, out);
   }
 
@@ -105,7 +116,7 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
     return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);
   }
 
-  private static class SingleTypeFactory implements TypeAdapterFactory {
+  private static final class SingleTypeFactory implements TypeAdapterFactory {
     private final TypeToken<?> exactType;
     private final boolean matchRawType;
     private final Class<?> hierarchyType;
@@ -138,4 +149,17 @@ public static TypeAdapterFactory newTypeHierarchyFactory(
           : null;
     }
   }
+
+  private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {
+    @Override public JsonElement serialize(Object src) {
+      return gson.toJsonTree(src);
+    }
+    @Override public JsonElement serialize(Object src, Type typeOfSrc) {
+      return gson.toJsonTree(src, typeOfSrc);
+    }
+    @SuppressWarnings(""unchecked"")
+    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
+      return (R) gson.fromJson(json, typeOfT);
+    }
+  };
 }, ","…to where they are used.

Also moved TreeTypeAdapter to internal.bind package for potential use in JsonAdapterAnnotationFactory.",moved the JsonSerializationContext/JsonDeserializationContext fields …
820,Inderjeet Singh,['pom.xml'],"@@ -105,7 +105,7 @@
     <profile>
       <id>doclint-java8-disable</id>
       <activation>
-        <jdk>[1.8,</jdk>
+        <jdk>[1.8,)</jdk>
       </activation>
       <build>
         <plugins>, ",NaN,Fixed unbound range bug issue# 819
823,Ryan Scheidter,['UserGuide.md'],"@@ -46,7 +46,7 @@ Gson can work with arbitrary Java objects including pre-existing objects that yo
 * Allow pre-existing unmodifiable objects to be converted to and from JSON
 * Allow custom representations for objects
 * Support arbitrarily complex objects
-* Generate compact and readability JSON output
+* Generate compact and readable JSON output
 
 ## <a name=""TOC-Gson-Performance-and-Scalability""></a>Gson Performance and Scalability
 
@@ -141,8 +141,8 @@ BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
 * There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
 * If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
 * This implementation handles nulls correctly
-* While serialization, a null field is skipped from the output
-* While deserialization, a missing entry in JSON results in setting the corresponding field in the object to null
+* While serializing, a null field is skipped from the output
+* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to null
 * If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
 * Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
 
@@ -169,7 +169,7 @@ public class A {
 
 **NOTE**: The above class B can not (by default) be serialized with Gson.
 
-Gson can not deserialize `{""b"":""abc""}` into an instance of B since the class B is an inner class. if it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B. 
+Gson can not deserialize `{""b"":""abc""}` into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B. 
 
 ```java
 public class InstanceCreatorForB implements InstanceCreator<A.B> {
@@ -390,7 +390,7 @@ Type could be of a corresponding generic type
 
 #### <a name=""TOC-InstanceCreator-for-a-Parameterized-Type""></a>InstanceCreator for a Parameterized Type
 
-Sometimes that the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:
+Sometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:
 
 ```java
 class MyList<T> extends ArrayList<T> {
@@ -430,9 +430,9 @@ In the above example, an instance of the Id class can not be created without act
 
 ### <a name=""TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format""></a>Compact Vs. Pretty Printing for JSON Output Format
 
-The default JSON output that is provide by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, ""null"" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the [Null Object Support](#TOC-Null-Object-Support) section for information on configure Gson to output all null values.
+The default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, ""null"" fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the [Null Object Support](#TOC-Null-Object-Support) section for information on configure Gson to output all null values.
 
-If you like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default `JsonPrintFormatter` that has default line length of 80 character, 2 character indentation, and 4 character right margin.
+If you would like to use the Pretty Print feature, you must configure your `Gson` instance using the `GsonBuilder`. The `JsonFormatter` is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default `JsonPrintFormatter` that has default line length of 80 character, 2 character indentation, and 4 character right margin.
 
 The following is an example shows how to configure a `Gson` instance to use the default `JsonPrintFormatter` instead of the `JsonCompactFormatter`:
 ```
@@ -441,7 +441,7 @@ String jsonOutput = gson.toJson(someObject);
 ```
 ### <a name=""TOC-Null-Object-Support""></a>Null Object Support
 
-The default behaviour that is implemented in Gson is that `null` object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java.
+The default behaviour that is implemented in Gson is that `null` object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.
 
 Here's how you would configure a `Gson` instance to output null:
 
@@ -522,7 +522,7 @@ The output is:
 
 ### <a name=""TOC-Excluding-Fields-From-Serialization-and-Deserialization""></a>Excluding Fields From Serialization and Deserialization
 
-Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanism that allow field and class exclusion. If none of the below mechanism satisfy your needs then you can always use [custom serializers and deserializers](#TOC-Custom-Serialization-and-Deserializ).
+Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use [custom serializers and deserializers](#TOC-Custom-Serialization-and-Deserialization).
 
 #### <a name=""TOC-Java-Modifier-Exclusion""></a>Java Modifier Exclusion
 
@@ -535,7 +535,7 @@ Gson gson = new GsonBuilder()
     .create();
 ```
 
-NOTE: you can use any number of the `Modifier` constants to `excludeFieldsWithModifiers` method. For example:
+NOTE: you can give any number of the `Modifier` constants to the `excludeFieldsWithModifiers` method. For example:
 
 ```java
 Gson gson = new GsonBuilder(), ",Also fixed a broken link,UserGuide Grammar Corrections
826,Scott Brown,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -428,9 +428,9 @@ static void checkValidFloatingPoint(double value) {
    *  class StatsTypeAdapterFactory implements TypeAdapterFactory {
    *    public int numReads = 0;
    *    public int numWrites = 0;
-   *    public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {
-   *      final TypeAdapter&lt;T&gt; delegate = gson.getDelegateAdapter(this, type);
-   *      return new TypeAdapter&lt;T&gt;() {
+   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+   *      return new TypeAdapter<T>() {
    *        public void write(JsonWriter out, T value) throws IOException {
    *          ++numWrites;
    *          delegate.write(out, value);, ","Fix for minor error on javadoc for <a href=""http://static.javadoc.io/com.google.code.gson/gson/2.6.2/com/google/gson/Gson.html#getDelegateAdapter-com.google.gson.TypeAdapterFactory-com.google.gson.reflect.TypeToken-"">Gson.getDelegateAdapter()</a> method

text in <a href=""http://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/whatsnew-1.5.0.html#{@code}"">@code</a> blocks is not treated as html when javadoc is compiled",minor javadoc @code block cleanup
829,Ugljesa Jovanovic,"['gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java', 'gson/src/test/java/com/google/gson/internal/UnsafeAllocatorInstantiationTest.java']","@@ -20,6 +20,7 @@
 import java.io.ObjectStreamClass;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 
 /**
  * Do sneaky things to allocate objects without invoking their constructors.
@@ -45,6 +46,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings(""unchecked"")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) allocateInstance.invoke(unsafe, c);
         }
       };
@@ -68,6 +70,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings(""unchecked"")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) newInstance.invoke(null, c, constructorId);
         }
       };
@@ -87,6 +90,7 @@ public static UnsafeAllocator create() {
         @Override
         @SuppressWarnings(""unchecked"")
         public <T> T newInstance(Class<T> c) throws Exception {
+          assertInstantiable(c);
           return (T) newInstance.invoke(null, c, Object.class);
         }
       };
@@ -101,4 +105,19 @@ public static UnsafeAllocator create() {
       }
     };
   }
+
+  /**
+   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
+   * throw an {@link java.lang.UnsupportedOperationException}
+   * @param c instance of the class to be checked
+   */
+  private static void assertInstantiable(Class<?> c) {
+    int modifiers = c.getModifiers();
+    if (Modifier.isInterface(modifiers)) {
+      throw new UnsupportedOperationException(""Interface can't be instantiated! Interface name: "" + c.getName());
+    }
+    if (Modifier.isAbstract(modifiers)) {
+      throw new UnsupportedOperationException(""Abstract class can't be instantiated! Class name: "" + c.getName());
+    }
+  }
 }, @@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import junit.framework.TestCase;
+
+/**
+ * Test unsafe allocator instantiation
+ * @author Ugljesa Jovanovic
+ */
+public final class UnsafeAllocatorInstantiationTest extends TestCase {
+
+  public interface Interface {
+  }
+
+  public static abstract class AbstractClass {
+  }
+
+  public static class ConcreteClass {
+  }
+
+  /**
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * to instantiate an interface
+   */
+  public void testInterfaceInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(Interface.class);
+      fail();
+    } catch (Exception e) {
+      assertEquals(e.getClass(), UnsupportedOperationException.class);
+    }
+  }
+
+  /**
+   * Ensure that the {@link java.lang.UnsupportedOperationException} is thrown when  trying
+   * to instantiate an abstract class
+   */
+  public void testAbstractClassInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(AbstractClass.class);
+      fail();
+    } catch (Exception e) {
+      assertEquals(e.getClass(), UnsupportedOperationException.class);
+    }
+  }
+
+  /**
+   * Ensure that no exception is thrown when trying to instantiate a concrete class
+   */
+  public void testConcreteClassInstantiation() {
+    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+    try {
+      unsafeAllocator.newInstance(ConcreteClass.class);
+    } catch (Exception e) {
+      fail();
+    }
+  }
+}, ",If class can't be instantiated throw an unsupported operation exception. On different android devices attempt to instantiate interface or abstract class would crash the VM sometimes with only a segmentation fault message and no other useful logs (Issue #817). Checking for interface or abstract class modifiers before trying to allocate instance and throwing an exception will help debugging.,Check if class can be instantiated based on class modifiers. Fix for #817
830,Arthur Gavlyukovskiy,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -679,7 +679,7 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
       JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
       toJson(jsonElement, jsonWriter);
     } catch (IOException e) {
-      throw new RuntimeException(e);
+      throw new JsonIOException(e);
     }
   }
 , ","Javadoc says that JsonIOException will be thrown if any problem happened, but actually I'm getting RuntimeException only in that method.",fixed throwing RuntimeException instead of JsonIOException
832,Inderjeet Singh,"['gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/Streams.java', 'gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java', 'gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java', 'gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java']","@@ -24,7 +24,6 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
 
 import com.google.gson.internal.bind.util.ISO8601Utils;
 , @@ -72,7 +72,6 @@ public static void write(JsonElement element, JsonWriter writer) throws IOExcept
     TypeAdapters.JSON_ELEMENT.write(writer, element);
   }
 
-  @SuppressWarnings(""resource"")
   public static Writer writerForAppendable(Appendable appendable) {
     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);
   }, @@ -32,6 +32,7 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
@@ -104,14 +105,22 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
     // special casing primitives here saves ~5% on Android...
+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
+    TypeAdapter<?> mapped = null;
+    if (annotation != null) {
+      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);
+    }
+    final boolean jsonAdapterPresent = mapped != null;
+    if (mapped == null) mapped = context.getAdapter(fieldType);
+
+    final TypeAdapter<?> typeAdapter = mapped;
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);
       @SuppressWarnings({""unchecked"", ""rawtypes""}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
-        TypeAdapter t =
-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());
+        TypeAdapter t = jsonAdapterPresent ? typeAdapter
+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
@@ -129,15 +138,6 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
     };
   }
 
-  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {
-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
-    if (annotation != null) {
-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);
-      if (adapter != null) return adapter;
-    }
-    return gson.getAdapter(fieldType);
-  }
-
   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {
     Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();
     if (raw.isInterface()) {, @@ -15,14 +15,15 @@
  */
 package com.google.gson.internal.bind;
 
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
-import java.io.IOException;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
 
 final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {
   private final Gson context;, @@ -63,7 +63,6 @@ public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {
         @Override public void write(JsonWriter out, Part part) throws IOException {
           throw new AssertionError();
         }
-
         @Override public Part read(JsonReader in) throws IOException {
           throw new AssertionError();
         }
@@ -220,4 +219,53 @@ private GadgetWithOptionalPart(Part part) {
       this.part = part;
     }
   }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithOptionalPart(new Part(""foo"")));
+    assertEquals(""{\""part\"":\""PartJsonFieldAnnotationAdapter\""}"", json);
+    GadgetWithOptionalPart gadget = gson.fromJson(""{'part':'foo'}"", GadgetWithOptionalPart.class);
+    assertEquals(""PartJsonFieldAnnotationAdapter"", gadget.part.name);
+  }
+
+  /** Regression test contributed through https://github.com/google/gson/issues/831 */
+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {
+    Gson gson = new Gson();
+    String json = gson.toJson(new GadgetWithPrimitivePart(42));
+    assertEquals(""{\""part\"":\""42\""}"", json);
+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);
+    assertEquals(42, gadget.part);
+  }
+
+  private static final class GadgetWithPrimitivePart {
+    @JsonAdapter(LongToStringTypeAdapterFactory.class)
+    final long part;
+
+    private GadgetWithPrimitivePart(long part) {
+      this.part = part;
+    }
+  }
+
+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {
+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {
+      @Override public void write(JsonWriter out, Long value) throws IOException {
+        out.value(value.toString());
+      }
+      @Override public Long read(JsonReader in) throws IOException {
+        return in.nextLong();
+      }
+    };
+    @SuppressWarnings(""unchecked"")
+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      Class<?> cls = type.getRawType();
+      if (Long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      } else if (long.class.isAssignableFrom(cls)) {
+        return (TypeAdapter<T>) ADAPTER;
+      }
+      throw new IllegalStateException(""Non-long field of type "" + type
+          + "" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)"");
+    }
+  }
 }, ",…elds.,Ensuring that JsonAdapter annotation works correctly for primitive fi…
836,Jake Wharton,"['gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java', 'gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/main/java/com/google/gson/stream/JsonWriter.java', 'gson/src/test/java/com/google/gson/stream/JsonWriterTest.java']","@@ -159,6 +159,14 @@ private void put(JsonElement value) {
     return this;
   }
 
+  @Override public JsonWriter value(Boolean value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    put(new JsonPrimitive(value));
+    return this;
+  }
+
   @Override public JsonWriter value(double value) throws IOException {
     if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException(""JSON forbids NaN and infinities: "" + value);, @@ -162,10 +162,6 @@ public Boolean read(JsonReader in) throws IOException {
     }
     @Override
     public void write(JsonWriter out, Boolean value) throws IOException {
-      if (value == null) {
-        out.nullValue();
-        return;
-      }
       out.value(value);
     }
   };, @@ -468,6 +468,21 @@ public JsonWriter value(boolean value) throws IOException {
     return this;
   }
 
+  /**
+   * Encodes {@code value}.
+   *
+   * @return this writer.
+   */
+  public JsonWriter value(Boolean value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    writeDeferredName();
+    beforeValue();
+    out.write(value ? ""true"" : ""false"");
+    return this;
+  }
+
   /**
    * Encodes {@code value}.
    *, @@ -283,6 +283,17 @@ public void testBooleans() throws IOException {
     assertEquals(""[true,false]"", stringWriter.toString());
   }
 
+  public void testBoxedBooleans() throws IOException {
+    StringWriter stringWriter = new StringWriter();
+    JsonWriter jsonWriter = new JsonWriter(stringWriter);
+    jsonWriter.beginArray();
+    jsonWriter.value((Boolean) true);
+    jsonWriter.value((Boolean) false);
+    jsonWriter.value((Boolean) null);
+    jsonWriter.endArray();
+    assertEquals(""[true,false,null]"", stringWriter.toString());
+  }
+
   public void testNulls() throws IOException {
     StringWriter stringWriter = new StringWriter();
     JsonWriter jsonWriter = new JsonWriter(stringWriter);, ","When calling value() with a Boolean, overload resolution would choose value(boolean) which would throw an NPE on null. The other boxed types are all numbers which would resolve to value(Number) and behave correctly.

Proof this happens: https://github.com/bugsnag/bugsnag-android/pull/42",Add boxed boolean value() overload.
837,轻微,['UserGuide.md'],"@@ -104,7 +104,7 @@ Integer one = gson.fromJson(""1"", Integer.class);
 Long one = gson.fromJson(""1"", Long.class);
 Boolean false = gson.fromJson(""false"", Boolean.class);
 String str = gson.fromJson(""\""abc\"""", String.class);
-String anotherStr = gson.fromJson(""[\""abc\""]"", String.class);
+String[] anotherStr = gson.fromJson(""[\""abc\""]"", String[].class);
 ```
 
 ### <a name=""TOC-Object-Examples""></a>Object Examples, ","String anotherStr = gson.fromJson(""[\""abc\""]"", String.class); => String[] anotherStr = gson.fromJson(""[\""abc\""]"", String[].class);", Documentation Error
839,Jake Wharton,['gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java'],"@@ -35,8 +35,9 @@
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.LinkedHashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
@@ -67,20 +68,22 @@ static boolean excludeField(Field f, boolean serialize, Excluder excluder) {
 
   /** first element holds the default name */
   private List<String> getFieldNames(Field f) {
-    return getFieldName(fieldNamingPolicy, f);
-  }
+    SerializedName annotation = f.getAnnotation(SerializedName.class);
+    if (annotation == null) {
+      String name = fieldNamingPolicy.translateName(f);
+      return Collections.singletonList(name);
+    }
 
-  /** first element holds the default name */
-  static List<String> getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {
-    SerializedName serializedName = f.getAnnotation(SerializedName.class);
-    List<String> fieldNames = new LinkedList<String>();
-    if (serializedName == null) {
-      fieldNames.add(fieldNamingPolicy.translateName(f));
-    } else {
-      fieldNames.add(serializedName.value());
-      for (String alternate : serializedName.alternate()) {
-        fieldNames.add(alternate);
-      }
+    String serializedName = annotation.value();
+    String[] alternates = annotation.alternate();
+    if (alternates.length == 0) {
+      return Collections.singletonList(serializedName);
+    }
+
+    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);
+    fieldNames.add(serializedName);
+    for (String alternate : alternates) {
+      fieldNames.add(alternate);
     }
     return fieldNames;
   }, ","The common cases (no @SerializedName and a single-value @SerializedName) now use a specialized one-element collection. Cases with alternate names use a much more space efficient ArrayList which is exactly sized.

This is also a performance win for adapter initialization since an index-based loop was used on the returned type for which LinkedList is not suited for.",Optimize list allocation for every reflective field.
840,Jake Wharton,['gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java'],"@@ -20,12 +20,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -163,7 +163,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
       } else if (Queue.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
           @Override public T construct() {
-            return (T) new LinkedList<Object>();
+            return (T) new ArrayDeque<Object>();
           }
         };
       } else {, ",Now that we require Java 1.6 or newer this much more efficient implementation can be used as the default.,Switch default Queue implementation to ArrayDeque.
848,David Hwang,['UserGuide.md'],"@@ -307,7 +307,7 @@ You can also find source code for some commonly used classes such as JodaTime at
 Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
 Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:
 
-* Json Serialiers: Need to define custom serialization for an object
+* Json Serializers: Need to define custom serialization for an object
 * Json Deserializers: Needed to define custom deserialization for a type
 
 * Instance Creators: Not needed if no-args constructor is available or a deserializer is registered, ","Changed ""Serialiers"" to ""Serializers""",Typo in the user guide.
853,Sebastian Bischoff,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -719,7 +719,7 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
   }
 
   /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
+   * Returns a new JSON reader configured for the settings on this Gson instance.
    */
   public JsonReader newJsonReader(Reader reader) {
     JsonReader jsonReader = new JsonReader(reader);, ",NaN,"Corrected documentation, copy&paste error"
857,Inderjeet Singh,['gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java'],"@@ -805,7 +805,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
           constantToName.put(constant, name);
         }
       } catch (NoSuchFieldException e) {
-        throw new AssertionError(""Missing field in "" + classOfT.getName(), e);
+        throw new AssertionError(e);
       }
     }
     @Override public T read(JsonReader in) throws IOException {, ",NaN,Replaced a JDK 1.7 specific method with its JDK 1.6 equivalent.
863,Nykolas Laurentino de Lima,"['proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java', 'proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java']","@@ -262,8 +262,8 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
           String jsonFieldName =
               getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());
 
-          if (jsonObject.has(jsonFieldName)) {
-            JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          JsonElement jsonElement = jsonObject.get(jsonFieldName);
+          if (jsonElement != null && !jsonElement.isJsonNull()) {
             // Do not reuse jsonFieldName here, it might have a custom value
             Object fieldValue;
             if (fieldDescriptor.getType() == ENUM_TYPE) {, @@ -66,4 +66,11 @@ public void testDeserializeProto() {
     assertEquals(""foo"", proto.getMsg());
     assertEquals(3, proto.getCount());
   }
+
+  public void testDeserializeWithExplicitNullValue() {
+    SimpleProto proto = gson.fromJson(""{msg:'foo',count:null}"", SimpleProto.class);
+    assertEquals(""foo"", proto.getMsg());
+    assertEquals(0, proto.getCount());
+  }
+
 }, ","Fix error when trying deserialize JSON with explicit `NULL` value.

```
{msg:'foo', count:null}
```",handle explicit null values in JSON
864,Juan Andrés,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -97,7 +97,7 @@
  * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
  * name to the {@link #of} factory method. If you don't supply an explicit type
  * field name, {@code ""type""} will be used. <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
  *       = RuntimeTypeAdapterFactory.of(Shape.class, ""type"");
  * }</pre>
  * Next register all of your subtypes. Every subtype must be explicitly
@@ -108,14 +108,14 @@
  *   shapeAdapter.registerSubtype(Circle.class, ""Circle"");
  *   shapeAdapter.registerSubtype(Diamond.class, ""Diamond"");
  * }</pre>
- * Finally, register the type adapter in your application's GSON builder:
+ * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapter(Shape.class, shapeAdapter)
+ *       .registerTypeAdapterFactory(Shape.class, shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)
+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
  *       .registerSubtype(Rectangle.class)
  *       .registerSubtype(Circle.class)
  *       .registerSubtype(Diamond.class);, ","Instances of classes that implement `RuntimeTypeAdapterFactory` should be registered using the `registerTypeAdapterFactory` method instead of `registerTypeAdapter` method on `GsonBuilder`.

Note that since `registerTypeAdapter(Type type, Object typeAdapter)` accepts an `Object`. Therefore, users of this class might not notice this until runtime.",Minor documentation fix on RuntimeTypeAdapterFactory
865,Juan Andrés,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -111,7 +111,7 @@
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapterFactory(Shape.class, shapeAdapterFactory)
+ *       .registerTypeAdapterFactory(shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code, ",See @JakeWharton's comment on #864.,Fix registerTypeAdapterFactory method usage
870,Jake Wharton,['gson/src/main/java/com/google/gson/stream/JsonReader.java'],"@@ -347,8 +347,7 @@ public void beginArray() throws IOException {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected BEGIN_ARRAY but was "" + peek() + locationString());
     }
   }
 
@@ -366,8 +365,7 @@ public void endArray() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException(""Expected END_ARRAY but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected END_ARRAY but was "" + peek() + locationString());
     }
   }
 
@@ -384,8 +382,7 @@ public void beginObject() throws IOException {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected BEGIN_OBJECT but was "" + peek() + locationString());
     }
   }
 
@@ -404,8 +401,7 @@ public void endObject() throws IOException {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException(""Expected END_OBJECT but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected END_OBJECT but was "" + peek() + locationString());
     }
   }
 
@@ -790,8 +786,7 @@ public String nextName() throws IOException {
     } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
       result = nextQuotedValue('""');
     } else {
-      throw new IllegalStateException(""Expected a name but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected a name but was "" + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathNames[stackSize - 1] = result;
@@ -827,8 +822,7 @@ public String nextString() throws IOException {
       result = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else {
-      throw new IllegalStateException(""Expected a string but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected a string but was "" + peek() + locationString());
     }
     peeked = PEEKED_NONE;
     pathIndices[stackSize - 1]++;
@@ -856,8 +850,7 @@ public boolean nextBoolean() throws IOException {
       pathIndices[stackSize - 1]++;
       return false;
     }
-    throw new IllegalStateException(""Expected a boolean but was "" + peek()
-        + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+    throw new IllegalStateException(""Expected a boolean but was "" + peek() + locationString());
   }
 
   /**
@@ -876,8 +869,7 @@ public void nextNull() throws IOException {
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
     } else {
-      throw new IllegalStateException(""Expected null but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected null but was "" + peek() + locationString());
     }
   }
 
@@ -910,15 +902,14 @@ public double nextDouble() throws IOException {
     } else if (p == PEEKED_UNQUOTED) {
       peekedString = nextUnquotedValue();
     } else if (p != PEEKED_BUFFERED) {
-      throw new IllegalStateException(""Expected a double but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected a double but was "" + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new MalformedJsonException(""JSON forbids NaN and infinities: "" + result
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new MalformedJsonException(
+          ""JSON forbids NaN and infinities: "" + result + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -966,16 +957,14 @@ public long nextLong() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException(""Expected a long but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected a long but was "" + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new NumberFormatException(""Expected a long but was "" + peekedString
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new NumberFormatException(""Expected a long but was "" + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -1172,8 +1161,7 @@ public int nextInt() throws IOException {
     if (p == PEEKED_LONG) {
       result = (int) peekedLong;
       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new NumberFormatException(""Expected an int but was "" + peekedLong
-            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+        throw new NumberFormatException(""Expected an int but was "" + peekedLong + locationString());
       }
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
@@ -1198,16 +1186,14 @@ public int nextInt() throws IOException {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException(""Expected an int but was "" + peek()
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new IllegalStateException(""Expected an int but was "" + peek() + locationString());
     }
 
     peeked = PEEKED_BUFFERED;
     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new NumberFormatException(""Expected an int but was "" + peekedString
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+      throw new NumberFormatException(""Expected an int but was "" + peekedString + locationString());
     }
     peekedString = null;
     peeked = PEEKED_NONE;
@@ -1315,14 +1301,6 @@ private boolean fillBuffer(int minimum) throws IOException {
     return false;
   }
 
-  int getLineNumber() {
-    return lineNumber + 1;
-  }
-
-  int getColumnNumber() {
-    return pos - lineStart + 1;
-  }
-
   /**
    * Returns the next character in the stream that is neither whitespace nor a
    * part of a comment. When this returns, the returned character is always at
@@ -1412,8 +1390,7 @@ private int nextNonWhitespace(boolean throwOnEof) throws IOException {
       }
     }
     if (throwOnEof) {
-      throw new EOFException(""End of input""
-          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber());
+      throw new EOFException(""End of input"" + locationString());
     } else {
       return -1;
     }
@@ -1465,8 +1442,13 @@ private boolean skipTo(String toFind) throws IOException {
   }
 
   @Override public String toString() {
-    return getClass().getSimpleName()
-        + "" at line "" + getLineNumber() + "" column "" + getColumnNumber();
+    return getClass().getSimpleName() + locationString();
+  }
+
+  private String locationString() {
+    int line = lineNumber + 1;
+    int column = pos - lineStart + 1;
+    return "" at line "" + line + "" column "" + column + "" path "" + getPath();
   }
 
   /**
@@ -1571,8 +1553,7 @@ private char readEscapeCharacter() throws IOException {
    * with this reader's content.
    */
   private IOException syntaxError(String message) throws IOException {
-    throw new MalformedJsonException(message
-        + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
+    throw new MalformedJsonException(message + locationString());
   }
 
   /**
@@ -1615,9 +1596,8 @@ private void consumeNonExecutePrefix() throws IOException {
         } else if (p == PEEKED_UNQUOTED_NAME) {
           reader.peeked = PEEKED_UNQUOTED;
         } else {
-          throw new IllegalStateException(""Expected a name but was "" + reader.peek() + "" ""
-              + "" at line "" + reader.getLineNumber() + "" column "" + reader.getColumnNumber()
-              + "" path "" + reader.getPath());
+          throw new IllegalStateException(
+              ""Expected a name but was "" + reader.peek() + reader.locationString());
         }
       }
     };, ",NaN,Consolidate location and path rendering for exceptions.
871,Jake Wharton,"['gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java', 'pom.xml']","@@ -25,9 +25,7 @@
 import com.google.gson.stream.JsonToken;
 import java.io.IOException;
 import java.io.Reader;
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -47,35 +45,57 @@
   };
   private static final Object SENTINEL_CLOSED = new Object();
 
-  private final List<Object> stack = new ArrayList<Object>();
+  /*
+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+   */
+  private Object[] stack = new Object[32];
+  private int stackSize = 0;
+
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
 
   public JsonTreeReader(JsonElement element) {
     super(UNREADABLE_READER);
-    stack.add(element);
+    push(element);
   }
 
   @Override public void beginArray() throws IOException {
     expect(JsonToken.BEGIN_ARRAY);
     JsonArray array = (JsonArray) peekStack();
-    stack.add(array.iterator());
+    push(array.iterator());
+    pathIndices[stackSize - 1] = 0;
   }
 
   @Override public void endArray() throws IOException {
     expect(JsonToken.END_ARRAY);
     popStack(); // empty iterator
     popStack(); // array
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public void beginObject() throws IOException {
     expect(JsonToken.BEGIN_OBJECT);
     JsonObject object = (JsonObject) peekStack();
-    stack.add(object.entrySet().iterator());
+    push(object.entrySet().iterator());
   }
 
   @Override public void endObject() throws IOException {
     expect(JsonToken.END_OBJECT);
     popStack(); // empty iterator
     popStack(); // object
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public boolean hasNext() throws IOException {
@@ -84,19 +104,19 @@ public JsonTreeReader(JsonElement element) {
   }
 
   @Override public JsonToken peek() throws IOException {
-    if (stack.isEmpty()) {
+    if (stackSize == 0) {
       return JsonToken.END_DOCUMENT;
     }
 
     Object o = peekStack();
     if (o instanceof Iterator) {
-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;
+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;
       Iterator<?> iterator = (Iterator<?>) o;
       if (iterator.hasNext()) {
         if (isObject) {
           return JsonToken.NAME;
         } else {
-          stack.add(iterator.next());
+          push(iterator.next());
           return peek();
         }
       } else {
@@ -127,89 +147,121 @@ public JsonTreeReader(JsonElement element) {
   }
 
   private Object peekStack() {
-    return stack.get(stack.size() - 1);
+    return stack[stackSize - 1];
   }
 
   private Object popStack() {
-    return stack.remove(stack.size() - 1);
+    Object result = stack[--stackSize];
+    stack[stackSize] = null;
+    return result;
   }
 
   private void expect(JsonToken expected) throws IOException {
     if (peek() != expected) {
-      throw new IllegalStateException(""Expected "" + expected + "" but was "" + peek());
+      throw new IllegalStateException(
+          ""Expected "" + expected + "" but was "" + peek() + locationString());
     }
   }
 
   @Override public String nextName() throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    return (String) entry.getKey();
+    String result = (String) entry.getKey();
+    pathNames[stackSize - 1] = result;
+    push(entry.getValue());
+    return result;
   }
 
   @Override public String nextString() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {
-      throw new IllegalStateException(""Expected "" + JsonToken.STRING + "" but was "" + token);
+      throw new IllegalStateException(
+          ""Expected "" + JsonToken.STRING + "" but was "" + token + locationString());
+    }
+    String result = ((JsonPrimitive) popStack()).getAsString();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
-    return ((JsonPrimitive) popStack()).getAsString();
+    return result;
   }
 
   @Override public boolean nextBoolean() throws IOException {
     expect(JsonToken.BOOLEAN);
-    return ((JsonPrimitive) popStack()).getAsBoolean();
+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
+    return result;
   }
 
   @Override public void nextNull() throws IOException {
     expect(JsonToken.NULL);
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
   }
 
   @Override public double nextDouble() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(""Expected "" + JsonToken.NUMBER + "" but was "" + token);
+      throw new IllegalStateException(
+          ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString());
     }
     double result = ((JsonPrimitive) peekStack()).getAsDouble();
     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
       throw new NumberFormatException(""JSON forbids NaN and infinities: "" + result);
     }
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public long nextLong() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(""Expected "" + JsonToken.NUMBER + "" but was "" + token);
+      throw new IllegalStateException(
+          ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString());
     }
     long result = ((JsonPrimitive) peekStack()).getAsLong();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public int nextInt() throws IOException {
     JsonToken token = peek();
     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {
-      throw new IllegalStateException(""Expected "" + JsonToken.NUMBER + "" but was "" + token);
+      throw new IllegalStateException(
+          ""Expected "" + JsonToken.NUMBER + "" but was "" + token + locationString());
     }
     int result = ((JsonPrimitive) peekStack()).getAsInt();
     popStack();
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+    }
     return result;
   }
 
   @Override public void close() throws IOException {
-    stack.clear();
-    stack.add(SENTINEL_CLOSED);
+    stack = new Object[] { SENTINEL_CLOSED };
+    stackSize = 1;
   }
 
   @Override public void skipValue() throws IOException {
     if (peek() == JsonToken.NAME) {
       nextName();
+      pathNames[stackSize - 2] = ""null"";
     } else {
       popStack();
+      pathNames[stackSize - 1] = ""null"";
     }
+    pathIndices[stackSize - 1]++;
   }
 
   @Override public String toString() {
@@ -220,7 +272,45 @@ public void promoteNameToValue() throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
-    stack.add(entry.getValue());
-    stack.add(new JsonPrimitive((String)entry.getKey()));
+    push(entry.getValue());
+    push(new JsonPrimitive((String) entry.getKey()));
+  }
+
+  private void push(Object newTop) {
+    if (stackSize == stack.length) {
+      Object[] newStack = new Object[stackSize * 2];
+      int[] newPathIndices = new int[stackSize * 2];
+      String[] newPathNames = new String[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
+      stack = newStack;
+      pathIndices = newPathIndices;
+      pathNames = newPathNames;
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  @Override public String getPath() {
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0; i < stackSize; i++) {
+      if (stack[i] instanceof JsonArray) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('[').append(pathIndices[i]).append(']');
+        }
+      } else if (stack[i] instanceof JsonObject) {
+        if (stack[++i] instanceof Iterator) {
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+        }
+      }
+    }
+    return result.toString();
+  }
+
+  private String locationString() {
+    return "" at path "" + getPath();
   }
 }, @@ -16,15 +16,35 @@
 
 package com.google.gson.stream;
 
+import com.google.gson.JsonElement;
+import com.google.gson.internal.Streams;
+import com.google.gson.internal.bind.JsonTreeReader;
 import java.io.IOException;
 import java.io.StringReader;
-import junit.framework.TestCase;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-@SuppressWarnings(""resource"")
-public class JsonReaderPathTest extends TestCase {
-  public void testPath() throws IOException {
-    JsonReader reader = new JsonReader(
-        new StringReader(""{\""a\"":[2,true,false,null,\""b\"",{\""c\"":\""d\""},[3]]}""));
+import static junit.framework.Assert.assertEquals;
+import static org.junit.Assume.assumeTrue;
+
+@RunWith(Parameterized.class)
+public class JsonReaderPathTest {
+  @Parameterized.Parameters(name = ""{0}"")
+  public static List<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { Factory.STRING_READER },
+        new Object[] { Factory.OBJECT_READER }
+    );
+  }
+
+  @Parameterized.Parameter
+  public Factory factory;
+
+  @Test public void path() throws IOException {
+    JsonReader reader = factory.create(""{\""a\"":[2,true,false,null,\""b\"",{\""c\"":\""d\""},[3]]}"");
     assertEquals(""$"", reader.getPath());
     reader.beginObject();
     assertEquals(""$."", reader.getPath());
@@ -62,8 +82,8 @@ public void testPath() throws IOException {
     assertEquals(""$"", reader.getPath());
   }
 
-  public void testObjectPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""{\""a\"":1,\""b\"":2}""));
+  @Test public void objectPath() throws IOException {
+    JsonReader reader = factory.create(""{\""a\"":1,\""b\"":2}"");
     assertEquals(""$"", reader.getPath());
 
     reader.peek();
@@ -102,8 +122,8 @@ public void testObjectPath() throws IOException {
     assertEquals(""$"", reader.getPath());
   }
 
-  public void testArrayPath() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[1,2]""));
+  @Test public void arrayPath() throws IOException {
+    JsonReader reader = factory.create(""[1,2]"");
     assertEquals(""$"", reader.getPath());
 
     reader.peek();
@@ -132,8 +152,10 @@ public void testArrayPath() throws IOException {
     assertEquals(""$"", reader.getPath());
   }
 
-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[][]""));
+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {
+    assumeTrue(factory == Factory.STRING_READER);
+
+    JsonReader reader = factory.create(""[][]"");
     reader.setLenient(true);
     reader.beginArray();
     reader.endArray();
@@ -143,40 +165,41 @@ public void testMultipleTopLevelValuesInOneDocument() throws IOException {
     assertEquals(""$"", reader.getPath());
   }
 
-  public void testSkipArrayElements() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[1,2,3]""));
+  @Test public void skipArrayElements() throws IOException {
+    JsonReader reader = factory.create(""[1,2,3]"");
     reader.beginArray();
     reader.skipValue();
     reader.skipValue();
     assertEquals(""$[2]"", reader.getPath());
   }
 
-  public void testSkipObjectNames() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""{\""a\"":1}""));
+  @Test public void skipObjectNames() throws IOException {
+    JsonReader reader = factory.create(""{\""a\"":1}"");
     reader.beginObject();
     reader.skipValue();
     assertEquals(""$.null"", reader.getPath());
   }
 
-  public void testSkipObjectValues() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""{\""a\"":1,\""b\"":2}""));
+  @Test public void skipObjectValues() throws IOException {
+    JsonReader reader = factory.create(""{\""a\"":1,\""b\"":2}"");
     reader.beginObject();
+    assertEquals(""$."", reader.getPath());
     reader.nextName();
     reader.skipValue();
     assertEquals(""$.null"", reader.getPath());
     reader.nextName();
     assertEquals(""$.b"", reader.getPath());
   }
 
-  public void testSkipNestedStructures() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[[1,2,3],4]""));
+  @Test public void skipNestedStructures() throws IOException {
+    JsonReader reader = factory.create(""[[1,2,3],4]"");
     reader.beginArray();
     reader.skipValue();
     assertEquals(""$[1]"", reader.getPath());
   }
 
-  public void testArrayOfObjects() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[{},{},{}]""));
+  @Test public void arrayOfObjects() throws IOException {
+    JsonReader reader = factory.create(""[{},{},{}]"");
     reader.beginArray();
     assertEquals(""$[0]"", reader.getPath());
     reader.beginObject();
@@ -195,8 +218,8 @@ public void testArrayOfObjects() throws IOException {
     assertEquals(""$"", reader.getPath());
   }
 
-  public void testArrayOfArrays() throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(""[[],[],[]]""));
+  @Test public void arrayOfArrays() throws IOException {
+    JsonReader reader = factory.create(""[[],[],[]]"");
     reader.beginArray();
     assertEquals(""$[0]"", reader.getPath());
     reader.beginArray();
@@ -214,4 +237,20 @@ public void testArrayOfArrays() throws IOException {
     reader.endArray();
     assertEquals(""$"", reader.getPath());
   }
+
+  enum Factory {
+    STRING_READER {
+      @Override public JsonReader create(String data) {
+        return new JsonReader(new StringReader(data));
+      }
+    },
+    OBJECT_READER {
+      @Override public JsonReader create(String data) {
+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));
+        return new JsonTreeReader(element);
+      }
+    };
+
+    abstract JsonReader create(String data);
+  }
 }, @@ -51,7 +51,7 @@
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>3.8.2</version>
+        <version>4.12</version>
         <scope>test</scope>
       </dependency>
     </dependencies>, ","Since @swankjesse did the JSON Path for `JsonReader`, please review this for correctness (although it passes your tests!).",Implement JSON Path for JsonTreeReader.
872,Jake Wharton,"['gson/src/main/java/com/google/gson/JsonObject.java', 'gson/src/test/java/com/google/gson/JsonObjectTest.java']","@@ -132,6 +132,15 @@ private JsonElement createJsonElement(Object value) {
     return members.entrySet();
   }
 
+  /**
+   * Returns the number of key/value pairs in the object.
+   *
+   * @return the number of key/value pairs in the object.
+   */
+  public int size() {
+    return members.size();
+  }
+
   /**
    * Convenience method to check if a member with the specified name is present in this object.
    *, @@ -158,6 +158,20 @@ public void testEqualsNonEmptyObject() {
     assertFalse(b.equals(a));
   }
 
+  public void testSize() {
+    JsonObject o = new JsonObject();
+    assertEquals(0, o.size());
+
+    o.add(""Hello"", new JsonPrimitive(1));
+    assertEquals(1, o.size());
+
+    o.add(""Hi"", new JsonPrimitive(1));
+    assertEquals(2, o.size());
+
+    o.remove(""Hello"");
+    assertEquals(1, o.size());
+  }
+
   public void testDeepCopy() {
     JsonObject original = new JsonObject();
     JsonArray firstEntry = new JsonArray();, ",I ran into this being absent when attempting to pre-size a collection based on the contents of a `JsonObject`.,Expose JsonObject size.
873,Inderjeet Singh,"['gson/src/main/java/com/google/gson/Gson.java', 'gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java']","@@ -134,7 +134,7 @@
   private final boolean generateNonExecutableJson;
   private final boolean prettyPrinting;
   private final boolean lenient;
-  private JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
 
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
@@ -488,14 +488,13 @@ static void checkValidFloatingPoint(double value) {
    * @since 2.2
    */
   public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {
-    boolean skipPastFound = false;
-
     // Hack. If the skipPast factory isn't registered, assume the factory is being requested via
     // our @JsonAdapter annotation.
     if (!factories.contains(skipPast)) {
       skipPast = jsonAdapterFactory;
     }
 
+    boolean skipPastFound = false;
     for (TypeAdapterFactory factory : factories) {
       if (!skipPastFound) {
         if (factory == skipPast) {, @@ -274,20 +274,20 @@ private GadgetWithPrimitivePart(long part) {
   }
 
   public void testFieldAnnotationWorksForParameterizedType() {
-      Gson gson = new Gson();
-      String json = gson.toJson(new Gizmo2(Arrays.asList(new Part(""Part""))));
-      assertEquals(""{\""part\"":\""GizmoPartTypeAdapterFactory\""}"", json);
-      Gizmo2 computer = gson.fromJson(""{'part':'Part'}"", Gizmo2.class);
-      assertEquals(""GizmoPartTypeAdapterFactory"", computer.part.get(0).name);
-    }
+    Gson gson = new Gson();
+    String json = gson.toJson(new Gizmo2(Arrays.asList(new Part(""Part""))));
+    assertEquals(""{\""part\"":\""GizmoPartTypeAdapterFactory\""}"", json);
+    Gizmo2 computer = gson.fromJson(""{'part':'Part'}"", Gizmo2.class);
+    assertEquals(""GizmoPartTypeAdapterFactory"", computer.part.get(0).name);
+  }
 
   private static final class Gizmo2 {
-      @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)
-      List<Part> part;
-      Gizmo2(List<Part> part) {
-        this.part = part;
-      }
+    @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)
+    List<Part> part;
+    Gizmo2(List<Part> part) {
+      this.part = part;
     }
+  }
 
   private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
     @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {, ",NaN,Add support for JsonSerializer/JsonDeserializer in the JsonAdapter annotation
875,Inderjeet Singh,"['gson/pom.xml', 'pom.xml']","@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.6.3-SNAPSHOT</version>
+    <version>2.7-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>, @@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.6.3-SNAPSHOT</version>
+  <version>2.7-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>, ",NaN,Preparing 2.7-SNAPSHOT to cut the 2.7 release.
881,Lucas,"['gson/src/main/java/com/google/gson/annotations/JsonAdapter.java', 'gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java']","@@ -94,4 +94,7 @@
   /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
   Class<?> value();
 
+  /** false, to be able to handle {@code null} values within the adapter, default value is true. */
+  boolean nullSafe() default true;
+
 }, @@ -73,7 +73,7 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
               + ""JsonSerializer or JsonDeserializer reference."");
     }
 
-    if (typeAdapter != null) {
+    if (typeAdapter != null && annotation.nullSafe()) {
       typeAdapter = typeAdapter.nullSafe();
     }
 , ",see pull request #851 ,made nullSafe wrapper of JsonAdapter optional
900,Jake Wharton,"['gson/src/main/java/com/google/gson/reflect/TypeToken.java', 'gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java']","@@ -302,4 +302,19 @@ private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
   public static <T> TypeToken<T> get(Class<T> type) {
     return new TypeToken<T>(type);
   }
+
+  /**
+   * Gets type literal for the parameterized type represented by applying {@code typeArguments} to
+   * {@code rawType}.
+   */
+  public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {
+    return new TypeToken<Object>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
+  }
+
+  /**
+   * Gets type literal for the array type whose elements are all instances of {@code componentType}.
+   */
+  public static TypeToken<?> getArray(Type componentType) {
+    return new TypeToken<Object>($Gson$Types.arrayOf(componentType));
+  }
 }, @@ -19,6 +19,7 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.RandomAccess;
 import java.util.Set;
 import junit.framework.TestCase;
@@ -79,4 +80,26 @@ public void testIsAssignableFromWithNestedWildcards() throws Exception {
     // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false
     assertFalse(TypeToken.get(b).isAssignableFrom(a));
   }
+
+  public void testArrayFactory() {
+    TypeToken<?> expectedStringArray = new TypeToken<String[]>() {};
+    assertEquals(expectedStringArray, TypeToken.getArray(String.class));
+
+    TypeToken<?> expectedListOfStringArray = new TypeToken<List<String>[]>() {};
+    Type listOfString = new TypeToken<List<String>>() {}.getType();
+    assertEquals(expectedListOfStringArray, TypeToken.getArray(listOfString));
+  }
+
+  public void testParameterizedFactory() {
+    TypeToken<?> expectedListOfString = new TypeToken<List<String>>() {};
+    assertEquals(expectedListOfString, TypeToken.getParameterized(List.class, String.class));
+
+    TypeToken<?> expectedMapOfStringToString = new TypeToken<Map<String, String>>() {};
+    assertEquals(expectedMapOfStringToString, TypeToken.getParameterized(Map.class, String.class, String.class));
+
+    TypeToken<?> expectedListOfListOfListOfString = new TypeToken<List<List<List<String>>>>() {};
+    Type listOfString = TypeToken.getParameterized(List.class, String.class).getType();
+    Type listOfListOfString = TypeToken.getParameterized(List.class, listOfString).getType();
+    assertEquals(expectedListOfListOfListOfString, TypeToken.getParameterized(List.class, listOfListOfString));
+  }
 }, ","These are useful when creating TypeAdapterFactories that delegate to others with more complex types. They also are useful when writing dynamic code that deals with types that cannot be fully reified using the normal subclass technique.

Equivalent methods are exposed on Moshi's `Types` utility.

Some examples of where these are needed:
- Writing a Retrofit `Converter.Factory` which automatically wraps your model object type in an envelope type (like JSON-RPC). For example, `TypeToken.getParameterized(JsonRpcRequest.class, userType)`.
- When doing compile-time code generation of `TypeAdapter` implementations that support generics. To handle `T[]` you need to generate code that combines the statically known type with the runtime generic type. For example, `TypeToken.getArray(runtimeType)`.",Add static factories for array and parameterized type tokens.
922,Inderjeet Singh,"['gson/src/main/java/com/google/gson/annotations/Expose.java', 'gson/src/main/java/com/google/gson/annotations/SerializedName.java', 'gson/src/main/java/com/google/gson/annotations/Since.java', 'gson/src/main/java/com/google/gson/annotations/Until.java']","@@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -57,6 +58,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Expose {, @@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -76,6 +77,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.METHOD})
 public @interface SerializedName {, @@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -50,6 +51,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Since {, @@ -16,6 +16,7 @@
 
 package com.google.gson.annotations;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -54,6 +55,7 @@
  * @author Joel Leitch
  * @since 1.3
  */
+@Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.TYPE})
 public @interface Until {, ",This is useful since it shows the JSON format for a class which the user of that class should typically know.,Added @Documented to Gson annotations.
926,Chaitanya Pramod,['examples/android-proguard-example/proguard.cfg'],"@@ -13,4 +13,10 @@
 # Application classes that will be serialized/deserialized over Gson
 -keep class com.google.gson.examples.android.model.** { *; }
 
+# Prevent proguard from stripping interface information from TypeAdapterFactory,
+# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
+-keep class * implements com.google.gson.TypeAdapterFactory
+-keep class * implements com.google.gson.JsonSerializer
+-keep class * implements com.google.gson.JsonDeserializer
+
 ##---------------End: proguard configuration for Gson  ----------, ","Previously after Proguard, the classes would no longer implement the interfaces, leading to `JsonAdapterAnnotationTypeAdapterFactory` throwing.

Fixes #925",Prevent Proguard from stripping interface info from @JsonAdapter classes
930,Inderjeet Singh,"['extras/pom.xml', 'extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java', 'extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java']","@@ -40,9 +40,14 @@
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.3.1</version>
+      <version>2.7</version>
       <scope>compile</scope>
     </dependency>
+    <dependency>
+      <groupId>javax.annotation</groupId>
+      <artifactId>jsr250-api</artifactId>
+      <version>1.0</version>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -86,16 +91,16 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.2</version>
+        <version>3.5.1</version>
         <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
+          <source>1.6</source>
+          <target>1.6</target>
         </configuration>
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>2.5</version>
+        <version>3.0.2</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -113,7 +118,7 @@
       <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-source-plugin</artifactId>
-         <version>2.4</version>
+         <version>3.0.1</version>
          <executions>
            <execution>
              <id>attach-sources</id>
@@ -127,7 +132,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-javadoc-plugin</artifactId>
-         <version>2.10.1</version>
+         <version>2.10.4</version>
          <executions>
            <execution>
              <id>attach-javadocs</id>
@@ -147,7 +152,7 @@
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-eclipse-plugin</artifactId>
-         <version>2.9</version>
+         <version>2.10</version>
          <configuration>
            <downloadSources>true</downloadSources>
            <downloadJavadocs>true</downloadJavadocs>, @@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+public class PostConstructAdapterFactory implements TypeAdapterFactory {
+    // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
+    @Override
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+        for (Class<?> t = type.getRawType(); t != Object.class; t = t.getSuperclass()) {
+            for (Method m : t.getDeclaredMethods()) {
+                if (m.isAnnotationPresent(PostConstruct.class)) {
+                    m.setAccessible(true);
+                    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+                    return new PostConstructAdapter<T>(delegate, m);
+                }
+            }
+        }
+        return null;
+    }
+
+    final static class PostConstructAdapter<T> extends TypeAdapter<T> {
+        private final TypeAdapter<T> delegate;
+        private final Method method;
+
+        public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
+            this.delegate = delegate;
+            this.method = method;
+        }
+
+        @Override public T read(JsonReader in) throws IOException {
+            T result = delegate.read(in);
+            if (result != null) {
+                try {
+                    method.invoke(result);
+                } catch (IllegalAccessException e) {
+                    throw new AssertionError();
+                } catch (InvocationTargetException e) {
+                    if (e.getCause() instanceof RuntimeException) throw (RuntimeException) e.getCause();
+                    throw new RuntimeException(e.getCause());
+                }
+            }
+            return result;
+        }
+
+        @Override public void write(JsonWriter out, T value) throws IOException {
+            delegate.write(out, value);
+        }
+    }
+}
\ No newline at end of file, @@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.typeadapters;
+
+import javax.annotation.PostConstruct;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import junit.framework.TestCase;
+
+public class PostConstructAdapterFactoryTest extends TestCase {
+    public void test() throws Exception {
+        Gson gson = new GsonBuilder()
+                .registerTypeAdapterFactory(new PostConstructAdapterFactory())
+                .create();
+        gson.fromJson(""{\""bread\"": \""white\"", \""cheese\"": \""cheddar\""}"", Sandwich.class);
+        try {
+            gson.fromJson(""{\""bread\"": \""cheesey bread\"", \""cheese\"": \""swiss\""}"", Sandwich.class);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(""too cheesey"", expected.getMessage());
+        }
+    }
+
+    static class Sandwich {
+        String bread;
+        String cheese;
+
+        @PostConstruct void validate() {
+            if (bread.equals(""cheesey bread"") && cheese != null) {
+                throw new IllegalArgumentException(""too cheesey"");
+            }
+        }
+    }
+}, ",NaN,Added PostConstruct Factory sample in Extras.
931,Heidi Dong,['pom.xml'],"@@ -77,9 +77,6 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-jar-plugin</artifactId>
-          <configuration>
-            <useDefaultManifestFile>true</useDefaultManifestFile>
-          </configuration>
         </plugin>
       </plugins>
     </pluginManagement>, ",Addresses #928 ,Remove deprecated useDefaultManifestFile for jar plugin
942,Mark Hess,"['gson/src/main/java/com/google/gson/JsonObject.java', 'gson/src/test/java/com/google/gson/JsonObjectTest.java']","@@ -132,6 +132,15 @@ private JsonElement createJsonElement(Object value) {
     return members.entrySet();
   }
 
+  /**
+   * Returns a set of members key values.
+   *
+   * @return a set of member keys as Strings
+   */
+  public Set<String> keySet() {
+    return members.keySet();
+  }
+
   /**
    * Returns the number of key/value pairs in the object.
    *, @@ -183,4 +183,19 @@ public void testDeepCopy() {
     assertEquals(1, original.get(""key"").getAsJsonArray().size());
     assertEquals(0, copy.get(""key"").getAsJsonArray().size());
   }
+
+  /**
+   * From issue 941
+   */
+  public void testKeySet() {
+    JsonObject a = new JsonObject();
+
+    a.add(""foo"", new JsonArray());
+    a.add(""bar"", new JsonObject());
+
+    assertEquals(2, a.size());
+    assertEquals(2, a.keySet().size());
+    assertTrue(a.keySet().contains(""foo""));
+    assertTrue(a.keySet().contains(""bar""));
+  }
 }, ","# Overview

Adds keySet method similar to that of Java Map.  Since all Map.entries utilize strings as a key.  Test method also included.",Add keySet method and test
943,Norman Peitek,['README.md'],"@@ -30,6 +30,7 @@ Please use the [google-gson Google group](http://groups.google.com/group/google-
 
 ###*Gson-related Content Created by Third Parties*
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
+  * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
 
 ###*License*
 , ",[Future Studio](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) has published over 20 tutorials on Gson with some more to come soon. Developers interested in Gson would benefit from practical introductions to this amazing library.,README.md Add a 2nd third party tutorial resource
955,Greg,['UserGuide.md'],"@@ -79,7 +79,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.7</version>
+      <version>2.8</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>, ",NaN,Update gson version to 2.8 in Maven example
964,Egor Neliuba,"['gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/test/java/com/google/gson/functional/PrimitiveTest.java']","@@ -368,6 +368,7 @@ public Number read(JsonReader in) throws IOException {
         in.nextNull();
         return null;
       case NUMBER:
+      case STRING:
         return new LazilyParsedNumber(in.nextString());
       default:
         throw new JsonSyntaxException(""Expecting number, got: "" + jsonToken);, @@ -158,6 +158,11 @@ public void testNumberDeserialization() {
     assertEquals(1L, actual.longValue());
   }
 
+  public void testNumberAsStringDeserialization() {
+    Number value = gson.fromJson(""\""18\"""", Number.class);
+    assertEquals(18, value.intValue());
+  }
+
   public void testPrimitiveDoubleAutoboxedSerialization() {
     assertEquals(""-122.08234335"", gson.toJson(-122.08234335));
     assertEquals(""122.08112002"", gson.toJson(new Double(122.08112002)));, ","This works:
```
gson.fromJson(""\""15\"""", int.class)
```

This doesn't:
```
gson.fromJson(""\""15\"""", Number.class)
```

This PR makes it so the second case works too.",Allow deserialization of a Number represented as a String
976,Kevin Most,['gson/src/main/java/com/google/gson/annotations/JsonAdapter.java'],"@@ -16,6 +16,8 @@
 
 package com.google.gson.annotations;
 
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import java.lang.annotation.ElementType;
@@ -77,8 +79,10 @@
  * adapters, which in turn take precedence over annotated types.
  *
  * <p>The class referenced by this annotation must be either a {@link
- * TypeAdapter} or a {@link TypeAdapterFactory}. Using the factory interface
- * makes it possible to delegate to the enclosing {@code Gson} instance.
+ * TypeAdapter} or a {@link TypeAdapterFactory}, or must implement one
+ * or both of {@link JsonDeserializer} or {@link JsonSerializer}. 
+ * Using {@link TypeAdapterFactory} makes it possible to delegate 
+ * to the enclosing {@code Gson} instance.
  *
  * @since 2.3
  *
@@ -91,7 +95,7 @@
 @Target({ElementType.TYPE, ElementType.FIELD})
 public @interface JsonAdapter {
 
-  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}. */
+  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}, or one or both of {@link JsonDeserializer} or {@link JsonSerializer}. */
   Class<?> value();
 
   /** false, to be able to handle {@code null} values within the adapter, default value is true. */, ",Include mention of JsonDeserializer and JsonSerializer as valid JsonAdapter classes.,Update JsonAdapter documentation
982,Yutaro Iino,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -981,7 +981,7 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {
   public String toString() {
     return new StringBuilder(""{serializeNulls:"")
         .append(serializeNulls)
-        .append(""factories:"").append(factories)
+        .append("",factories:"").append(factories)
         .append("",instanceCreators:"").append(constructorConstructor)
         .append(""}"")
         .toString();, ","I noticed `Gson#toString()` prints  a bit unreadable string.
Though I don't know why `toString()` is printing such 3 fields only, this PR fixes missing comma only.",Add missing comma in toString()
994,Martin Lind,['gson/pom.xml'],"@@ -43,6 +43,15 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>, ",This would ensure that the headers created by the bnd maven plugin where included in the jar (as per the documentation found here https://github.com/bndtools/bnd/tree/master/maven/bnd-maven-plugin#important-note).,#957 OSGi headers from the bnd.bnd will be included in the jar
999,twlkyao,['CHANGELOG.md'],"@@ -73,7 +73,7 @@ _2015-10-04_
 
 ## Version 2.3.1
 
-__2014-11-20_
+_2014-11-20_
 
  * Added support to serialize objects with self-referential fields. The self-referential field is set to null in JSON. Previous version of Gson threw a StackOverflowException on encountering any self-referential fields.
    * The most visible impact of this is that Gson can now serialize Throwable (Exception and Error), ",Fixed typo,Fixed typo
1012,João Vitor Verona Biazibetti,['gson/src/main/java/com/google/gson/JsonElement.java'],"@@ -103,7 +103,7 @@ public JsonArray getAsJsonArray() {
     if (isJsonArray()) {
       return (JsonArray) this;
     }
-    throw new IllegalStateException(""This is not a JSON Array."");
+    throw new IllegalStateException(""Not a JSON Array: "" + this);
   }
 
   /**
@@ -119,7 +119,7 @@ public JsonPrimitive getAsJsonPrimitive() {
     if (isJsonPrimitive()) {
       return (JsonPrimitive) this;
     }
-    throw new IllegalStateException(""This is not a JSON Primitive."");
+    throw new IllegalStateException(""Not a JSON Primitive: "" + this);
   }
 
   /**
@@ -136,7 +136,7 @@ public JsonNull getAsJsonNull() {
     if (isJsonNull()) {
       return (JsonNull) this;
     }
-    throw new IllegalStateException(""This is not a JSON Null."");
+    throw new IllegalStateException(""Not a JSON Null: "" + this);
   }
 
   /**, ","As noted in https://github.com/google/gson/issues/1000, this change aims to symmetrize the message of thrown exceptions on methods [getAsJsonObject](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonElement.java#L86), [getAsJsonArray](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonElement.java#L102), [getAsJsonPrimitive](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonElement.java#L118), [getAsJsonNull](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonElement.java#L135), by appending the JSON information ([toString](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonElement.java#L319)) to the messages.",All JsonElement::getAsJsonXXX methods now include the JSON string on thrown exception's message
1014,André Rouél,"['gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java', 'gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java']","@@ -259,9 +259,13 @@ private void expect(JsonToken expected) throws IOException {
       pathNames[stackSize - 2] = ""null"";
     } else {
       popStack();
-      pathNames[stackSize - 1] = ""null"";
+      if (stackSize > 0) {
+        pathNames[stackSize - 1] = ""null"";
+      }
+    }
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
     }
-    pathIndices[stackSize - 1]++;
   }
 
   @Override public String toString() {, @@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.bind;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonObject;
+import com.google.gson.stream.JsonToken;
+import java.io.IOException;
+import junit.framework.TestCase;
+
+@SuppressWarnings(""resource"")
+public class JsonTreeReaderTest extends TestCase {
+  public void testSkipValue_emptyJsonObject() throws IOException {
+    JsonTreeReader in = new JsonTreeReader(new JsonObject());
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+
+  public void testSkipValue_filledJsonObject() throws IOException {
+    JsonObject jsonObject = new JsonObject();
+    JsonArray jsonArray = new JsonArray();
+    jsonArray.add('c');
+    jsonArray.add(""text"");
+    jsonObject.add(""a"", jsonArray);
+    jsonObject.addProperty(""b"", true);
+    jsonObject.addProperty(""i"", 1);
+    jsonObject.add(""n"", JsonNull.INSTANCE);
+    JsonObject jsonObject2 = new JsonObject();
+    jsonObject2.addProperty(""n"", 2L);
+    jsonObject.add(""o"", jsonObject2);
+    jsonObject.addProperty(""s"", ""text"");
+    JsonTreeReader in = new JsonTreeReader(jsonObject);
+    in.skipValue();
+    assertEquals(JsonToken.END_DOCUMENT, in.peek());
+  }
+}, ",…eReader #1013,Fix ArrayIndexOutOfBoundsException when skipping a value with JsonTre…
1015,Mohammad Yasir,['gson/src/main/java/com/google/gson/stream/JsonReader.java'],"@@ -997,7 +997,7 @@ private String nextQuotedValue(char quote) throws IOException {
         if (c == quote) {
           pos = p;
           int len = p - start - 1;
-          if(null == builder) {
+          if (builder == null) {
             return new String(buffer, start, len);
           } else {
             builder.append(buffer, start, len);
@@ -1007,9 +1007,9 @@ private String nextQuotedValue(char quote) throws IOException {
           pos = p;
           int len = p - start - 1;
           char escapeChar = readEscapeCharacter();
-          if(null == builder) {
+          if (builder == null) {
             int estimatedLength = (len + pos - p) * 2;
-            builder = new StringBuilder(estimatedLength < 16 ? 16 : estimatedLength);
+            builder = new StringBuilder(Math.max(estimatedLength, 16));
           }
           builder.append(buffer, start, len);
           builder.append(escapeChar);
@@ -1022,9 +1022,9 @@ private String nextQuotedValue(char quote) throws IOException {
         }
       }
 
-      if(null == builder) {
-        int len = (p - start) * 2;
-        builder = new StringBuilder(len < 16 ? 16 : len);
+      if (builder == null) {
+        int estimatedLength = (p - start) * 2;
+        builder = new StringBuilder(Math.max(estimatedLength, 16));
       }
       builder.append(buffer, start, p - start);
       pos = p;, ","The default constructor of StringReader gives a capacity of 16. It expands and does an array copy in the event of the capacity being exceeded while appending characters.

JsonReader.nextQuotedValue was initializing the default constructor. If the entire string was in buffer and there were no characters to be escaped then we can directly create a string object and return it back (based on the profiling for our sample JSON payload this was the flow this code goes into for 90% of the times).


In the event of it going into other code paths trying to estimate a length to be the double of the current length and ensure it is not less than 16. ",Memory optimisation in JsonReader
1016,Mohammad Yasir,['gson/src/main/java/com/google/gson/stream/JsonReader.java'],"@@ -1006,13 +1006,12 @@ private String nextQuotedValue(char quote) throws IOException {
         } else if (c == '\\') {
           pos = p;
           int len = p - start - 1;
-          char escapeChar = readEscapeCharacter();
           if (builder == null) {
-            int estimatedLength = (len + pos - p) * 2;
+            int estimatedLength = (len + 1) * 2;
             builder = new StringBuilder(Math.max(estimatedLength, 16));
           }
           builder.append(buffer, start, len);
-          builder.append(escapeChar);
+          builder.append(readEscapeCharacter());
           p = pos;
           l = limit;
           start = p;, ","Incorporating the review comments in #1015. 

While readEscapeCharacter might read more than one character from the buffer it will also write 1 to the output. So the right thing to do is len+1",Incorporating the review comments in #1015
1026,Anirudh Ramanan,['gson/src/main/java/com/google/gson/internal/$Gson$Types.java'],"@@ -483,7 +483,9 @@ public Type getOwnerType() {
 
     @Override public String toString() {
       int length = typeArguments.length;
-      if length == 0 return typeToString(rawType);
+      if (length == 0) {
+        return typeToString(rawType);
+      }
 
       StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));
       stringBuilder.append(typeToString(rawType)).append(""<"").append(typeToString(typeArguments[0]));, ","* Calculating length and size beforehand in cases of for loops
* Avoid creation of StringBuilder object if type argument's length is 0 ($Gson$Types.java : 485)
* Removed boilerplate null checks from TypeAdapter, and replaced with nullSafe()",Eliminating Code Overhead
1033,sourabh gupta,['gson/src/main/java/com/google/gson/JsonArray.java'],"@@ -39,14 +39,21 @@
   public JsonArray() {
     elements = new ArrayList<JsonElement>();
   }
+  
+  public JsonArray(int capacity) {
+    elements = new ArrayList<JsonElement>(capacity);
+  }
 
   @Override
   JsonArray deepCopy() {
-    JsonArray result = new JsonArray();
-    for (JsonElement element : elements) {
-      result.add(element.deepCopy());
+    if (!elements.isEmpty()) {
+      JsonArray result = new JsonArray(elements.size());
+      for (JsonElement element : elements) {
+        result.add(element.deepCopy());
+      }
+      return result;
     }
-    return result;
+    return new JsonArray();
   }
 
   /**, ",JsonArray with capacity support in constructor,JsonArray with capacity support in constructor
1037,sourabh gupta,"['gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java']","@@ -150,10 +150,6 @@ static String upperCaseFirstLetter(String name) {
       firstCharacter = name.charAt(++index);
     }
 
-    if (index == length) {
-      return fieldNameBuilder.toString();
-    }
-
     if (!Character.isUpperCase(firstCharacter)) {
       String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);
       return fieldNameBuilder.append(modifiedTarget).toString();, @@ -224,7 +224,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
 
       if (hasComplexKeys) {
         out.beginArray();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           out.beginArray(); // entry array
           Streams.write(keys.get(i), out);
           valueTypeAdapter.write(out, values.get(i));
@@ -233,7 +233,7 @@ public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,
         out.endArray();
       } else {
         out.beginObject();
-        for (int i = 0; i < keys.size(); i++) {
+        for (int i = 0, size = keys.size(); i < size; i++) {
           JsonElement keyElement = keys.get(i);
           out.name(keyToString(keyElement));
           valueTypeAdapter.write(out, values.get(i));, ","Changes are -:
1) Calculating length and size beforehand in cases of for loops.
2) index can never be equal to length in FieldNamingPolicy.
",elimiating code overhead
1038,sourabh gupta,['gson/src/main/java/com/google/gson/GsonBuilder.java'],"@@ -16,13 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Gson$Preconditions;
-import com.google.gson.internal.Excluder;
-import com.google.gson.internal.bind.TreeTypeAdapter;
-import com.google.gson.internal.bind.TypeAdapters;
-import com.google.gson.reflect.TypeToken;
-import com.google.gson.stream.JsonReader;
-
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
 import java.text.DateFormat;
@@ -33,6 +26,13 @@
 import java.util.List;
 import java.util.Map;
 
+import com.google.gson.internal.$Gson$Preconditions;
+import com.google.gson.internal.Excluder;
+import com.google.gson.internal.bind.TreeTypeAdapter;
+import com.google.gson.internal.bind.TypeAdapters;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+
 import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
 import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
 import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;, ","Changes -:
1) Instead of always adding item at 0th position and then shifting the list every time with the new addition, add the item in the last and then reverse the complete list.
2) Correctly allocation of array sizes.",list addition optimization
1041,Egor Neliuba,['README.md'],"@@ -9,30 +9,30 @@ Gson can work with arbitrary Java objects including pre-existing objects that yo
 
 There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
 
-###*Gson Goals*
+### Gson Goals
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-###*Gson Download and Maven*
+### Gson Download and Maven
   * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
   * For Maven check ""Dependency Information"" tab, on the left side.
 
-###*Gson Documentation*
+### Gson Documentation
   * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
   * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
   * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
   * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
 
 Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
 
-###*Gson-related Content Created by Third Parties*
+### Gson-related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
   * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
 
-###*License*
+### License
 
 Gson is released under the [Apache 2.0 license](LICENSE).
 , ",NaN,Fix headers format in the README.md
1042,sourabh gupta,['gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java'],"@@ -37,11 +37,12 @@
 final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
 
   // TODO: migrate to streaming adapter
-
+  
+  private static final String SIMPLE_NAME = ""DefaultDateTypeAdapter"";
+  
   private final DateFormat enUsFormat;
   private final DateFormat localFormat;
-  private final static String SIMPLE_NAME = ""DefaultDateTypeAdapter"";
-
+  
   DefaultDateTypeAdapter() {
     this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
         DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));, ","instead of calling getClass.getSimpleName() that will check too many conditions inside , we can make it as final String and use it directly.",Simplified access of getSimpleName
1045,Matthew Haughton,['UserGuide.md'],"@@ -5,32 +5,32 @@
 3. [Gson Performance and Scalability](#TOC-Gson-Performance-and-Scalability)
 4. [Gson Users](#TOC-Gson-Users)
 5. [Using Gson](#TOC-Using-Gson)
-  * [Using Gson with Maven](#TOC-Gson-With-Maven)
-  * [Primitives Examples](#TOC-Primitives-Examples)
-  * [Object Examples](#TOC-Object-Examples)
-  * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
-  * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
-  * [Array Examples](#TOC-Array-Examples)
-  * [Collections Examples](#TOC-Collections-Examples)
-    * [Collections Limitations](#TOC-Collections-Limitations)
-  * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
-  * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
-  * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
-  * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
-    * [Writing a Serializer](#TOC-Writing-a-Serializer)
-    * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
-  * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
-    * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
-  * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
-  * [Null Object Support](#TOC-Null-Object-Support)
-  * [Versioning Support](#TOC-Versioning-Support)
-  * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
-    * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
-    * [Gson's `@Expose`](#TOC-Gson-s-Expose)
-    * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
-  * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
-  * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
-  * [Streaming](#TOC-Streaming)
+   * [Using Gson with Maven](#TOC-Gson-With-Maven)
+   * [Primitives Examples](#TOC-Primitives-Examples)
+   * [Object Examples](#TOC-Object-Examples)
+   * [Finer Points with Objects](#TOC-Finer-Points-with-Objects)
+   * [Nested Classes (including Inner Classes)](#TOC-Nested-Classes-including-Inner-Classes-)
+   * [Array Examples](#TOC-Array-Examples)
+   * [Collections Examples](#TOC-Collections-Examples)
+     * [Collections Limitations](#TOC-Collections-Limitations)
+   * [Serializing and Deserializing Generic Types](#TOC-Serializing-and-Deserializing-Generic-Types)
+   * [Serializing and Deserializing Collection with Objects of Arbitrary Types](#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types)
+   * [Built-in Serializers and Deserializers](#TOC-Built-in-Serializers-and-Deserializers)
+   * [Custom Serialization and Deserialization](#TOC-Custom-Serialization-and-Deserialization)
+     * [Writing a Serializer](#TOC-Writing-a-Serializer)
+     * [Writing a Deserializer](#TOC-Writing-a-Deserializer)
+   * [Writing an Instance Creator](#TOC-Writing-an-Instance-Creator)
+     * [InstanceCreator for a Parameterized Type](#TOC-InstanceCreator-for-a-Parameterized-Type)
+   * [Compact Vs. Pretty Printing for JSON Output Format](#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format)
+   * [Null Object Support](#TOC-Null-Object-Support)
+   * [Versioning Support](#TOC-Versioning-Support)
+   * [Excluding Fields From Serialization and Deserialization](#TOC-Excluding-Fields-From-Serialization-and-Deserialization)
+     * [Java Modifier Exclusion](#TOC-Java-Modifier-Exclusion)
+     * [Gson's `@Expose`](#TOC-Gson-s-Expose)
+     * [User Defined Exclusion Strategies](#TOC-User-Defined-Exclusion-Strategies)
+   * [JSON Field Naming Support](#TOC-JSON-Field-Naming-Support)
+   * [Sharing State Across Custom Serializers and Deserializers](#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers)
+   * [Streaming](#TOC-Streaming)
 6. [Issues in Designing Gson](#TOC-Issues-in-Designing-Gson)
 7. [Future Enhancements to Gson](#TOC-Future-Enhancements-to-Gson)
 , ",NaN,UserGuide formatting fix
1047,sourabh gupta,['gson/src/main/java/com/google/gson/stream/JsonReader.java'],"@@ -1077,7 +1077,7 @@ private String nextUnquotedValue() throws IOException {
 
       // use a StringBuilder when the value is too long. This is too long to be a number!
       if (builder == null) {
-        builder = new StringBuilder();
+        builder = new StringBuilder(Math.max(i,16));
       }
       builder.append(buffer, pos, i);
       pos += i;
@@ -1086,14 +1086,8 @@ private String nextUnquotedValue() throws IOException {
         break;
       }
     }
-
-    String result;
-    if (builder == null) {
-      result = new String(buffer, pos, i);
-    } else {
-      builder.append(buffer, pos, i);
-      result = builder.toString();
-    }
+   
+    String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
     pos += i;
     return result;
   }
@@ -1438,14 +1432,15 @@ private void skipToEndOfLine() throws IOException {
    * @param toFind a string to search for. Must not contain a newline.
    */
   private boolean skipTo(String toFind) throws IOException {
+    int length = toFind.length();
     outer:
-    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
+    for (; pos + length <= limit || fillBuffer(length); pos++) {
       if (buffer[pos] == '\n') {
         lineNumber++;
         lineStart = pos + 1;
         continue;
       }
-      for (int c = 0; c < toFind.length(); c++) {
+      for (int c = 0; c < length; c++) {
         if (buffer[pos + c] != toFind.charAt(c)) {
           continue outer;
         }, ",Size allocation of StringBuilder,Size allocation of StringBuilder
1052,Timmy Villaluz,['GsonDesignDocument.md'],"@@ -1,4 +1,4 @@
-#Gson Design Document
+# Gson Design Document
 
 This document presents issues that we faced while designing Gson. It is meant for advanced users or developers working on Gson. If you are interested in learning how to use Gson, see its user guide. 
 , ",NaN,Update GsonDesignDocument.md
1064,Mohammad Yasir,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -109,6 +109,7 @@
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
   static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
+  private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = "")]}'\n"";
 
   /**
@@ -395,7 +396,7 @@ static void checkValidFloatingPoint(double value) {
    */
   @SuppressWarnings(""unchecked"")
   public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
-    TypeAdapter<?> cached = typeTokenCache.get(type == null ? TypeToken.get(Object.class) : type);
+    TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
     if (cached != null) {
       return (TypeAdapter<T>) cached;
     }, ","Fixes issue #1063

![image](https://cloud.githubusercontent.com/assets/13655724/24973945/41484432-1fde-11e7-835b-2451c8478a16.png)

This is because of the static initialisation of NULL_KEY_SURROGATE in Gson class.
Given this is quite expensive and this is required only when someone passes in a null for the type parameter (which would be very rare, we should look at lazy initialisation of this variable)",Performance fix to do lazy initialization of null key surrogate
1068,Inderjeet Singh,"['gson/src/main/java/com/google/gson/JsonObject.java', 'gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java', 'gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java']","@@ -136,6 +136,7 @@ private JsonElement createJsonElement(Object value) {
    * Returns a set of members key values.
    *
    * @return a set of member keys as Strings
+   * @since 2.8.1
    */
   public Set<String> keySet() {
     return members.keySet();, @@ -68,9 +68,10 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
           : null;
       typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);
     } else {
-      throw new IllegalArgumentException(
-          ""@JsonAdapter value must be TypeAdapter, TypeAdapterFactory, ""
-              + ""JsonSerializer or JsonDeserializer reference."");
+      throw new IllegalArgumentException(""Invalid attempt to bind an instance of ""
+          + instance.getClass().getName() + "" as a @JsonAdapter for "" + type.toString()
+          + "". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,""
+          + "" JsonSerializer or JsonDeserializer."");
     }
 
     if (typeAdapter != null && annotation.nullSafe()) {, @@ -249,4 +249,15 @@ public NullableClass read(JsonReader in) throws IOException {
       return Foo.valueOf(in.nextString().toUpperCase(Locale.US));
     }
   }
+
+  public void testIncorrectJsonAdapterType() {
+    try {
+      new Gson().toJson(new D());
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+  @JsonAdapter(Integer.class)
+  private static final class D {
+    @SuppressWarnings(""unused"") final String value = ""a"";
+  }
 }, ","…ter.

Now the thrown exception carries this information:
java.lang.IllegalArgumentException: Invalid attempt to bind an instance of java.lang.Integer as a @JsonAdapter for com.google.gson.functional.JsonAdapterAnnotationOnClassesTest$D. @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory, JsonSerializer or JsonDeserializer.",Printing more debugging information to help track an invalid JsonAdap…
1069,Michele Vivoda,"['gson/src/main/java/com/google/gson/stream/JsonReader.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderTest.java']","@@ -728,7 +728,7 @@ private int peekNumber() throws IOException {
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;, @@ -560,6 +560,18 @@ public void testLongLargerThanMinLongThatWrapsAround() throws IOException {
     } catch (NumberFormatException expected) {
     }
   }
+  
+  /**
+   * Issue 1053, negative zero.
+   * @throws Exception
+   */
+  public void testNegativeZero() throws Exception {
+	  	JsonReader reader = new JsonReader(reader(""[-0]""));
+	    reader.setLenient(false);
+	    reader.beginArray();
+	    assertEquals(NUMBER, reader.peek());
+	    assertEquals(""-0"", reader.nextString());
+  }
 
   /**
    * This test fails because there's no double for 9223372036854775808, and our, ",For issue #1053 ,negative zero test and fix
1070,Lyubomyr Shaydariv,"['gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'gson/src/main/java/com/google/gson/GsonBuilder.java', 'gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java']","@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import java.lang.reflect.Type;
+import java.io.IOException;
 import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.text.ParseException;
@@ -26,6 +26,9 @@
 import java.util.Locale;
 
 import com.google.gson.internal.bind.util.ISO8601Utils;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
 
 /**
  * This type adapter supports three subclasses of date: Date, Timestamp, and
@@ -34,78 +37,89 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {
+final class DefaultDateTypeAdapter extends TypeAdapter<Date> {
 
-  // TODO: migrate to streaming adapter
-  
   private static final String SIMPLE_NAME = ""DefaultDateTypeAdapter"";
-  
+
+  private final Class<? extends Date> dateType;
   private final DateFormat enUsFormat;
   private final DateFormat localFormat;
   
-  DefaultDateTypeAdapter() {
-    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
+  DefaultDateTypeAdapter(Class<? extends Date> dateType) {
+    this(dateType,
+        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),
         DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
   }
 
-  DefaultDateTypeAdapter(String datePattern) {
-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {
+    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));
   }
 
-  DefaultDateTypeAdapter(int style) {
-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
+  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {
+    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));
   }
 
   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {
-    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
+    this(Date.class,
+        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
         DateFormat.getDateTimeInstance(dateStyle, timeStyle));
   }
 
-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {
+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {
+    this(dateType,
+        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),
+        DateFormat.getDateTimeInstance(dateStyle, timeStyle));
+  }
+
+  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {
+    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {
+      throw new IllegalArgumentException(""Date type must be one of "" + Date.class + "", "" + Timestamp.class + "", or "" + java.sql.Date.class + "" but was "" + dateType);
+    }
+    this.dateType = dateType;
     this.enUsFormat = enUsFormat;
     this.localFormat = localFormat;
   }
 
   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe
   // See issue 162
   @Override
-  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {
+  public void write(JsonWriter out, Date value) throws IOException {
     synchronized (localFormat) {
-      String dateFormatAsString = enUsFormat.format(src);
-      return new JsonPrimitive(dateFormatAsString);
+      String dateFormatAsString = enUsFormat.format(value);
+      out.value(dateFormatAsString);
     }
   }
 
   @Override
-  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
-      throws JsonParseException {
-    if (!(json instanceof JsonPrimitive)) {
+  public Date read(JsonReader in) throws IOException {
+    if (in.peek() != JsonToken.STRING) {
       throw new JsonParseException(""The date should be a string value"");
     }
-    Date date = deserializeToDate(json);
-    if (typeOfT == Date.class) {
+    Date date = deserializeToDate(in.nextString());
+    if (dateType == Date.class) {
       return date;
-    } else if (typeOfT == Timestamp.class) {
+    } else if (dateType == Timestamp.class) {
       return new Timestamp(date.getTime());
-    } else if (typeOfT == java.sql.Date.class) {
+    } else if (dateType == java.sql.Date.class) {
       return new java.sql.Date(date.getTime());
     } else {
-      throw new IllegalArgumentException(getClass() + "" cannot deserialize to "" + typeOfT);
+      // This must never happen: dateType is guarded in the primary constructor
+      throw new AssertionError();
     }
   }
 
-  private Date deserializeToDate(JsonElement json) {
+  private Date deserializeToDate(String s) {
     synchronized (localFormat) {
       try {
-      	return localFormat.parse(json.getAsString());
+        return localFormat.parse(s);
       } catch (ParseException ignored) {}
       try {
-        return enUsFormat.parse(json.getAsString());
+        return enUsFormat.parse(s);
       } catch (ParseException ignored) {}
       try {
-        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));
+        return ISO8601Utils.parse(s, new ParsePosition(0));
       } catch (ParseException e) {
-        throw new JsonSyntaxException(json.getAsString(), e);
+        throw new JsonSyntaxException(s, e);
       }
     }
   }, @@ -572,19 +572,26 @@ public Gson create() {
         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);
   }
 
+  @SuppressWarnings(""unchecked"")
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
       List<TypeAdapterFactory> factories) {
     DefaultDateTypeAdapter dateTypeAdapter;
+    TypeAdapter<Timestamp> timestampTypeAdapter;
+    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;
     if (datePattern != null && !"""".equals(datePattern.trim())) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);
     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {
-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);
+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);
+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);
+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);
     } else {
       return;
     }
 
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));
-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));
+    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));
+    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));
   }
 }, @@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import java.io.IOException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -44,10 +45,10 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(locale);
     try {
-      assertFormatted(""Jan 1, 1970 12:00:00 AM"", new DefaultDateTypeAdapter());
-      assertFormatted(""1/1/70"", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertFormatted(""Jan 1, 1970"", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertFormatted(""January 1, 1970"", new DefaultDateTypeAdapter(DateFormat.LONG));
+      assertFormatted(""Jan 1, 1970 12:00:00 AM"", new DefaultDateTypeAdapter(Date.class));
+      assertFormatted(""1/1/70"", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertFormatted(""Jan 1, 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertFormatted(""January 1, 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertFormatted(""1/1/70 12:00 AM"",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
       assertFormatted(""Jan 1, 1970 12:00:00 AM"",
@@ -62,16 +63,16 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     }
   }
 
-  public void testParsingDatesFormattedWithSystemLocale() {
+  public void testParsingDatesFormattedWithSystemLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.FRANCE);
     try {
-      assertParsed(""1 janv. 1970 00:00:00"", new DefaultDateTypeAdapter());
-      assertParsed(""01/01/70"", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed(""1 janv. 1970"", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed(""1 janvier 1970"", new DefaultDateTypeAdapter(DateFormat.LONG));
+      assertParsed(""1 janv. 1970 00:00:00"", new DefaultDateTypeAdapter(Date.class));
+      assertParsed(""01/01/70"", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed(""1 janv. 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed(""1 janvier 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed(""01/01/70 00:00"",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
       assertParsed(""1 janv. 1970 00:00:00"",
@@ -86,16 +87,16 @@ public void testParsingDatesFormattedWithSystemLocale() {
     }
   }
 
-  public void testParsingDatesFormattedWithUsLocale() {
+  public void testParsingDatesFormattedWithUsLocale() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertParsed(""Jan 1, 1970 0:00:00 AM"", new DefaultDateTypeAdapter());
-      assertParsed(""1/1/70"", new DefaultDateTypeAdapter(DateFormat.SHORT));
-      assertParsed(""Jan 1, 1970"", new DefaultDateTypeAdapter(DateFormat.MEDIUM));
-      assertParsed(""January 1, 1970"", new DefaultDateTypeAdapter(DateFormat.LONG));
+      assertParsed(""Jan 1, 1970 0:00:00 AM"", new DefaultDateTypeAdapter(Date.class));
+      assertParsed(""1/1/70"", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
+      assertParsed(""Jan 1, 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));
+      assertParsed(""January 1, 1970"", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));
       assertParsed(""1/1/70 0:00 AM"",
           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));
       assertParsed(""Jan 1, 1970 0:00:00 AM"",
@@ -110,22 +111,22 @@ public void testParsingDatesFormattedWithUsLocale() {
     }
   }
 
-  public void testFormatUsesDefaultTimezone() {
+  public void testFormatUsesDefaultTimezone() throws Exception {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone(""America/Los_Angeles""));
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      assertFormatted(""Dec 31, 1969 4:00:00 PM"", new DefaultDateTypeAdapter());
-      assertParsed(""Dec 31, 1969 4:00:00 PM"", new DefaultDateTypeAdapter());
+      assertFormatted(""Dec 31, 1969 4:00:00 PM"", new DefaultDateTypeAdapter(Date.class));
+      assertParsed(""Dec 31, 1969 4:00:00 PM"", new DefaultDateTypeAdapter(Date.class));
     } finally {
       TimeZone.setDefault(defaultTimeZone);
       Locale.setDefault(defaultLocale);
     }
   }
 
   public void testDateDeserializationISO8601() throws Exception {
-  	DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();
+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
     assertParsed(""1970-01-01T00:00:00.000Z"", adapter);
     assertParsed(""1970-01-01T00:00Z"", adapter);
     assertParsed(""1970-01-01T00:00:00+00:00"", adapter);
@@ -135,38 +136,41 @@ public void testDateDeserializationISO8601() throws Exception {
   
   public void testDateSerialization() throws Exception {
     int dateStyle = DateFormat.LONG;
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle);
     DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testDatePattern() throws Exception {
     String pattern = ""yyyy-MM-dd"";
-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);
+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, pattern);
     DateFormat formatter = new SimpleDateFormat(pattern);
     Date currentDate = new Date();
 
-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();
-    assertEquals(formatter.format(currentDate), dateString);
+    String dateString = dateTypeAdapter.toJson(currentDate);
+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
   public void testInvalidDatePattern() throws Exception {
     try {
-      new DefaultDateTypeAdapter(""I am a bad Date pattern...."");
+      new DefaultDateTypeAdapter(Date.class, ""I am a bad Date pattern...."");
       fail(""Invalid date pattern should fail."");
     } catch (IllegalArgumentException expected) { }
   }
 
   private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {
-    assertEquals(formatted, adapter.serialize(new Date(0), Date.class, null).getAsString());
+    assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));
   }
 
-  private void assertParsed(String date, DefaultDateTypeAdapter  adapter) {
-    assertEquals(date, new Date(0), adapter.deserialize(new JsonPrimitive(date), Date.class, null));
-    assertEquals(""ISO 8601"", new Date(0), adapter.deserialize(
-        new JsonPrimitive(""1970-01-01T00:00:00Z""), Date.class, null));
+  private void assertParsed(String date, DefaultDateTypeAdapter adapter) throws IOException {
+    assertEquals(date, new Date(0), adapter.fromJson(toLiteral(date)));
+    assertEquals(""ISO 8601"", new Date(0), adapter.fromJson(toLiteral(""1970-01-01T00:00:00Z"")));
+  }
+
+  private static String toLiteral(String s) {
+    return '""' + s + '""';
   }
 }, ","* Migrated `DefaultDateTypeAdapter` to streaming adapter, removing one item from the in-source TODO list.
* `DefaultDateTypeAdapter` does not introduce its own type parameter like `<T extends Date>` in order to keep compatiblity.
* `DefaultDateTypeAdapter` now requires a `Class<? extends Date>` to be passed to the primary constructor: all package-protected constructors always accept the `dateType` parameter; however, there was one public constructor accepting no `dateType`, so now there are two constructors and another one accepts `dataType` in order not to break public interface.
* `dateType` default value is `java.util.Date.class`.
* `dateType` must be one of: `java.util.Date.class`, `java.sql.Timestamp.class`, or `java.sql.Date.class`. Otherwise a fail-fast `IllegalArgumentException` that is migrated from the former `deserialize` method (`AssertionError` is thrown instead) and now thrown in the new constructor. I hope this is acceptable however I cannot recall fail-fast constructors in Gson (factory methods only).",Migrate DefaultDateTypeAdapter to streaming adapter
1071,James Carman,"['gson/pom.xml', 'pom.xml']","@@ -52,6 +52,10 @@
           </archive>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
+      </plugin>
     </plugins>
   </build>
 </project>, @@ -78,6 +78,12 @@
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-jar-plugin</artifactId>
         </plugin>
+        <plugin>
+          <groupId>org.apache.felix</groupId>
+          <artifactId>maven-bundle-plugin</artifactId>
+          <version>3.2.0</version>
+          <inherited>true</inherited>
+        </plugin>
       </plugins>
     </pluginManagement>
     <plugins>, ","This patch adds OSGi support to GSON, without changing the packaging type to ""bundle"".  It also uses a more recent version of the maven-bundle-plugin, 3.2.0 (3.3.0 is having some issues right now with CDNs or something).",Adding maven-bundle-plugin.
1072,Eric Cochran,"['gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java', 'gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java', 'gson/src/main/java/com/google/gson/stream/JsonReader.java']","@@ -111,7 +111,7 @@ public static UnsafeAllocator create() {
    * throw an {@link java.lang.UnsupportedOperationException}
    * @param c instance of the class to be checked
    */
-  private static void assertInstantiable(Class<?> c) {
+  static void assertInstantiable(Class<?> c) {
     int modifiers = c.getModifiers();
     if (Modifier.isInterface(modifiers)) {
       throw new UnsupportedOperationException(""Interface can't be instantiated! Interface name: "" + c.getName());, @@ -41,7 +41,7 @@
 public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final JsonSerializer<T> serializer;
   private final JsonDeserializer<T> deserializer;
-  private final Gson gson;
+  final Gson gson;
   private final TypeToken<T> typeToken;
   private final TypeAdapterFactory skipPast;
   private final GsonContextImpl context = new GsonContextImpl();, @@ -1459,7 +1459,7 @@ private boolean skipTo(String toFind) throws IOException {
     return getClass().getSimpleName() + locationString();
   }
 
-  private String locationString() {
+  String locationString() {
     int line = lineNumber + 1;
     int column = pos - lineStart + 1;
     return "" at line "" + line + "" column "" + column + "" path "" + getPath();, ",NaN,Remove need for synthetic accessor methods.
1073,Lyubomyr Shaydariv,['gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java'],"@@ -27,8 +27,6 @@
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -43,59 +41,59 @@
   private TypeAdapter<Map<String, Double>> mapAdapter
       = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});
 
-  public void testSerialize() throws IOException {
+  public void testSerialize() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person(""Jesse"", 29), new Person(""Jodie"", 29));
     truck.horsePower = 300;
 
     assertEquals(""{'horsePower':300.0,""
         + ""'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}"",
-        toJson(truckAdapter, truck).replace('\""', '\''));
+        truckAdapter.toJson(truck).replace('\""', '\''));
   }
 
   public void testDeserialize() throws IOException {
     String json = ""{'horsePower':300.0,""
         + ""'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}"";
-    Truck truck = fromJson(truckAdapter, json);
+    Truck truck = truckAdapter.fromJson(json.replace('\'', '\""'));
     assertEquals(300.0, truck.horsePower);
     assertEquals(Arrays.asList(new Person(""Jesse"", 29), new Person(""Jodie"", 29)), truck.passengers);
   }
 
-  public void testSerializeNullField() throws IOException {
+  public void testSerializeNullField() {
     Truck truck = new Truck();
     truck.passengers = null;
     assertEquals(""{'horsePower':0.0,'passengers':null}"",
-        toJson(truckAdapter, truck).replace('\""', '\''));
+        truckAdapter.toJson(truck).replace('\""', '\''));
   }
 
   public void testDeserializeNullField() throws IOException {
-    Truck truck = fromJson(truckAdapter, ""{'horsePower':0.0,'passengers':null}"");
+    Truck truck = truckAdapter.fromJson(""{'horsePower':0.0,'passengers':null}"".replace('\'', '\""'));
     assertNull(truck.passengers);
   }
 
-  public void testSerializeNullObject() throws IOException {
+  public void testSerializeNullObject() {
     Truck truck = new Truck();
     truck.passengers = Arrays.asList((Person) null);
     assertEquals(""{'horsePower':0.0,'passengers':[null]}"",
-        toJson(truckAdapter, truck).replace('\""', '\''));
+        truckAdapter.toJson(truck).replace('\""', '\''));
   }
 
   public void testDeserializeNullObject() throws IOException {
-    Truck truck = fromJson(truckAdapter, ""{'horsePower':0.0,'passengers':[null]}"");
+    Truck truck = truckAdapter.fromJson(""{'horsePower':0.0,'passengers':[null]}"".replace('\'', '\""'));
     assertEquals(Arrays.asList((Person) null), truck.passengers);
   }
 
-  public void testSerializeWithCustomTypeAdapter() throws IOException {
+  public void testSerializeWithCustomTypeAdapter() {
     usePersonNameAdapter();
     Truck truck = new Truck();
     truck.passengers = Arrays.asList(new Person(""Jesse"", 29), new Person(""Jodie"", 29));
     assertEquals(""{'horsePower':0.0,'passengers':['Jesse','Jodie']}"",
-        toJson(truckAdapter, truck).replace('\""', '\''));
+        truckAdapter.toJson(truck).replace('\""', '\''));
   }
 
   public void testDeserializeWithCustomTypeAdapter() throws IOException {
     usePersonNameAdapter();
-    Truck truck = fromJson(truckAdapter, ""{'horsePower':0.0,'passengers':['Jesse','Jodie']}"");
+    Truck truck = truckAdapter.fromJson(""{'horsePower':0.0,'passengers':['Jesse','Jodie']}"".replace('\'', '\""'));
     assertEquals(Arrays.asList(new Person(""Jesse"", -1), new Person(""Jodie"", -1)), truck.passengers);
   }
 
@@ -113,40 +111,40 @@ private void usePersonNameAdapter() {
     truckAdapter = miniGson.getAdapter(Truck.class);
   }
 
-  public void testSerializeMap() throws IOException {
+  public void testSerializeMap() {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put(""a"", 5.0);
     map.put(""b"", 10.0);
-    assertEquals(""{'a':5.0,'b':10.0}"", toJson(mapAdapter, map).replace('""', '\''));
+    assertEquals(""{'a':5.0,'b':10.0}"", mapAdapter.toJson(map).replace('""', '\''));
   }
 
   public void testDeserializeMap() throws IOException {
     Map<String, Double> map = new LinkedHashMap<String, Double>();
     map.put(""a"", 5.0);
     map.put(""b"", 10.0);
-    assertEquals(map, fromJson(mapAdapter, ""{'a':5.0,'b':10.0}""));
+    assertEquals(map, mapAdapter.fromJson(""{'a':5.0,'b':10.0}"".replace('\'', '\""')));
   }
 
-  public void testSerialize1dArray() throws IOException {
+  public void testSerialize1dArray() {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    assertEquals(""[1.0,2.0,3.0]"", toJson(arrayAdapter, new double[]{1.0, 2.0, 3.0}));
+    assertEquals(""[1.0,2.0,3.0]"", arrayAdapter.toJson(new double[]{ 1.0, 2.0, 3.0 }));
   }
 
   public void testDeserialize1dArray() throws IOException {
     TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});
-    double[] array = fromJson(arrayAdapter, ""[1.0,2.0,3.0]"");
+    double[] array = arrayAdapter.fromJson(""[1.0,2.0,3.0]"");
     assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));
   }
 
-  public void testSerialize2dArray() throws IOException {
+  public void testSerialize2dArray() {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
     double[][] array = { {1.0, 2.0 }, { 3.0 } };
-    assertEquals(""[[1.0,2.0],[3.0]]"", toJson(arrayAdapter, array));
+    assertEquals(""[[1.0,2.0],[3.0]]"", arrayAdapter.toJson(array));
   }
 
   public void testDeserialize2dArray() throws IOException {
     TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});
-    double[][] array = fromJson(arrayAdapter, ""[[1.0,2.0],[3.0]]"");
+    double[][] array = arrayAdapter.fromJson(""[[1.0,2.0],[3.0]]"");
     double[][] expected = { {1.0, 2.0 }, { 3.0 } };
     assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));
   }
@@ -186,15 +184,15 @@ public void write(JsonWriter out, Person person) throws IOException {
     assertEquals(""jesse"", truck.passengers.get(1).name);
   }
 
-  public void testSerializeRecursive() throws IOException {
+  public void testSerializeRecursive() {
     TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);
     Node root = new Node(""root"");
     root.left = new Node(""left"");
     root.right = new Node(""right"");
     assertEquals(""{'label':'root',""
         + ""'left':{'label':'left','left':null,'right':null},""
         + ""'right':{'label':'right','left':null,'right':null}}"",
-        toJson(nodeAdapter, root).replace('""', '\''));
+        nodeAdapter.toJson(root).replace('""', '\''));
   }
   
   public void testFromJsonTree() {
@@ -243,19 +241,4 @@ public void testFromJsonTree() {
       this.label = label;
     }
   }
-
-  // TODO: remove this when TypeAdapter.toJson() is public
-  private static <T> String toJson(TypeAdapter<T> typeAdapter, T value) throws IOException {
-    StringWriter stringWriter = new StringWriter();
-    JsonWriter writer = new JsonWriter(stringWriter);
-    typeAdapter.write(writer, value);
-    return stringWriter.toString();
-  }
-
-  // TODO: remove this when TypeAdapter.fromJson() is public
-  private <T> T fromJson(TypeAdapter<T> typeAdapter, String json) throws IOException {
-    JsonReader reader = new JsonReader(new StringReader(json));
-    reader.setLenient(true); // TODO: non-lenient?
-    return typeAdapter.read(reader);
-  }
 }, ",NaN,Remove helper methods mentioned in the TODO list
1075,Andrey Mogilev,['gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java'],"@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2017 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.google.gson.internal.bind;
 
 import com.google.gson.Gson;, ","As described in Issue #1074, $Gson$Types.resolve() shall collapse chains of super/extends type bounds to avoid StackOverflowError on attempts to serialize objects of such types or just obtain the type adapter.

The suggested change fixes StackOverflowError's in a number of issues, including Issue #440 and Issue #603.",Fix StackOverflowError on resolving recursive types by collapsing chains of type bounds
1091,Inderjeet Singh,"['gson/src/main/java/com/google/gson/JsonArray.java', 'gson/src/main/java/com/google/gson/JsonElement.java', 'gson/src/main/java/com/google/gson/JsonNull.java', 'gson/src/main/java/com/google/gson/JsonObject.java', 'gson/src/main/java/com/google/gson/JsonPrimitive.java']","@@ -46,7 +46,7 @@ public JsonArray(int capacity) {
 
   /**
    * Creates a deep copy of this element and all its children
-   * @since 2.8.1
+   * @since 2.8.2
    */
   @Override
   public JsonArray deepCopy() {, @@ -34,7 +34,7 @@
   /**
    * Returns a deep copy of this element. Immutable elements like primitives
    * and nulls are not copied.
-   * @since 2.8.1
+   * @since 2.8.2
    */
   public abstract JsonElement deepCopy();
 , @@ -42,7 +42,7 @@ public JsonNull() {
 
   /**
    * Returns the same instance since it is an immutable value
-   * @since 2.8.1
+   * @since 2.8.2
    */
   @Override
   public JsonNull deepCopy() {, @@ -35,7 +35,7 @@
 
   /**
    * Creates a deep copy of this element and all its children
-   * @since 2.8.1
+   * @since 2.8.2
    */
   @Override
   public JsonObject deepCopy() {, @@ -87,7 +87,7 @@ public JsonPrimitive(Character c) {
 
   /**
    * Returns the same value as primitives are immutable.
-   * @since 2.8.1
+   * @since 2.8.2
    */
   @Override
   public JsonPrimitive deepCopy() {, ",NaN,Made deepCopy public
1093,Mike,['gson/src/main/java/com/google/gson/stream/JsonWriter.java'],"@@ -491,10 +491,10 @@ public JsonWriter value(Boolean value) throws IOException {
    * @return this writer.
    */
   public JsonWriter value(double value) throws IOException {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
+    writeDeferredName();
+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
-    writeDeferredName();
     beforeValue();
     out.append(Double.toString(value));
     return this;, ",Fixes #1090.,"value(double) can write NaN and infinite values when lenient, as value(Number) does"
1100,Lyubomyr Shaydariv,"['gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java']","@@ -84,6 +84,10 @@ public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int
   // See issue 162
   @Override
   public void write(JsonWriter out, Date value) throws IOException {
+    if (value == null) {
+      out.nullValue();
+      return;
+    }
     synchronized (localFormat) {
       String dateFormatAsString = enUsFormat.format(value);
       out.value(dateFormatAsString);, @@ -164,6 +164,7 @@ public void testInvalidDatePattern() throws Exception {
   public void testNullValue() throws Exception {
     DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);
     assertNull(adapter.fromJson(""null""));
+    assertEquals(""null"", adapter.toJson(null));
   }
 
   public void testUnexpectedToken() throws Exception {, ","Regression in:

* b8f616c939c652b8540c95fa2b377b8c628ef3ff - Migrate DefaultDateTypeAdapter to streaming adapter (#1070)

Bug reports:

* #1096 - 2.8.1 can't serialize and deserialize date null (2.8.0 works fine)
* #1098 - Gson 2.8.1 DefaultDateTypeAdapter is not null safe.
* #1095 - serialize date sometimes TreeTypeAdapter, sometimes DefaultDateTypeAdapter?",Fixed DefaultDateTypeAdapter nullability issue and JSON primitives contract
1103,Niv Singer,['extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java'],"@@ -50,8 +50,7 @@ public void testList() {
 
         // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
         String json = gson.toJson(sandwiches);
-        Assert.assertEquals(
-            ""{\""sandwiches\"":[{\""bread\"":\""white\"",\""cheese\"":\""cheddar\""},{\""bread\"":\""whole wheat\"",\""cheese\"":\""swiss\""}]}"", json);
+        Assert.assertEquals(""{\""sandwiches\"":[{\""bread\"":\""white\"",\""cheese\"":\""cheddar\""},{\""bread\"":\""whole wheat\"",\""cheese\"":\""swiss\""}]}"", json);
 
         MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
         Assert.assertEquals(sandwiches, sandwichesFromJson);, ","The RawType's Superclass might be null. This happens, for example, when the type is a collection.",Avoid NPE in PostConstructAdapterFactory
1105,Stefan M.,"['extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java', 'extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java', 'extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java']","@@ -229,7 +229,7 @@ private static Date parse(String date, ParsePosition pos) throws ParseException
     } catch (IllegalArgumentException e) {
       fail = e;
     }
-    String input = (date == null) ? null : ('""' + date + ""'"");
+    String input = (date == null) ? null : (""'"" + date + ""'"");
     throw new ParseException(""Failed to parse date ["" + input + ""]: "" + fail.getMessage(), pos.getIndex());
   }
 , @@ -22,7 +22,6 @@
 import com.google.gson.GsonBuilder;
 
 import junit.framework.TestCase;
-import org.junit.Assert;
 
 import java.util.Arrays;
 import java.util.List;
@@ -50,10 +49,10 @@ public void testList() {
 
         // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
         String json = gson.toJson(sandwiches);
-        Assert.assertEquals(""{\""sandwiches\"":[{\""bread\"":\""white\"",\""cheese\"":\""cheddar\""},{\""bread\"":\""whole wheat\"",\""cheese\"":\""swiss\""}]}"", json);
+        assertEquals(""{\""sandwiches\"":[{\""bread\"":\""white\"",\""cheese\"":\""cheddar\""},{\""bread\"":\""whole wheat\"",\""cheese\"":\""swiss\""}]}"", json);
 
         MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
-        Assert.assertEquals(sandwiches, sandwichesFromJson);
+        assertEquals(sandwiches, sandwichesFromJson);
     }
 
     static class Sandwich {, @@ -22,6 +22,7 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
+import com.google.gson.JsonParseException;
 import junit.framework.TestCase;
 
 import com.google.gson.Gson;
@@ -76,4 +77,13 @@ public void testNullDateSerialization() {
     String json = gson.toJson(null, Date.class);
     assertEquals(""null"", json);
   }
+
+  public void testWellFormedParseException() {
+    try {
+      gson.fromJson(""2017-06-20T14:32:30"", Date.class);
+      fail(""No exception"");
+    } catch (JsonParseException exe) {
+      assertEquals(exe.getMessage(), ""java.text.ParseException: Failed to parse date ['2017-06-20T14']: 2017-06-20T14"");
+    }
+  }
 }, ","The previous exception was styled in the following way:
... [""DATE']...
This commit will fix the different quote marks and replace the "" with '",Fix well formed exception
1119,Ori Schwartz,"['proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java', 'proto/src/main/protobuf/bag.proto', 'proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java']","@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Converter;
 import com.google.common.collect.MapMaker;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonDeserializationContext;
@@ -94,7 +93,8 @@
     private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
     private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
     private EnumSerialization enumSerialization;
-    private Converter<String, String> fieldNameSerializationFormat;
+    private CaseFormat protoFormat;
+    private CaseFormat jsonFormat;
 
     private Builder(EnumSerialization enumSerialization, CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
@@ -126,7 +126,8 @@ public Builder setEnumSerialization(EnumSerialization enumSerialization) {
      */
     public Builder setFieldNameSerializationFormat(CaseFormat fromFieldNameFormat,
         CaseFormat toFieldNameFormat) {
-      fieldNameSerializationFormat = fromFieldNameFormat.converterTo(toFieldNameFormat);
+      this.protoFormat = fromFieldNameFormat;
+      this.jsonFormat = toFieldNameFormat;
       return this;
     }
 
@@ -174,7 +175,7 @@ public Builder addSerializedEnumValueExtension(
     }
 
     public ProtoTypeAdapter build() {
-      return new ProtoTypeAdapter(enumSerialization, fieldNameSerializationFormat,
+      return new ProtoTypeAdapter(enumSerialization, protoFormat, jsonFormat,
           serializedNameExtensions, serializedEnumValueExtensions);
     }
   }
@@ -195,16 +196,19 @@ public static Builder newBuilder() {
       new MapMaker().makeMap();
 
   private final EnumSerialization enumSerialization;
-  private final Converter<String, String> fieldNameSerializationFormat;
+  private final CaseFormat protoFormat;
+  private final CaseFormat jsonFormat;
   private final Set<Extension<FieldOptions, String>> serializedNameExtensions;
   private final Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions;
 
   private ProtoTypeAdapter(EnumSerialization enumSerialization,
-      Converter<String, String> fieldNameSerializationFormat,
+      CaseFormat protoFormat,
+      CaseFormat jsonFormat,
       Set<Extension<FieldOptions, String>> serializedNameExtensions,
       Set<Extension<EnumValueOptions, String>> serializedEnumValueExtensions) {
     this.enumSerialization = enumSerialization;
-    this.fieldNameSerializationFormat = fieldNameSerializationFormat;
+    this.protoFormat = protoFormat;
+    this.jsonFormat = jsonFormat;
     this.serializedNameExtensions = serializedNameExtensions;
     this.serializedEnumValueExtensions = serializedEnumValueExtensions;
   }
@@ -284,8 +288,9 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else if (fieldDescriptor.isRepeated()) {
               // If the type is an array, then we have to grab the type from the class.
+              // protobuf java field names are always lower camel case
               String protoArrayFieldName =
-                  fieldNameSerializationFormat.convert(fieldDescriptor.getName()) + ""_"";
+                  protoFormat.to(CaseFormat.LOWER_CAMEL, fieldDescriptor.getName()) + ""_"";
               Field protoArrayField = protoClass.getDeclaredField(protoArrayFieldName);
               Type protoArrayFieldType = protoArrayField.getGenericType();
               fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
@@ -325,7 +330,7 @@ private String getCustSerializedName(FieldOptions options, String defaultName) {
         return options.getExtension(extension);
       }
     }
-    return fieldNameSerializationFormat.convert(defaultName);
+    return protoFormat.to(jsonFormat, defaultName);
   }
 
   /**, @@ -24,6 +24,11 @@ message SimpleProto {
   optional int32 count = 2;
 }
 
+message ProtoWithDifferentCaseFormat {
+  repeated string name_that_tests_case_format = 1;
+  optional string another_field = 2;
+}
+
 message ProtoWithRepeatedFields {
   repeated int64 numbers = 1;
   repeated SimpleProto simples = 2;, @@ -15,10 +15,13 @@
  */
 package com.google.gson.protobuf.functional;
 
+import com.google.common.base.CaseFormat;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
+import com.google.gson.JsonObject;
 import com.google.gson.protobuf.ProtoTypeAdapter;
 import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
+import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
 import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
 import com.google.protobuf.GeneratedMessage;
@@ -32,6 +35,7 @@
  */
 public class ProtosWithComplexAndRepeatedFieldsTest extends TestCase {
   private Gson gson;
+  private Gson upperCamelGson;
 
   @Override
   protected void setUp() throws Exception {
@@ -43,6 +47,14 @@ protected void setUp() throws Exception {
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
             .create();
+    upperCamelGson =
+        new GsonBuilder()
+            .registerTypeHierarchyAdapter(
+                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+                    .setFieldNameSerializationFormat(
+                        CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
+                    .build())
+            .create();
   }
 
   public void testSerializeRepeatedFields() {
@@ -67,4 +79,23 @@ public void testDeserializeRepeatedFieldsProto() {
     assertEquals(""bar"", proto.getSimples(0).getMsg());
     assertEquals(7, proto.getSimples(1).getCount());
   }
+
+  public void testSerializeDifferentCaseFormat() {
+    final ProtoWithDifferentCaseFormat proto =
+      ProtoWithDifferentCaseFormat.newBuilder()
+        .setAnotherField(""foo"")
+        .addNameThatTestsCaseFormat(""bar"")
+        .build();
+    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
+    assertEquals(""foo"", json.get(""AnotherField"").getAsString());
+    assertEquals(""bar"", json.get(""NameThatTestsCaseFormat"").getAsJsonArray().get(0).getAsString());
+  }
+
+  public void testDeserializeDifferentCaseFormat() {
+    final String json = ""{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}"";
+    ProtoWithDifferentCaseFormat proto =
+      upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
+    assertEquals(""foo"", proto.getAnotherField());
+    assertEquals(""bar"", proto.getNameThatTestsCaseFormat(0));
+  }
 }, ","`fieldNameSerializationFormat` is a converter from protobuf case format -> json case format.

When deserializing json -> protobuf, `ProtoTypeAdapter` uses reflection to determine the Java field name of a repeated protobuf field (to obtain its generic type).

The Java protobuf implementation always uses lower camel case for its field names, but `ProtoTypeAdapter` was using the caller-specified proto->json converter. 

Before this PR, if the JSON case format didn't produce the same name as lower camel, deserialization would fail.

This PR:
* Removes the `Converter` and instead stores both proto and json `CaseFormat`s so the json `CaseFormat` can be referenced.
* Fixes the field name translation used in reflection so it always converts to lower camel.
* Adds deserialization and serialization unit tests on a protobuf with a repeated field name that exposes the error.",ProtoTypeAdapter uses wrong case format to find repeated field's generic type via reflection
1122,Igor Mysak,['gson/src/main/java/com/google/gson/FieldAttributes.java'],"@@ -136,9 +136,13 @@ public boolean hasModifier(int modifier) {
   }
 
   /**
-   * This is exposed internally only for the removing synthetic fields from the JSON output.
+   * Returns the value of the field represented by this {@code Field}, on
+   * the specified object. The value is automatically wrapped in an
+   * object if it has a primitive type.
    *
-   * @return true if the field is synthetic; otherwise false
+   * @return the value of the represented field in object
+   * {@code obj}; primitive values are wrapped in an appropriate
+   * object before being returned
    * @throws IllegalAccessException
    * @throws IllegalArgumentException
    */, ",NaN,fix javaDoc
1128,Andrey Mogilev,['gson/src/main/java/com/google/gson/internal/$Gson$Types.java'],"@@ -25,11 +25,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Properties;
+import java.util.*;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
 import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;, ","Sample failing code:
  private static class TestType<X> {
    TestType<? super X> superType;
  }
  ...
  new Gson().getAdapter(TestType.class);",Fix StackOverflowError on resolving types with TypeVariable recursion
1134,Tom Magnusson,['gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java'],"@@ -224,7 +224,7 @@ public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException((""Unable to invoke no-args constructor for "" + type + "". ""
-              + ""Register an InstanceCreator with Gson for this type may fix this problem.""), e);
+              + ""Registering an InstanceCreator with Gson for this type may fix this problem.""), e);
         }
       }
     };, ",Simple typo fix in `com.google.internal.ConstructorConstructor` exception message.,fix typo in ConstructorConstructor exception
1141,Warren Smith,['gson/src/main/java/com/google/gson/GsonBuilder.java'],"@@ -563,8 +563,7 @@ public Gson create() {
     factories.addAll(this.factories);
     Collections.reverse(factories);
 
-    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>(this.hierarchyFactories.size());
-    hierarchyFactories.addAll(this.hierarchyFactories);
+    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>(this.hierarchyFactories);
     Collections.reverse(hierarchyFactories);
     factories.addAll(hierarchyFactories);
 , ","Calling `GsonBuilder.create()` multiple times results in the builder's underlying hierarchy factory list being reversed.

This change copies hierarchy factories to a new local list when `GsonBuilder.create()` is called so subsequently calls don't result in a change in factory ordering.",Make GsonBuilder.create() factory order idempotent.
1142,Warren Smith,['gson/src/main/java/com/google/gson/GsonBuilder.java'],"@@ -110,7 +110,7 @@ public GsonBuilder() {
    *
    * @param gson the gson instance whose configuration should by applied to a new GsonBuilder.
    */
-  public GsonBuilder(Gson gson) {
+  GsonBuilder(Gson gson) {
     this.excluder = gson.excluder;
     this.fieldNamingPolicy = gson.fieldNamingStrategy;
     this.instanceCreators.putAll(gson.instanceCreators);, ","Addresses #1139 

`Gson.newBuilder()` returns `GsonBuilder`

Few changes here:
- Increases visibility of `Gson` member variables so they can be seen by `GsonBuilder`
- Adds additional member variables to `Gson` to save state required to transform `Gson` back to `GsonBuilder`",Add newBuilder() API
1146,Andrey Mogilev,['gson/src/test/java/com/google/gson/functional/CollectionTest.java'],"@@ -394,9 +394,9 @@ public void testSetDeserialization() {
     }
   }
 
-  private class BigClass { Map<String, ? extends List<SmallClass>> inBig; }
+  private class BigClass { private Map<String, ? extends List<SmallClass>> inBig; }
 
-  private class SmallClass { String inSmall; }
+  private class SmallClass { private String inSmall; }
 
   public void testIssue1107() {
     String json = ""{\n"" +, ","This change fixes of detecting element types by method $Gson$Types.getCollectionElementType() when the generic collection type is declared using wildcards. For example, for the collection type ""? extends List&lt;Something&gt;"" it shall extract ""Something"" as the element type. 

This change fixes issue #1107.",fix issue #1107: resolve element type in wildcard collection types
1151,Nels Beckman,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -765,7 +765,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * @param <T> the type of the desired object
    * @param json the string from which the object is to be deserialized
    * @param classOfT the class of T
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    * classOfT
    */, ","For the string-based fromJson() method, mention that the result will be null if the given string is empty.",Update fromJson Javadoc.
1158,Warren Smith,['examples/android-proguard-example/proguard.cfg'],"@@ -7,7 +7,7 @@
 -keepattributes *Annotation*
 
 # Gson specific classes
--keep class sun.misc.Unsafe { *; }
+-dontwarn sun.misc.**
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson, ",Addresses #1155.,Update proguard rules to not warn on sun.misc package.
1161,Inderjeet Singh,['pom.xml'],"@@ -63,7 +63,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.7.0</version>
           <configuration>
             <source>${java.version}</source>
             <target>${java.version}</target>
@@ -72,7 +72,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.3</version>
+          <version>2.10.4</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
@@ -81,7 +81,7 @@
         <plugin>
           <groupId>org.apache.felix</groupId>
           <artifactId>maven-bundle-plugin</artifactId>
-          <version>3.2.0</version>
+          <version>3.3.0</version>
           <inherited>true</inherited>
         </plugin>
       </plugins>
@@ -90,12 +90,12 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.4.2</version>
+        <version>2.5.3</version>
         <dependencies>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9</version>
+            <version>1.9.5</version>
           </dependency>
         </dependencies>
         <configuration>, ",NaN,Upgraded plugin versions
1169,Elliotte Rusty Harold,['UserGuide.md'],"@@ -144,14 +144,14 @@ BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
 
 #### <a name=""TOC-Finer-Points-with-Objects""></a>**Finer Points with Objects**
 
-* It is perfectly fine (and recommended) to use private fields
+* It is perfectly fine (and recommended) to use private fields.
 * There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
 * If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
-* This implementation handles nulls correctly
-* While serializing, a null field is skipped from the output
-* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to null
-* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization
-* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization
+* This implementation handles nulls correctly.
+* While serializing, a null field is omitted from the output.
+* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
+* If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization.
+* Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.
 
 ### <a name=""TOC-Nested-Classes-including-Inner-Classes-""></a>Nested Classes (including Inner Classes)
 , ","fix ##1166

@inder123 While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.

Also added some missing periods and corrected one word. ",Clarify handling of non-object omitted fields
1175,Michael Edward,['README.md'],"@@ -5,9 +5,9 @@
 [![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
-Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of. 
+Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
 
-There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals. 
+There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.
 
 ### Gson Goals
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
@@ -31,9 +31,9 @@ dependencies {
   * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
   * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
   * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
-  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion
+  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
 
-Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions. 
+Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions.
 
 ### Gson-related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`, ",NaN,Fix README.md grammatical error
1179,,['pom.xml'],"@@ -65,6 +65,7 @@
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.7.0</version>
           <configuration>
+            <excludes>**/module-info.java</excludes>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>, ","I've added a module-info.java file. Right now it's disabled by default-- I'm no maven wizard, so I didn't want to mess with the pom more than absolutely necessary. To try compiling the GSON as a jigsaw module, delete `<excludes>**/module-info.java</excludes>` and set java.version to 1.9, then run mvn compile.",Java 9 module
1183,,['gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java'],"@@ -266,7 +266,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
         } catch (IllegalArgumentException e) {
             fail = e;
         }
-        String input = (date == null) ? null : ('""' + date + ""'"");
+        String input = (date == null) ? null : ('""' + date + '""');
         String msg = fail.getMessage();
         if (msg == null || msg.isEmpty()) {
             msg = ""(""+fail.getClass().getName()+"")"";, ",The quotes were mismatched,Fix a small typo
1184,Inderjeet Singh,['.travis.yml'],"@@ -1,7 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk7
+  - openjdk7
   - oraclejdk8
 
 install: mvn -f gson install -DskipTests=true, ",NaN,Replaced oracle JDK 7 with openJDK 7 to fix broken build.
1191,Ori Schwartz,['proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java'],"@@ -34,8 +34,8 @@
 import com.google.protobuf.Descriptors.EnumDescriptor;
 import com.google.protobuf.Descriptors.EnumValueDescriptor;
 import com.google.protobuf.Descriptors.FieldDescriptor;
+import com.google.protobuf.DynamicMessage;
 import com.google.protobuf.Extension;
-import com.google.protobuf.GeneratedMessage;
 import com.google.protobuf.Message;
 
 import java.lang.reflect.Field;
@@ -72,7 +72,7 @@
  * @author Stanley Wang
  */
 public class ProtoTypeAdapter
-    implements JsonSerializer<GeneratedMessage>, JsonDeserializer<GeneratedMessage> {
+    implements JsonSerializer<Message>, JsonDeserializer<Message> {
   /**
    * Determines how enum <u>values</u> should be serialized.
    */
@@ -214,7 +214,7 @@ private ProtoTypeAdapter(EnumSerialization enumSerialization,
   }
 
   @Override
-  public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
+  public JsonElement serialize(Message src, Type typeOfSrc,
       JsonSerializationContext context) {
     JsonObject ret = new JsonObject();
     final Map<FieldDescriptor, Object> fields = src.getAllFields();
@@ -247,17 +247,21 @@ public JsonElement serialize(GeneratedMessage src, Type typeOfSrc,
   }
 
   @Override
-  public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
+  public Message deserialize(JsonElement json, Type typeOfT,
       JsonDeserializationContext context) throws JsonParseException {
     try {
       JsonObject jsonObject = json.getAsJsonObject();
       @SuppressWarnings(""unchecked"")
-      Class<? extends GeneratedMessage> protoClass = (Class<? extends GeneratedMessage>) typeOfT;
+      Class<? extends Message> protoClass = (Class<? extends Message>) typeOfT;
+
+      if (DynamicMessage.class.isAssignableFrom(protoClass)) {
+        throw new IllegalStateException(""only generated messages are supported"");
+      }
 
       try {
         // Invoke the ProtoClass.newBuilder() method
-        GeneratedMessage.Builder<?> protoBuilder =
-            (GeneratedMessage.Builder<?>) getCachedMethod(protoClass, ""newBuilder"").invoke(null);
+        Message.Builder protoBuilder =
+            (Message.Builder) getCachedMethod(protoClass, ""newBuilder"").invoke(null);
 
         Descriptor protoDescriptor =
             (Descriptor) getCachedMethod(protoClass, ""getDescriptor"").invoke(null);
@@ -303,7 +307,7 @@ public GeneratedMessage deserialize(JsonElement json, Type typeOfT,
             }
           }
         }
-        return (GeneratedMessage) protoBuilder.build();
+        return (Message) protoBuilder.build();
       } catch (SecurityException e) {
         throw new JsonParseException(e);
       } catch (NoSuchMethodException e) {, ","This change allows `ProtoTypeAdapter` to work with both protobuf 2.x and 3.x.

The pom currently requires [version 2.6.1](https://github.com/google/gson/blob/855f0493d0edba5d6f6ec4c72a46bfef225ef22c/proto/pom.xml#L65). But because this artifact is not published on Maven central, most users will [copy it into their project](https://github.com/google/gson/issues/690#issuecomment-133768886).

`Message` is a common superclass of both `GeneratedMessage` and `GeneratedMessageV3` so after this change `ProtoTypeAdapter` can be used with either.

### Changes
* Use `com.google.protobuf.Message` instead of v2-specific `com.google.protobuf.GeneratedMessage`.
* Throw an exception if adapter is ever called on a subclass of `com.google.protobuf.DynamicMessage`, which was probably the original intent of using `GeneratedMessage`.",Use Message instead of GeneratedMessage which is specific to protobuf v2
1199,Anirudh Ramanan,"['gson/src/main/java/com/google/gson/GsonBuilder.java', 'gson/src/main/java/com/google/gson/internal/Excluder.java']","@@ -286,17 +286,6 @@ public GsonBuilder disableInnerClassSerialization() {
     return this;
   }
 
-  /**
-   * Configures Gson to include anonymous and local classes during serialization.
-   *
-   * @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
-   * @since 2.8.2
-   */
-  public GsonBuilder enableAnonymousAndLocalClassSerialization() {
-    excluder = excluder.enableAnonymousAndLocalClassSerialization();
-    return this;
-  }
-
   /**
    * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}
    * objects., @@ -54,7 +54,6 @@
   private double version = IGNORE_VERSIONS;
   private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;
   private boolean serializeInnerClasses = true;
-  private boolean serializeAnonymousAndLocalClasses = false;
   private boolean requireExpose;
   private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();
   private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();
@@ -88,12 +87,6 @@ public Excluder disableInnerClassSerialization() {
     return result;
   }
 
-  public com.google.gson.internal.Excluder enableAnonymousAndLocalClassSerialization() {
-    com.google.gson.internal.Excluder result = clone();
-    result.serializeAnonymousAndLocalClasses = true;
-    return result;
-  }
-
   public Excluder excludeFieldsWithoutExposeAnnotation() {
     Excluder result = clone();
     result.requireExpose = true;
@@ -180,7 +173,7 @@ public boolean excludeField(Field field, boolean serialize) {
       return true;
     }
 
-    if (!serializeAnonymousAndLocalClasses && isAnonymousOrLocal(field.getType())) {
+    if (isAnonymousOrLocal(field.getType())) {
       return true;
     }
 
@@ -206,7 +199,7 @@ private boolean excludeClassChecks(Class<?> clazz) {
           return true;
       }
 
-      if (!serializeAnonymousAndLocalClasses && isAnonymousOrLocal(clazz)) {
+      if (isAnonymousOrLocal(clazz)) {
           return true;
       }
 , ","excludeClass used to get called twice, which internally used to check if class is a innerClass, or an anonymous or local class. Attaching the CPU Profiler snapshot.

<img width=""646"" alt=""screen shot 2017-11-30 at 2 51 22 pm"" src=""https://user-images.githubusercontent.com/16556984/33430061-2b37aa3e-d5f5-11e7-85fb-54882606579e.png"">

With this change, we only check once and return if the class has to be excluded.",Optimised the create() call for Excluder TypeAdapterFactory
1205,Lucas Bleme,['README.md'],"@@ -18,15 +18,15 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
 
 ### Gson Download and Maven
   * To use Gson in Android
-```
+```gradle
 dependencies {
     compile 'com.google.code.gson:gson:2.8.2'
 }
 ```
 
   * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
   * To use Gson with Maven
-  ```
+  ```xml
 <dependency>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson</artifactId>, ","Adding maven dependency to readme file.
Fixes issue #1204.

:white_check_mark:  I have signed the CLA agreement.",Including Maven snippet on README.md
1211,Andrey Mogilev,['gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java'],"@@ -56,7 +56,8 @@
    * The first of them (default US format) is used for serialization as well.
    */
   private final List<DateFormat> dateFormats = new ArrayList<DateFormat>();
-  {
+
+  public DateTypeAdapter() {
     dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US));
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));, ","Adopts Gson for Java9 DateFormat changes, as described in issue #1210 ",fix Java9 DateFormat changes
1215,Ori Schwartz,['proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java'],"@@ -263,6 +263,9 @@ public Message deserialize(JsonElement json, Type typeOfT,
         Message.Builder protoBuilder =
             (Message.Builder) getCachedMethod(protoClass, ""newBuilder"").invoke(null);
 
+        Message defaultInstance =
+            (Message) getCachedMethod(protoClass, ""getDefaultInstance"").invoke(null);
+
         Descriptor protoDescriptor =
             (Descriptor) getCachedMethod(protoClass, ""getDescriptor"").invoke(null);
         // Call setters on all of the available fields
@@ -300,8 +303,7 @@ public Message deserialize(JsonElement json, Type typeOfT,
               fieldValue = context.deserialize(jsonElement, protoArrayFieldType);
               protoBuilder.setField(fieldDescriptor, fieldValue);
             } else {
-              Message prototype = protoBuilder.build();
-              Object field = prototype.getField(fieldDescriptor);
+              Object field = defaultInstance.getField(fieldDescriptor);
               fieldValue = context.deserialize(jsonElement, field.getClass());
               protoBuilder.setField(fieldDescriptor, fieldValue);
             }, ","Before this PR, a protobuf message was being built and then discarded for every field.

Using the instance returned via `getDefaultInstance()` avoids creating unused objects. ",Avoid repeated calls to build() during deserialization by obtaining field types from the Message's defaultInstance
1218,Andrey Mogilev,['gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java'],"@@ -33,7 +33,7 @@
 public abstract class ReflectionAccessor {
 
   // the singleton instance, use getInstance() to obtain
-  private static final ReflectionAccessor instance = createReflectionAccessor();
+  private static final ReflectionAccessor instance = VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
 
   /**
    * Does the same as {@code ao.setAccessible(true)}, but never throws
@@ -51,8 +51,4 @@
   public static ReflectionAccessor getInstance() {
     return instance;
   }
-
-  private static ReflectionAccessor createReflectionAccessor() {
-    return VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
-  }
 }, ","Fixes ""illegal reflective access"" warnings and exceptions, like one in #1216 ",Java 9 support: use Unsafe-based reflection in Java 9+
1278,,"['gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java']","@@ -114,6 +114,29 @@
     @Override public String translateName(Field f) {
       return separateCamelCase(f.getName(), ""-"").toLowerCase(Locale.ENGLISH);
     }
+  },
+
+  /**
+   * Using this naming policy with Gson will modify the Java Field name from its camel cased
+   * form to a lower case field name where each word is separated by a dot (.).
+   *
+   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <ul>
+   *   <li>someFieldName ---> some.field.name</li>
+   *   <li>_someFieldName ---> _some.field.name</li>
+   *   <li>aStringField ---> a.string.field</li>
+   *   <li>aURL ---> a.u.r.l</li>
+   * </ul>
+   * Using dots in JavaScript is not recommended since dot is also used for a member sign in
+   * expressions. This requires that a field named with dots is always accessed as a quoted
+   * property like {@code myobject['my.field']}. Accessing it as an object field
+   * {@code myobject.my.field} will result in an unintended javascript expression.
+   * @since 2.8
+   */
+  LOWER_CASE_WITH_DOTS() {
+    @Override public String translateName(Field f) {
+      return separateCamelCase(f.getName(), ""."").toLowerCase(Locale.ENGLISH);
+    }
   };
 
   /**, @@ -63,6 +63,14 @@ public void testGsonWithLowerCaseDashPolicySerialization() {
         + target.someConstantStringInstanceField + ""\""}"", gson.toJson(target));
   }
 
+  public void testGsonWithLowerCaseDotPolicySerialization() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    StringWrapper target = new StringWrapper(""blah"");
+    assertEquals(""{\""some.constant.string.instance.field\"":\""""
+          + target.someConstantStringInstanceField + ""\""}"", gson.toJson(target));
+  }
+
+
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
     String target = ""{\""some-constant-string-instance-field\"":\""someValue\""}"";, ","Dot separated property naming is one of the most common field naming policies, used in many products like Spark, hadoop, log4j etc, e.g., `spark.executors.memory`, which is mapped to `sparkExecutorsMemory` as class field name.
This is very similar to LOWER_CASE_WITH_DASHES, the only difference is using `.` instead of `-`.",Add FieldNamingPolicy.LOWER_CASE_WITH_DOTS
1281,Yaakov,"['.gitignore', 'CHANGELOG.md', 'README.md', 'ReleaseProcess.md', 'UserGuide.md', 'build.gradle', 'examples/android-proguard-example/AndroidManifest.xml', 'gradle/wrapper/gradle-wrapper.jar', 'gradle/wrapper/gradle-wrapper.properties', 'gradlew', 'gradlew.bat', 'gson/build.gradle', 'gson/pom.xml', 'gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/main/java/com/google/gson/JsonNull.java', 'gson/src/main/java/com/google/gson/JsonParser.java', 'gson/src/main/java/com/google/gson/internal/JavaVersion.java', 'gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java', 'gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java', 'gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java', 'gson/src/main/java/com/google/gson/util/VersionUtils.java', 'gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java', 'gson/src/test/java/com/google/gson/GsonBuilderTest.java', 'gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java', 'gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java', 'gson/src/test/java/com/google/gson/functional/MapTest.java', 'gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java', 'gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java', 'gson/src/test/java/com/google/gson/functional/ObjectTest.java', 'gson/src/test/java/com/google/gson/internal/JavaVersionTest.java', 'gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java', 'pom.xml', 'settings.gradle']","@@ -13,4 +13,8 @@ release.properties
 *.iws
 classes
 
+.gradle
+local.properties
+build
+
 .DS_Store, @@ -1,6 +1,17 @@
 Change Log
 ==========
 
+## Version 2.8.4
+_2018-05-01_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.3...gson-parent-2.8.4)
+ * Added a new FieldNamingPolicy, `LOWER_CASE_WITH_DOTS` that mapps JSON name `someFieldName` to `some.field.name`
+ * Fixed issue https://github.com/google/gson/issues/1305 by removing compile/runtime dependency on `sun.misc.Unsafe`
+
+## Version 2.8.3
+_2018-04-27_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.2...gson-parent-2.8.3)
+ * Added a new API, `GsonBuilder.newBuilder()` that clones the current builder
+ * Preserving DateFormatter behavior on JDK 9
+ * Numerous other bugfixes
+
 ## Version 2.8.2
 _2017-09-19_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.1...gson-parent-2.8.2)
  * Introduced a new API, `JsonElement.deepCopy()`, @@ -20,7 +20,7 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
   * To use Gson in Android
 ```gradle
 dependencies {
-    implementation 'com.google.code.gson:gson:2.8.2'
+    implementation 'com.google.code.gson:gson:2.8.4'
 }
 ```
 
@@ -30,7 +30,7 @@ dependencies {
 <dependency>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson</artifactId>
-    <version>2.8.2</version>
+    <version>2.8.4</version>
 </dependency>
 ```
 , @@ -1,51 +1,19 @@
-#Gson Release Process
+# Gson Release Process
 
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
 1. (obsolete step) Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
 1. Ensure all changelists are code-reviewed and have +1
-1. (obsolete step) Ensure that your `~/.m2/settings.xml` is configured properly (see steps below)
 1. `cd gson` to the parent directory; ensure there are no open files and all changes are committed.
 1. Run `mvn release:clean`
 1. Do a dry run: `mvn release:prepare -DdryRun=true`
 1. Start the release: `mvn release:prepare`
-  * Answer questions: usually the defaults are fine.
-  * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
-1. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
-
-   ```bash
-   mvn -s /home/<username>/.m2/settings.xml release:perform
-   ```
-
-1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
-
-  ```bash
-  cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
-  cd /tmp/1.7.2
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2-javadoc.jar \
-      -Dclassifier=javadoc
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2-sources.jar \
-      -Dclassifier=sources
-
-  mvn gpg:sign-and-deploy-file \
-      -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
-      -DrepositoryId=sonatype-nexus-staging \
-      -DpomFile=gson-1.7.2.pom \
-      -Dfile=gson-1.7.2.jar
-  ```
-
-1. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
+   * Answer questions: usually the defaults are fine.
+   * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
+1. Complete the release: `mvn release:perform`
+1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson.
+1. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
 1. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
 
 1. Update the version in the [Using Gson with Maven2 page](https://github.com/google/gson/blob/master/UserGuide.md#TOC-Gson-With-Maven)
@@ -58,16 +26,16 @@ The following is a step-by-step procedure for releasing a new version of Google-
 This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
 
 1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
-2. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
-3. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
-4. Now for deploying a snapshot repository, use `mvn deploy`.
+1. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+1. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
+1. Now for deploying a snapshot repository, use `mvn deploy`.
 
 ## Getting Maven Publishing Privileges
 
 Based on [Gson group thread](https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion):
 
 1. [Sign up for a Sonatype account](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide) following instructions under (2) on that page
-2. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
+1. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
 
 ## Running Benchmarks or Tests on Android
 , @@ -74,7 +74,7 @@ The Gson instance does not maintain any state while invoking Json operations. So
 ## <a name=""TOC-Gson-With-Gradle""></a>Using Gson with Gradle/Android
 ```
 dependencies {
-    compile 'com.google.code.gson:gson:2.8.2'
+    compile 'com.google.code.gson:gson:2.8.4'
 }
 ```
 ## <a name=""TOC-Gson-With-Maven""></a>Using Gson with Maven
@@ -86,7 +86,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.8.2</version>
+      <version>2.8.4</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>, @@ -0,0 +1,12 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
+    }
+}
+, None, None, @@ -0,0 +1,6 @@
+#Fri Apr 27 17:41:01 PDT 2018
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip, @@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG=""$0""
+# Need this for relative symlinks.
+while [ -h ""$PRG"" ] ; do
+    ls=`ls -ld ""$PRG""`
+    link=`expr ""$ls"" : '.*-> \(.*\)$'`
+    if expr ""$link"" : '/.*' > /dev/null; then
+        PRG=""$link""
+    else
+        PRG=`dirname ""$PRG""`""/$link""
+    fi
+done
+SAVED=""`pwd`""
+cd ""`dirname \""$PRG\""`/"" >/dev/null
+APP_HOME=""`pwd -P`""
+cd ""$SAVED"" >/dev/null
+
+APP_NAME=""Gradle""
+APP_BASE_NAME=`basename ""$0""`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=""maximum""
+
+warn () {
+    echo ""$*""
+}
+
+die () {
+    echo
+    echo ""$*""
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case ""`uname`"" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n ""$JAVA_HOME"" ] ; then
+    if [ -x ""$JAVA_HOME/jre/sh/java"" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=""$JAVA_HOME/jre/sh/java""
+    else
+        JAVACMD=""$JAVA_HOME/bin/java""
+    fi
+    if [ ! -x ""$JAVACMD"" ] ; then
+        die ""ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation.""
+    fi
+else
+    JAVACMD=""java""
+    which java >/dev/null 2>&1 || die ""ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation.""
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ ""$cygwin"" = ""false"" -a ""$darwin"" = ""false"" -a ""$nonstop"" = ""false"" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ ""$MAX_FD"" = ""maximum"" -o ""$MAX_FD"" = ""max"" ] ; then
+            MAX_FD=""$MAX_FD_LIMIT""
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn ""Could not set maximum file descriptor limit: $MAX_FD""
+        fi
+    else
+        warn ""Could not query maximum file descriptor limit: $MAX_FD_LIMIT""
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS=""$GRADLE_OPTS \""-Xdock:name=$APP_NAME\"" \""-Xdock:icon=$APP_HOME/media/gradle.icns\""""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed ""$APP_HOME""`
+    CLASSPATH=`cygpath --path --mixed ""$CLASSPATH""`
+    JAVACMD=`cygpath --unix ""$JAVACMD""`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS=""$ROOTDIRS$SEP$dir""
+        SEP=""|""
+    done
+    OURCYGPATTERN=""(^($ROOTDIRS))""
+    # Add a user-defined pattern to the cygpath arguments
+    if [ ""$GRADLE_CYGPATTERN"" != """" ] ; then
+        OURCYGPATTERN=""$OURCYGPATTERN|($GRADLE_CYGPATTERN)""
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in ""$@"" ; do
+        CHECK=`echo ""$arg""|egrep -c ""$OURCYGPATTERN"" -`
+        CHECK2=`echo ""$arg""|egrep -c ""^-""`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed ""$arg""`
+        else
+            eval `echo args$i`=""\""$arg\""""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- ""$args0"" ;;
+        (2) set -- ""$args0"" ""$args1"" ;;
+        (3) set -- ""$args0"" ""$args1"" ""$args2"" ;;
+        (4) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ;;
+        (5) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ;;
+        (6) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ;;
+        (7) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ;;
+        (8) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ""$args7"" ;;
+        (9) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ""$args7"" ""$args8"" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n ""$i"" | sed ""s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/"" ; done
+    echo "" ""
+}
+APP_ARGS=$(save ""$@"")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS ""\""-Dorg.gradle.appname=$APP_BASE_NAME\"""" -classpath ""\""$CLASSPATH\"""" org.gradle.wrapper.GradleWrapperMain ""$APP_ARGS""
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ ""$(uname)"" = ""Darwin"" ] && [ ""$HOME"" = ""$PWD"" ]; then
+  cd ""$(dirname ""$0"")""
+fi
+
+exec ""$JAVACMD"" ""$@"", @@ -0,0 +1,84 @@
+@if ""%DEBUG%"" == """" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if ""%OS%""==""Windows_NT"" setlocal
+
+set DIRNAME=%~dp0
+if ""%DIRNAME%"" == """" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if ""%ERRORLEVEL%"" == ""0"" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:""=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist ""%JAVA_EXE%"" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not ""%OS%"" == ""Windows_NT"" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if ""x%~1"" == ""x"" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+""%JAVA_EXE%"" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% ""-Dorg.gradle.appname=%APP_BASE_NAME%"" -classpath ""%CLASSPATH%"" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if ""%ERRORLEVEL%""==""0"" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not """" == ""%GRADLE_EXIT_CONSOLE%"" exit 1
+exit /b 1
+
+:mainEnd
+if ""%OS%""==""Windows_NT"" endlocal
+
+:omega, @@ -0,0 +1,13 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+
+group = 'com.google.code.gson'
+version = '2.8.4-SNAPSHOT'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+sourceSets.main.java.exclude(""**/module-info.java"")
+dependencies {
+    testCompile ""junit:junit:4.12""
+}, @@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.8.3-SNAPSHOT</version>
+    <version>2.8.5-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>, @@ -27,12 +27,12 @@
 import java.util.List;
 import java.util.Locale;
 
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.google.gson.util.VersionUtils;
 
 /**
  * This type adapter supports three subclasses of date: Date, Timestamp, and
@@ -59,7 +59,7 @@
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
   }
@@ -78,7 +78,7 @@
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateInstance(style));
     }
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
     }
   }
@@ -93,7 +93,7 @@ public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
     }
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
     }
   }, @@ -114,6 +114,29 @@
     @Override public String translateName(Field f) {
       return separateCamelCase(f.getName(), ""-"").toLowerCase(Locale.ENGLISH);
     }
+  },
+
+  /**
+   * Using this naming policy with Gson will modify the Java Field name from its camel cased
+   * form to a lower case field name where each word is separated by a dot (.).
+   *
+   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <ul>
+   *   <li>someFieldName ---> some.field.name</li>
+   *   <li>_someFieldName ---> _some.field.name</li>
+   *   <li>aStringField ---> a.string.field</li>
+   *   <li>aURL ---> a.u.r.l</li>
+   * </ul>
+   * Using dots in JavaScript is not recommended since dot is also used for a member sign in
+   * expressions. This requires that a field named with dots is always accessed as a quoted
+   * property like {@code myobject['my.field']}. Accessing it as an object field
+   * {@code myobject.my.field} will result in an unintended javascript expression.
+   * @since 2.8
+   */
+  LOWER_CASE_WITH_DOTS() {
+    @Override public String translateName(Field f) {
+      return separateCamelCase(f.getName(), ""."").toLowerCase(Locale.ENGLISH);
+    }
   };
 
   /**, None, None, @@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal;
+
+/**
+ * Utility to check the major Java version of the current JVM.
+ */
+public final class JavaVersion {
+  // Oracle defines naming conventions at http://www.oracle.com/technetwork/java/javase/versioning-naming-139433.html
+  // However, many alternate implementations differ. For example, Debian used 9-debian as the version string
+
+  private static final int majorJavaVersion = determineMajorJavaVersion();
+
+  private static int determineMajorJavaVersion() {
+    String javaVersion = System.getProperty(""java.version"");
+    return getMajorJavaVersion(javaVersion);
+  }
+
+  // Visible for testing only
+  static int getMajorJavaVersion(String javaVersion) {
+    int version = parseDotted(javaVersion);
+    if (version == -1) {
+      version = extractBeginningInt(javaVersion);
+    }
+    if (version == -1) {
+      return 6;  // Choose minimum supported JDK version as default
+    }
+    return version;
+  }
+
+  // Parses both legacy 1.8 style and newer 9.0.4 style 
+  private static int parseDotted(String javaVersion) {
+    try {
+      String[] parts = javaVersion.split(""[._]"");
+      int firstVer = Integer.parseInt(parts[0]);
+      if (firstVer == 1 && parts.length > 1) {
+        return Integer.parseInt(parts[1]);
+      } else {
+        return firstVer;
+      }
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  private static int extractBeginningInt(String javaVersion) {
+    try {
+      StringBuilder num = new StringBuilder();
+      for (int i = 0; i < javaVersion.length(); ++i) {
+        char c = javaVersion.charAt(i);
+        if (Character.isDigit(c)) {
+          num.append(c);
+        } else {
+          break;
+        }
+      }
+      return Integer.parseInt(num.toString());
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
+   */
+  public static int getMajorJavaVersion() {
+    return majorJavaVersion;
+  }
+
+  /**
+   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
+   */
+  public static boolean isJava9OrLater() {
+    return majorJavaVersion >= 9;
+  }
+}, @@ -20,13 +20,13 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.google.gson.util.VersionUtils;
 
 import java.io.IOException;
 import java.text.DateFormat;
@@ -62,7 +62,7 @@ public DateTypeAdapter() {
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
   }, @@ -25,12 +25,9 @@
  */
 final class PreJava9ReflectionAccessor extends ReflectionAccessor {
 
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
   @Override
   public void makeAccessible(AccessibleObject ao) {
     ao.setAccessible(true);
   }
-
 }, @@ -15,10 +15,10 @@
  */
 package com.google.gson.internal.reflect;
 
-import com.google.gson.util.VersionUtils;
-
 import java.lang.reflect.AccessibleObject;
 
+import com.google.gson.internal.JavaVersion;
+
 /**
  * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
  * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
@@ -33,7 +33,7 @@
 public abstract class ReflectionAccessor {
 
   // the singleton instance, use getInstance() to obtain
-  private static final ReflectionAccessor instance = VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
+  private static final ReflectionAccessor instance = JavaVersion.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
 
   /**
    * Does the same as {@code ao.setAccessible(true)}, but never throws, @@ -15,40 +15,63 @@
  */
 package com.google.gson.internal.reflect;
 
-import sun.misc.Unsafe;
-
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import com.google.gson.JsonIOException;
 
 /**
  * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
  * <p>
  * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
  * use {@link PreJava9ReflectionAccessor} for them.
  */
+@SuppressWarnings({""unchecked"", ""rawtypes""})
 final class UnsafeReflectionAccessor extends ReflectionAccessor {
 
-  private final Unsafe theUnsafe = getUnsafeInstance();
+  private static Class unsafeClass;
+  private final Object theUnsafe = getUnsafeInstance();
   private final Field overrideField = getOverrideField();
 
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
   @Override
   public void makeAccessible(AccessibleObject ao) {
+    boolean success = makeAccessibleWithUnsafe(ao);
+    if (!success) {
+      try {
+        // unsafe couldn't be found, so try using accessible anyway
+        ao.setAccessible(true);
+      } catch (SecurityException e) {
+        throw new JsonIOException(""Gson couldn't modify fields for "" + ao
+          + ""\nand sun.misc.Unsafe not found.\nEither write a custom type adapter,""
+          + "" or make fields accessible, or include sun.misc.Unsafe."", e);
+      }
+    }
+  }
+
+  // Visible for testing only
+  boolean makeAccessibleWithUnsafe(AccessibleObject ao) {
     if (theUnsafe != null && overrideField != null) {
-      long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
-      theUnsafe.putBoolean(ao, overrideOffset, true);
+      try {
+        Method method = unsafeClass.getMethod(""objectFieldOffset"", Field.class);
+        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
+        Method putBooleanMethod = unsafeClass.getMethod(""putBoolean"",  Object.class, long.class, boolean.class);
+        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);
+        return true;
+      } catch (Exception ignored) { // do nothing
+      }
     }
+    return false;
   }
 
-  private static Unsafe getUnsafeInstance() {
+  private static Object getUnsafeInstance() {
     try {
-      Field unsafeField = Unsafe.class.getDeclaredField(""theUnsafe"");
+      unsafeClass = Class.forName(""sun.misc.Unsafe"");
+      Field unsafeField = unsafeClass.getDeclaredField(""theUnsafe"");
       unsafeField.setAccessible(true);
-      return (Unsafe) unsafeField.get(null);
+      return unsafeField.get(null);
     } catch (Exception e) {
-      e.printStackTrace();
       return null;
     }
   }
@@ -57,7 +80,6 @@ private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField(""override"");
     } catch (NoSuchFieldException e) {
-      e.printStackTrace();
       return null;
     }
   }, @@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2017 The Gson authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.util;
-
-/**
- * Utility to check the major Java version of the current JVM.
- */
-public class VersionUtils {
-
-  private static final int majorJavaVersion = determineMajorJavaVersion();
-
-  private static int determineMajorJavaVersion() {
-    String[] parts = System.getProperty(""java.version"").split(""[._]"");
-    int firstVer = Integer.parseInt(parts[0]);
-    if (firstVer == 1 && parts.length > 1) {
-      return Integer.parseInt(parts[1]);
-    } else {
-      return firstVer;
-    }
-  }
-
-  /**
-   * @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc.
-   */
-  public static int getMajorJavaVersion() {
-    return majorJavaVersion;
-  }
-
-  /**
-   * @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise.
-   */
-  public static boolean isJava9OrLater() {
-    return majorJavaVersion >= 9;
-  }
-}, @@ -23,7 +23,8 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
-import com.google.gson.util.VersionUtils;
+import com.google.gson.internal.JavaVersion;
+
 import junit.framework.TestCase;
 
 /**
@@ -47,9 +48,9 @@ private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(locale);
     try {
-      String afterYearSep = VersionUtils.isJava9OrLater() ? "", "" : "" "";
-      String afterYearLongSep = VersionUtils.isJava9OrLater() ? "" at "" : "" "";
-      String utcFull = VersionUtils.isJava9OrLater() ? ""Coordinated Universal Time"" : ""UTC"";
+      String afterYearSep = JavaVersion.isJava9OrLater() ? "", "" : "" "";
+      String afterYearLongSep = JavaVersion.isJava9OrLater() ? "" at "" : "" "";
+      String utcFull = JavaVersion.isJava9OrLater() ? ""Coordinated Universal Time"" : ""UTC"";
       assertFormatted(String.format(""Jan 1, 1970%s12:00:00 AM"", afterYearSep),
               new DefaultDateTypeAdapter(Date.class));
       assertFormatted(""1/1/70"", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
@@ -75,7 +76,7 @@ public void testParsingDatesFormattedWithSystemLocale() throws Exception {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.FRANCE);
     try {
-      String afterYearSep = VersionUtils.isJava9OrLater() ? "" à "" : "" "";
+      String afterYearSep = JavaVersion.isJava9OrLater() ? "" à "" : "" "";
       assertParsed(String.format(""1 janv. 1970%s00:00:00"", afterYearSep),
               new DefaultDateTypeAdapter(Date.class));
       assertParsed(""01/01/70"", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));
@@ -87,7 +88,7 @@ public void testParsingDatesFormattedWithSystemLocale() throws Exception {
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
       assertParsed(String.format(""1 janvier 1970%s00:00:00 UTC"", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed(VersionUtils.isJava9OrLater() ?
+      assertParsed(JavaVersion.isJava9OrLater() ?
                       ""jeudi 1 janvier 1970 à 00:00:00 Coordinated Universal Time"" :
                       ""jeudi 1 janvier 1970 00 h 00 UTC"",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
@@ -127,7 +128,7 @@ public void testFormatUsesDefaultTimezone() throws Exception {
     Locale defaultLocale = Locale.getDefault();
     Locale.setDefault(Locale.US);
     try {
-      String afterYearSep = VersionUtils.isJava9OrLater() ? "", "" : "" "";
+      String afterYearSep = JavaVersion.isJava9OrLater() ? "", "" : "" "";
       assertFormatted(String.format(""Dec 31, 1969%s4:00:00 PM"", afterYearSep),
               new DefaultDateTypeAdapter(Date.class));
       assertParsed(""Dec 31, 1969 4:00:00 PM"", new DefaultDateTypeAdapter(Date.class));, None, None, @@ -27,6 +27,7 @@
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -56,7 +57,6 @@
 import java.util.TreeSet;
 import java.util.UUID;
 
-import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -330,7 +330,7 @@ public void testBitSetDeserialization() throws Exception {
   public void testDefaultDateSerialization() {
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       assertEquals(""\""Sep 11, 2011, 10:55:03 PM\"""", json);
     } else {
       assertEquals(""\""Sep 11, 2011 10:55:03 PM\"""", json);
@@ -375,7 +375,7 @@ public void testDefaultJavaSqlDateDeserialization() {
   public void testDefaultJavaSqlTimestampSerialization() {
     Timestamp now = new java.sql.Timestamp(1259875082000L);
     String json = gson.toJson(now);
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       assertEquals(""\""Dec 3, 2009, 1:18:02 PM\"""", json);
     } else {
       assertEquals(""\""Dec 3, 2009 1:18:02 PM\"""", json);
@@ -405,7 +405,7 @@ public void testDefaultDateSerializationUsingBuilder() throws Exception {
     Gson gson = new GsonBuilder().create();
     Date now = new Date(1315806903103L);
     String json = gson.toJson(now);
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       assertEquals(""\""Sep 11, 2011, 10:55:03 PM\"""", json);
     } else {
       assertEquals(""\""Sep 11, 2011 10:55:03 PM\"""", json);, None, @@ -63,6 +63,20 @@ public void testGsonWithLowerCaseDashPolicySerialization() {
         + target.someConstantStringInstanceField + ""\""}"", gson.toJson(target));
   }
 
+  public void testGsonWithLowerCaseDotPolicySerialization() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    StringWrapper target = new StringWrapper(""blah"");
+    assertEquals(""{\""some.constant.string.instance.field\"":\""""
+          + target.someConstantStringInstanceField + ""\""}"", gson.toJson(target));
+  }
+
+  public void testGsonWithLowerCaseDotPolicyDeserialiation() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    String target = ""{\""some.constant.string.instance.field\"":\""someValue\""}"";
+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
+    assertEquals(""someValue"", deserializedObject.someConstantStringInstanceField);
+  }
+
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();
     String target = ""{\""some-constant-string-instance-field\"":\""someValue\""}"";, None, @@ -33,6 +33,7 @@
 import com.google.gson.common.TestTypes.ClassWithTransientFields;
 import com.google.gson.common.TestTypes.Nested;
 import com.google.gson.common.TestTypes.PrimitiveArray;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -44,7 +45,6 @@
 import java.util.Map;
 import java.util.TimeZone;
 
-import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -484,7 +484,7 @@ public void testSingletonLists() {
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
     a.map.put(""date"", new Date(0));
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       assertEquals(""{\""map\"":{\""date\"":\""Dec 31, 1969, 4:00:00 PM\""}}"", gson.toJson(a));
     } else {
       assertEquals(""{\""map\"":{\""date\"":\""Dec 31, 1969 4:00:00 PM\""}}"", gson.toJson(a));, @@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import com.google.gson.internal.JavaVersion;
+
+/**
+ * Unit and functional tests for {@link JavaVersion}
+ *
+ * @author Inderjeet Singh
+ */
+public class JavaVersionTest {
+  // Borrowed some of test strings from https://github.com/prestodb/presto/blob/master/presto-main/src/test/java/com/facebook/presto/server/TestJavaVersion.java
+
+  @Test
+  public void testGetMajorJavaVersion() {
+    JavaVersion.getMajorJavaVersion();
+  }
+
+  @Test
+  public void testJava6() {
+    assertEquals(6, JavaVersion.getMajorJavaVersion(""1.6.0"")); // http://www.oracle.com/technetwork/java/javase/version-6-141920.html
+  }
+
+  @Test
+  public void testJava7() {
+    assertEquals(7, JavaVersion.getMajorJavaVersion(""1.7.0"")); // http://www.oracle.com/technetwork/java/javase/jdk7-naming-418744.html
+  }
+
+  @Test
+  public void testJava8() {
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8""));
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0""));
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0_131""));
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0_60-ea""));
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0_111-internal""));
+
+    // openjdk8 per https://github.com/AdoptOpenJDK/openjdk-build/issues/93
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0-internal""));
+    assertEquals(8, JavaVersion.getMajorJavaVersion(""1.8.0_131-adoptopenjdk""));
+  }
+
+  @Test
+  public void testJava9() {
+    // Legacy style
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9.0.4"")); // Oracle JDK 9
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9-Debian"")); // Debian as reported in https://github.com/google/gson/issues/1310
+    // New style
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9-ea+19""));
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9+100""));
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9.0.1+20""));
+    assertEquals(9, JavaVersion.getMajorJavaVersion(""9.1.1+20""));
+  }
+
+  @Test
+  public void testJava10() {
+    assertEquals(10, JavaVersion.getMajorJavaVersion(""10.0.1"")); // Oracle JDK 10.0.1
+  }
+
+  @Test
+  public void testUnknownVersionFormat() {
+    assertEquals(6, JavaVersion.getMajorJavaVersion(""Java9"")); // unknown format
+  }
+}, @@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Field;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link UnsafeReflectionAccessor}
+ *
+ * @author Inderjeet Singh
+ */
+public class UnsafeReflectionAccessorTest {
+
+  @Test
+  public void testMakeAccessibleWithUnsafe() throws Exception {
+    UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+    Field field = ClassWithPrivateFinalFields.class.getDeclaredField(""a"");
+    try {
+      boolean success = accessor.makeAccessibleWithUnsafe(field);
+      assertTrue(success);
+    } catch (Exception e) {
+      fail(""Unsafe didn't work on the JDK"");
+    }
+  }
+
+  @SuppressWarnings(""unused"")
+  private static final class ClassWithPrivateFinalFields {
+    private final String a;
+    public ClassWithPrivateFinalFields(String a) {
+      this.a = a;
+    }
+  }
+}, @@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.8.3-SNAPSHOT</version>
+  <version>2.8.5-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>
@@ -65,7 +65,9 @@
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.7.0</version>
           <configuration>
-            <excludes>**/module-info.java</excludes>
+            <excludes>
+              <exclude>**/module-info.java</exclude>
+            </excludes>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>, @@ -0,0 +1 @@
+include ':gson', ","As of io 17, google reccomends using implementation when adding gradle dependencies instead of compile as compile is now depreciated.

I updated the readme to use implementation instead of compile.

See https://youtu.be/7ll-rkLCtyk?t=22m20s for more details.",updated README to use implementation instead of compile
1284,JoonHo Park,['ReleaseProcess.md'],"@@ -1,4 +1,4 @@
-#Gson Release Process
+# Gson Release Process
 
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
@@ -10,8 +10,8 @@ The following is a step-by-step procedure for releasing a new version of Google-
 1. Run `mvn release:clean`
 1. Do a dry run: `mvn release:prepare -DdryRun=true`
 1. Start the release: `mvn release:prepare`
-  * Answer questions: usually the defaults are fine.
-  * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
+   * Answer questions: usually the defaults are fine.
+   * This will do a full build, change version from `-SNAPSHOT` to the released version, commit and create the tags. It will then change the version to `-SNAPSHOT` for the next release.
 1. Ensure you have defined `sonatype-nexus-staging` in your Maven `settings.xml` and run:
 
    ```bash
@@ -20,30 +20,30 @@ The following is a step-by-step procedure for releasing a new version of Google-
 
 1. [Log in to Nexus repository manager](https://oss.sonatype.org/index.html#welcome) at Sonatype and close the staging repository for Gson. If you run into an error regarding missing signatures, you need to manually upload the artifacts using `mvn gpg:sign-and-deploy-file` for Gson binary, source and Javadoc jars.
 
-  ```bash
-  cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
-  cd /tmp/1.7.2
+   ```bash
+   cp -r ~/.m2/repository/com/google/code/gson/gson/1.7.2 /tmp
+   cd /tmp/1.7.2
 
-  mvn gpg:sign-and-deploy-file \
+   mvn gpg:sign-and-deploy-file \
       -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
       -DrepositoryId=sonatype-nexus-staging \
       -DpomFile=gson-1.7.2.pom \
       -Dfile=gson-1.7.2-javadoc.jar \
       -Dclassifier=javadoc
 
-  mvn gpg:sign-and-deploy-file \
+   mvn gpg:sign-and-deploy-file \
       -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
       -DrepositoryId=sonatype-nexus-staging \
       -DpomFile=gson-1.7.2.pom \
       -Dfile=gson-1.7.2-sources.jar \
       -Dclassifier=sources
 
-  mvn gpg:sign-and-deploy-file \
+   mvn gpg:sign-and-deploy-file \
       -Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/ \
       -DrepositoryId=sonatype-nexus-staging \
       -DpomFile=gson-1.7.2.pom \
       -Dfile=gson-1.7.2.jar
-  ```
+   ```
 
 1. Close the Gson repository. Download and sanity check all downloads. Do not skip this step! Once you release the staging repository, there is no going back. It will get synced with Maven central and you will not be able to update or delete anything. Your only recourse will be to release a new version of Gson and hope that no one uses the old one.
 1. Release the staging repository for Gson. Gson will now get synced to Maven central with-in the next hour. For issues consult [Sonatype Guide](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt).
@@ -58,16 +58,16 @@ The following is a step-by-step procedure for releasing a new version of Google-
 This section was borrowed heavily from [Doclava release process](http://code.google.com/p/doclava/wiki/ProcessRelease).
 
 1. Install/Configure GPG following this [guide](http://www.sonatype.com/people/2010/01/how-to-generate-pgp-signatures-with-maven/).
-2. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
-3. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
-4. Now for deploying a snapshot repository, use `mvn deploy`.
+1. [Create encrypted passwords](http://maven.apache.org/guides/mini/guide-encryption.html).
+1. Create `~/.m2/settings.xml` similar to as described in [Doclava release process](https://code.google.com/p/doclava/wiki/ProcessRelease).
+1. Now for deploying a snapshot repository, use `mvn deploy`.
 
 ## Getting Maven Publishing Privileges
 
 Based on [Gson group thread](https://groups.google.com/d/topic/google-gson/DHWJHVFpIBg/discussion):
 
 1. [Sign up for a Sonatype account](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide) following instructions under (2) on that page
-2. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
+1. Ask one of the existing members of the repository to create a JIRA ticket (Step 3 of above document) to add you to the publisher list.
 
 ## Running Benchmarks or Tests on Android
 , ","### Changes

- Space in `h1` header
- Indent code block & nested bullets properly with 3 spaces
- Unify numbered list indicator to `1.`

Since markdown automatically converts `1.` to `<li>` under `<ol>`, bullet numbers are automatically assigned in increment manner. Therefore there is no need to use other than `1.` for numbered list. So, I converted `2.` `3.` ... to `1.` for consistency.
Moreover, using only `1.` makes document easy to change: no number arrangement is required when adding / removing items in the ordered list",Format ReleaseProcess.md using GFM
1300,Lyubomyr Shaydariv,"['examples/android-proguard-example/AndroidManifest.xml', 'gson/src/main/java/com/google/gson/JsonNull.java', 'gson/src/main/java/com/google/gson/JsonParser.java', 'gson/src/test/java/com/google/gson/GsonBuilderTest.java', 'gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java', 'gson/src/test/java/com/google/gson/functional/MapTest.java', 'gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java']","None, None, None, None, None, None, None, ","Removed the `x` flag from the text files:

```shell
git ls-files \
    | xargs -I {} find {} -executable \
    | xargs chmod -x
```",Removed the executable flag from clearly text files
1301,Inderjeet Singh,['pom.xml'],"@@ -65,7 +65,9 @@
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.7.0</version>
           <configuration>
-            <excludes>**/module-info.java</excludes>
+            <excludes>
+              <exclude>**/module-info.java</exclude>
+            </excludes>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>, ",NaN,Fixed excludes section in maven-compiler-plugin
1302,Inderjeet Singh,"['.gitignore', 'build.gradle', 'gradle/wrapper/gradle-wrapper.jar', 'gradle/wrapper/gradle-wrapper.properties', 'gradlew', 'gradlew.bat', 'gson/build.gradle', 'settings.gradle']","@@ -13,4 +13,8 @@ release.properties
 *.iws
 classes
 
+.gradle
+local.properties
+build
+
 .DS_Store, @@ -0,0 +1,12 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
+    }
+}
+, None, @@ -0,0 +1,6 @@
+#Fri Apr 27 17:41:01 PDT 2018
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip, @@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG=""$0""
+# Need this for relative symlinks.
+while [ -h ""$PRG"" ] ; do
+    ls=`ls -ld ""$PRG""`
+    link=`expr ""$ls"" : '.*-> \(.*\)$'`
+    if expr ""$link"" : '/.*' > /dev/null; then
+        PRG=""$link""
+    else
+        PRG=`dirname ""$PRG""`""/$link""
+    fi
+done
+SAVED=""`pwd`""
+cd ""`dirname \""$PRG\""`/"" >/dev/null
+APP_HOME=""`pwd -P`""
+cd ""$SAVED"" >/dev/null
+
+APP_NAME=""Gradle""
+APP_BASE_NAME=`basename ""$0""`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=""maximum""
+
+warn () {
+    echo ""$*""
+}
+
+die () {
+    echo
+    echo ""$*""
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case ""`uname`"" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n ""$JAVA_HOME"" ] ; then
+    if [ -x ""$JAVA_HOME/jre/sh/java"" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=""$JAVA_HOME/jre/sh/java""
+    else
+        JAVACMD=""$JAVA_HOME/bin/java""
+    fi
+    if [ ! -x ""$JAVACMD"" ] ; then
+        die ""ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation.""
+    fi
+else
+    JAVACMD=""java""
+    which java >/dev/null 2>&1 || die ""ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation.""
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ ""$cygwin"" = ""false"" -a ""$darwin"" = ""false"" -a ""$nonstop"" = ""false"" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ ""$MAX_FD"" = ""maximum"" -o ""$MAX_FD"" = ""max"" ] ; then
+            MAX_FD=""$MAX_FD_LIMIT""
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn ""Could not set maximum file descriptor limit: $MAX_FD""
+        fi
+    else
+        warn ""Could not query maximum file descriptor limit: $MAX_FD_LIMIT""
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS=""$GRADLE_OPTS \""-Xdock:name=$APP_NAME\"" \""-Xdock:icon=$APP_HOME/media/gradle.icns\""""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed ""$APP_HOME""`
+    CLASSPATH=`cygpath --path --mixed ""$CLASSPATH""`
+    JAVACMD=`cygpath --unix ""$JAVACMD""`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS=""$ROOTDIRS$SEP$dir""
+        SEP=""|""
+    done
+    OURCYGPATTERN=""(^($ROOTDIRS))""
+    # Add a user-defined pattern to the cygpath arguments
+    if [ ""$GRADLE_CYGPATTERN"" != """" ] ; then
+        OURCYGPATTERN=""$OURCYGPATTERN|($GRADLE_CYGPATTERN)""
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in ""$@"" ; do
+        CHECK=`echo ""$arg""|egrep -c ""$OURCYGPATTERN"" -`
+        CHECK2=`echo ""$arg""|egrep -c ""^-""`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed ""$arg""`
+        else
+            eval `echo args$i`=""\""$arg\""""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- ""$args0"" ;;
+        (2) set -- ""$args0"" ""$args1"" ;;
+        (3) set -- ""$args0"" ""$args1"" ""$args2"" ;;
+        (4) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ;;
+        (5) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ;;
+        (6) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ;;
+        (7) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ;;
+        (8) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ""$args7"" ;;
+        (9) set -- ""$args0"" ""$args1"" ""$args2"" ""$args3"" ""$args4"" ""$args5"" ""$args6"" ""$args7"" ""$args8"" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n ""$i"" | sed ""s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/"" ; done
+    echo "" ""
+}
+APP_ARGS=$(save ""$@"")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS ""\""-Dorg.gradle.appname=$APP_BASE_NAME\"""" -classpath ""\""$CLASSPATH\"""" org.gradle.wrapper.GradleWrapperMain ""$APP_ARGS""
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ ""$(uname)"" = ""Darwin"" ] && [ ""$HOME"" = ""$PWD"" ]; then
+  cd ""$(dirname ""$0"")""
+fi
+
+exec ""$JAVACMD"" ""$@"", @@ -0,0 +1,84 @@
+@if ""%DEBUG%"" == """" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if ""%OS%""==""Windows_NT"" setlocal
+
+set DIRNAME=%~dp0
+if ""%DIRNAME%"" == """" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if ""%ERRORLEVEL%"" == ""0"" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:""=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist ""%JAVA_EXE%"" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not ""%OS%"" == ""Windows_NT"" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if ""x%~1"" == ""x"" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+""%JAVA_EXE%"" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% ""-Dorg.gradle.appname=%APP_BASE_NAME%"" -classpath ""%CLASSPATH%"" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if ""%ERRORLEVEL%""==""0"" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not """" == ""%GRADLE_EXIT_CONSOLE%"" exit 1
+exit /b 1
+
+:mainEnd
+if ""%OS%""==""Windows_NT"" endlocal
+
+:omega, @@ -0,0 +1,13 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+
+group = 'com.google.code.gson'
+version = '2.8.4-SNAPSHOT'
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+sourceSets.main.java.exclude(""**/module-info.java"")
+dependencies {
+    testCompile ""junit:junit:4.12""
+}, @@ -0,0 +1 @@
+include ':gson', ",NaN,Added gradle/Idea support
1303,Inderjeet Singh,['gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java'],"@@ -70,6 +70,12 @@ public void testGsonWithLowerCaseDotPolicySerialization() {
           + target.someConstantStringInstanceField + ""\""}"", gson.toJson(target));
   }
 
+  public void testGsonWithLowerCaseDotPolicyDeserialiation() {
+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DOTS).create();
+    String target = ""{\""some.constant.string.instance.field\"":\""someValue\""}"";
+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);
+    assertEquals(""someValue"", deserializedObject.someConstantStringInstanceField);
+  }
 
   public void testGsonWithLowerCaseDashPolicyDeserialiation() {
     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();, ",… policy,Added a test for deserialization of fields using lowercase-dot naming…
1306,Inderjeet Singh,"['gson/src/main/java/com/google/gson/internal/reflect/PreJava9ReflectionAccessor.java', 'gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java', 'gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java']","@@ -25,12 +25,9 @@
  */
 final class PreJava9ReflectionAccessor extends ReflectionAccessor {
 
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
   @Override
   public void makeAccessible(AccessibleObject ao) {
     ao.setAccessible(true);
   }
-
 }, @@ -15,40 +15,63 @@
  */
 package com.google.gson.internal.reflect;
 
-import sun.misc.Unsafe;
-
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import com.google.gson.JsonIOException;
 
 /**
  * An implementation of {@link ReflectionAccessor} based on {@link Unsafe}.
  * <p>
  * NOTE: This implementation is designed for Java 9. Although it should work with earlier Java releases, it is better to
  * use {@link PreJava9ReflectionAccessor} for them.
  */
+@SuppressWarnings({""unchecked"", ""rawtypes""})
 final class UnsafeReflectionAccessor extends ReflectionAccessor {
 
-  private final Unsafe theUnsafe = getUnsafeInstance();
+  private static Class unsafeClass;
+  private final Object theUnsafe = getUnsafeInstance();
   private final Field overrideField = getOverrideField();
 
-  /**
-   * {@inheritDoc}
-   */
+  /** {@inheritDoc} */
   @Override
   public void makeAccessible(AccessibleObject ao) {
+    boolean success = makeAccessibleWithUnsafe(ao);
+    if (!success) {
+      try {
+        // unsafe couldn't be found, so try using accessible anyway
+        ao.setAccessible(true);
+      } catch (SecurityException e) {
+        throw new JsonIOException(""Gson couldn't modify fields for "" + ao
+          + ""\nand sun.misc.Unsafe not found.\nEither write a custom type adapter,""
+          + "" or make fields accessible, or include sun.misc.Unsafe."", e);
+      }
+    }
+  }
+
+  // Visible for testing only
+  boolean makeAccessibleWithUnsafe(AccessibleObject ao) {
     if (theUnsafe != null && overrideField != null) {
-      long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
-      theUnsafe.putBoolean(ao, overrideOffset, true);
+      try {
+        Method method = unsafeClass.getMethod(""objectFieldOffset"", Field.class);
+        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);
+        Method putBooleanMethod = unsafeClass.getMethod(""putBoolean"",  Object.class, long.class, boolean.class);
+        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);
+        return true;
+      } catch (Exception ignored) { // do nothing
+      }
     }
+    return false;
   }
 
-  private static Unsafe getUnsafeInstance() {
+  private static Object getUnsafeInstance() {
     try {
-      Field unsafeField = Unsafe.class.getDeclaredField(""theUnsafe"");
+      unsafeClass = Class.forName(""sun.misc.Unsafe"");
+      Field unsafeField = unsafeClass.getDeclaredField(""theUnsafe"");
       unsafeField.setAccessible(true);
-      return (Unsafe) unsafeField.get(null);
+      return unsafeField.get(null);
     } catch (Exception e) {
-      e.printStackTrace();
       return null;
     }
   }
@@ -57,7 +80,6 @@ private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField(""override"");
     } catch (NoSuchFieldException e) {
-      e.printStackTrace();
       return null;
     }
   }, @@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal.reflect;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Field;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link UnsafeReflectionAccessor}
+ *
+ * @author Inderjeet Singh
+ */
+public class UnsafeReflectionAccessorTest {
+
+  @Test
+  public void testMakeAccessibleWithUnsafe() throws Exception {
+    UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+    Field field = ClassWithPrivateFinalFields.class.getDeclaredField(""a"");
+    try {
+      boolean success = accessor.makeAccessibleWithUnsafe(field);
+      assertTrue(success);
+    } catch (Exception e) {
+      fail(""Unsafe didn't work on the JDK"");
+    }
+  }
+
+  @SuppressWarnings(""unused"")
+  private static final class ClassWithPrivateFinalFields {
+    private final String a;
+    public ClassWithPrivateFinalFields(String a) {
+      this.a = a;
+    }
+  }
+}, ","Also using Unsafe using reflection
Also removed exception traces when sun.misc.Unsafe or override are not found","If sun.misc.Unsafe not found on Java 9, try field.setAccessible"
1311,Inderjeet Singh,"['gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/JavaVersion.java', 'gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java', 'gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java', 'gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java', 'gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java', 'gson/src/test/java/com/google/gson/functional/ObjectTest.java', 'gson/src/test/java/com/google/gson/internal/JavaVersionTest.java']","@@ -27,12 +27,12 @@
 import java.util.List;
 import java.util.Locale;
 
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.google.gson.util.JavaVersion;
 
 /**
  * This type adapter supports three subclasses of date: Date, Timestamp, and, @@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.util;
+package com.google.gson.internal;
 
 /**
  * Utility to check the major Java version of the current JVM., @@ -20,13 +20,13 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.google.gson.util.JavaVersion;
 
 import java.io.IOException;
 import java.text.DateFormat;, @@ -15,10 +15,10 @@
  */
 package com.google.gson.internal.reflect;
 
-import com.google.gson.util.JavaVersion;
-
 import java.lang.reflect.AccessibleObject;
 
+import com.google.gson.internal.JavaVersion;
+
 /**
  * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
  * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}, @@ -23,7 +23,8 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
-import com.google.gson.util.JavaVersion;
+import com.google.gson.internal.JavaVersion;
+
 import junit.framework.TestCase;
 
 /**, @@ -27,6 +27,7 @@
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -56,7 +57,6 @@
 import java.util.TreeSet;
 import java.util.UUID;
 
-import com.google.gson.util.JavaVersion;
 import junit.framework.TestCase;
 
 /**, @@ -33,6 +33,7 @@
 import com.google.gson.common.TestTypes.ClassWithTransientFields;
 import com.google.gson.common.TestTypes.Nested;
 import com.google.gson.common.TestTypes.PrimitiveArray;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -44,7 +45,6 @@
 import java.util.Map;
 import java.util.TimeZone;
 
-import com.google.gson.util.JavaVersion;
 import junit.framework.TestCase;
 
 /**, @@ -13,12 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.util;
+package com.google.gson.internal;
 
 import static org.junit.Assert.*;
 
 import org.junit.Test;
 
+import com.google.gson.internal.JavaVersion;
+
 /**
  * Unit and functional tests for {@link JavaVersion}
  *, ","Also renamed VersionUtils to more readable abstraction JavaVersion
Added support for debian naming convention
Using min supported version (6) as the default if JDK version can't be figured out",Fixed https://github.com/google/gson/issues/1310
1321,Inderjeet Singh,"['gson/pom.xml', 'gson/src/main/java-templates/com/google/gson/internal/GsonBuildConfig.java', 'gson/src/main/java/com/google/gson/Gson.java', 'gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java', 'gson/src/test/java/com/google/gson/internal/GsonBuildConfigTest.java']","@@ -17,7 +17,7 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-
+ 
   <build>
     <plugins>
       <plugin>
@@ -56,6 +56,23 @@
         <groupId>org.apache.felix</groupId>
         <artifactId>maven-bundle-plugin</artifactId>
       </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>templating-maven-plugin</artifactId>
+        <version>1.0.0</version>
+        <executions>
+          <execution>
+            <id>filtering-java-templates</id>
+            <goals>
+              <goal>filter-sources</goal>
+            </goals>
+            <configuration>
+              <sourceDirectory>${basedir}/src/main/java-templates</sourceDirectory>
+              <outputDirectory>${project.build.directory}/generated-sources/java-templates</outputDirectory>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>, @@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.internal;
+
+/**
+ * Build configuration for Gson. This file is automatically populated by
+ * templating-maven-plugin and .java/.class files are generated for use in Gson.
+ *
+ * @author Inderjeet Singh
+ */
+public final class GsonBuildConfig {
+  // Based on https://stackoverflow.com/questions/2469922/generate-a-version-java-file-in-maven
+
+  /** This field is automatically populated by Maven when a build is triggered */
+  public static final String VERSION = ""${project.version}"";
+}, @@ -37,6 +37,7 @@
 
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
+import com.google.gson.internal.GsonBuildConfig;
 import com.google.gson.internal.Primitives;
 import com.google.gson.internal.Streams;
 import com.google.gson.internal.bind.ArrayTypeAdapter;
@@ -461,7 +462,7 @@ static void checkValidFloatingPoint(double value) {
           return candidate;
         }
       }
-      throw new IllegalArgumentException(""GSON cannot handle "" + type);
+      throw new IllegalArgumentException(""GSON ("" + GsonBuildConfig.VERSION + "") cannot handle "" + type);
     } finally {
       threadCalls.remove(type);
 
@@ -703,6 +704,8 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
       ((TypeAdapter<Object>) adapter).write(writer, src);
     } catch (IOException e) {
       throw new JsonIOException(e);
+    } catch (AssertionError e) {
+      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage(), e);
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -779,6 +782,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
       Streams.write(jsonElement, writer);
     } catch (IOException e) {
       throw new JsonIOException(e);
+    } catch (AssertionError e) {
+      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage(), e);
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -935,6 +940,8 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
     } catch (IOException e) {
       // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
       throw new JsonSyntaxException(e);
+    } catch (AssertionError e) {
+      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage(), e);
     } finally {
       reader.setLenient(oldLenient);
     }, @@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 Gson Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.functional;
+
+import java.io.IOException;
+import java.util.regex.Pattern;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+import junit.framework.TestCase;
+
+/**
+ * Functional tests to validate printing of Gson version on AssertionErrors
+ *
+ * @author Inderjeet Singh
+ */
+public class GsonVersionDiagnosticsTest extends TestCase {
+  private static final Pattern GSON_VERSION_PATTERN = Pattern.compile(""(\\(GSON \\d\\.\\d\\.\\d)(?:[-.][A-Z]+)?\\)$"");
+
+  private Gson gson;
+
+  @Before
+  public void setUp() {
+    gson = new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter<TestType>() {
+      @Override public void write(JsonWriter out, TestType value) {
+        throw new AssertionError(""Expected during serialization"");
+      }
+      @Override public TestType read(JsonReader in) throws IOException {
+        throw new AssertionError(""Expected during deserialization"");
+      }
+    }).create();
+  }
+
+  @Test
+  public void testVersionPattern() {
+    assertTrue(GSON_VERSION_PATTERN.matcher(""(GSON 2.8.5)"").matches());
+    assertTrue(GSON_VERSION_PATTERN.matcher(""(GSON 2.8.5-SNAPSHOT)"").matches());
+  }
+
+  @Test
+  public void testAssertionErrorInSerializationPrintsVersion() {
+    try {
+      gson.toJson(new TestType());
+      fail();
+    } catch (AssertionError expected) {
+      ensureAssertionErrorPrintsGsonVersion(expected);
+    }
+  }
+
+  @Test
+  public void testAssertionErrorInDeserializationPrintsVersion() {
+    try {
+      gson.fromJson(""{'a':'abc'}"", TestType.class);
+      fail();
+    } catch (AssertionError expected) {
+      ensureAssertionErrorPrintsGsonVersion(expected);
+    }
+  }
+
+  private void ensureAssertionErrorPrintsGsonVersion(AssertionError expected) {
+    String msg = expected.getMessage();
+    // System.err.println(msg);
+    int start = msg.indexOf(""(GSON"");
+    assertTrue(start > 0);
+    int end = msg.indexOf(""):"") + 1;
+    assertTrue(end > 0 && end > start + 6);
+    String version = msg.substring(start, end);
+    // System.err.println(version);
+    assertTrue(GSON_VERSION_PATTERN.matcher(version).matches());
+  }
+
+  private static final class TestType {
+    @SuppressWarnings(""unused"")
+    String a;
+  }
+}, @@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2018 The Gson authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.gson.internal;
+
+import static org.junit.Assert.assertFalse;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for {@code GsonBuildConfig}
+ *
+ * @author Inderjeet Singh
+ */
+public class GsonBuildConfigTest {
+
+  @Test
+  public void testEnsureGsonBuildConfigGetsUpdatedToMavenVersion() {
+    assertFalse(""${project.version}"".equals(GsonBuildConfig.VERSION));
+  }
+}, ","…legalArgumentException

On some versions of Android (probably on some variants of the popular Samsung S4 phone), an older version of Gson is suspected to be bundled in, and gets picked up from the system classpath.
For those versions, the applications that include the latest Gson fail unexpectedly. This debug print will help confirm this issue.",Issue 1242: Printing Gson version when throwing AssertionError and Il…
1324,Joel Leitch,['ReleaseProcess.md'],"@@ -3,7 +3,6 @@
 The following is a step-by-step procedure for releasing a new version of Google-Gson.
 
 1. Go through all open bugs and identify which will be fixed in this release. Mark all others with an appropriate release tag. Identify duplicates, and close the bugs that will never be fixed. Fix all bugs for the release, and mark them fixed.
-1. (obsolete step) Edit [`pom.xml`](pom.xml) and update the versions listed for Export-Package to the target version. Also add any new Java packages that have been introduced in Gson.
 1. Ensure all changelists are code-reviewed and have +1
 1. `cd gson` to the parent directory; ensure there are no open files and all changes are committed.
 1. Run `mvn release:clean`, ",Add private constructors to utility classes and update the release process.,Private constructor
1330,Christian Schwarz,['README.md'],"@@ -20,7 +20,7 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
   * To use Gson in Android
 ```gradle
 dependencies {
-    implementation 'com.google.code.gson:gson:2.8.4'
+    implementation 'com.google.code.gson:gson:2.8.5'
 }
 ```
 
@@ -30,7 +30,7 @@ dependencies {
 <dependency>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson</artifactId>
-    <version>2.8.4</version>
+    <version>2.8.5</version>
 </dependency>
 ```
 , ",NaN,README.md Updated dependency examples to version 2.8.5
1342,Luca Taddeo,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -126,29 +126,40 @@
   private final String typeFieldName;
   private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();
   private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();
+  private final boolean maintainType;
 
-  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
+  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {
     if (typeFieldName == null || baseType == null) {
       throw new NullPointerException();
     }
     this.baseType = baseType;
     this.typeFieldName = typeFieldName;
+    this.maintainType = maintainType;
   }
 
+  /**
+   * Creates a new runtime type adapter using for {@code baseType} using {@code
+   * typeFieldName} as the type field name. Type field names are case sensitive.
+   * {@code maintainType} flag decide if the type will be stored in pojo or not.
+   */
+  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {
+    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, maintainType);
+  }
+  
   /**
    * Creates a new runtime type adapter using for {@code baseType} using {@code
    * typeFieldName} as the type field name. Type field names are case sensitive.
    */
   public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);
+    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName, false);
   }
 
   /**
    * Creates a new runtime type adapter for {@code baseType} using {@code ""type""} as
    * the type field name.
    */
   public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
-    return new RuntimeTypeAdapterFactory<T>(baseType, ""type"");
+    return new RuntimeTypeAdapterFactory<T>(baseType, ""type"", false);
   }
 
   /**
@@ -199,7 +210,13 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
     return new TypeAdapter<R>() {
       @Override public R read(JsonReader in) throws IOException {
         JsonElement jsonElement = Streams.parse(in);
-        JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
+        JsonElement labelJsonElement;
+        if (maintainType) {
+            labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
+        } else {
+            labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
+        }
+        
         if (labelJsonElement == null) {
           throw new JsonParseException(""cannot deserialize "" + baseType
               + "" because it does not define a field named "" + typeFieldName);
@@ -224,12 +241,16 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
               + ""; did you forget to register a subtype?"");
         }
         JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();
-        if (jsonObject.has(typeFieldName)) {
-          throw new JsonParseException(""cannot serialize "" + srcType.getName()
-              + "" because it already defines a field named "" + typeFieldName);
-        }
         JsonObject clone = new JsonObject();
-        clone.add(typeFieldName, new JsonPrimitive(label));
+        
+        if (!maintainType) {
+            if (jsonObject.has(typeFieldName)) {
+              throw new JsonParseException(""cannot serialize "" + srcType.getName()
+                  + "" because it already defines a field named "" + typeFieldName);
+            }
+            clone.add(typeFieldName, new JsonPrimitive(label));
+        }
+        
         for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
           clone.add(e.getKey(), e.getValue());
         }, ","Instead of completely remove type variable, give the possibility to decide if maintain type value (if pojo has type variable declaration) or not.",Add possibility to maintain type variable in created pojo
1350,Alex Alexandrovich,['.gitattributes'],"@@ -0,0 +1 @@
+gson/docs/javadocs/* linguist-documentation, ",Use the linguist-documentation attribute to mark paths as documentation.,add .gitattributes
1362,Eric Cochran,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -243,7 +243,8 @@ private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boole
         JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();
 
         if (maintainType) {
-          return jsonObject;
+          Streams.write(jsonObject, out);
+          return;
         }
 
         JsonObject clone = new JsonObject();, ","When we maintain the label value, we do not need to make a new JsonObject and copy over the keys and values when writing. The ordering will change, though. Before this change, it always put the label first.",Simplify maintainType logic.
1363,Eric Cochran,['gson/src/main/java/com/google/gson/JsonElement.java'],"@@ -271,6 +271,7 @@ public byte getAsByte() {
    * @deprecated This method is misleading, as it does not get this element as a char but rather as
    * a string's first character.
    */
+  @Deprecated
   public char getAsCharacter() {
     throw new UnsupportedOperationException(getClass().getSimpleName());
   }, ",Closes #1355.,Deprecate JsonElement.getAsCharacter.
1373, Karan Kumar,['UserGuide.md'],"@@ -74,7 +74,7 @@ The Gson instance does not maintain any state while invoking Json operations. So
 ## <a name=""TOC-Gson-With-Gradle""></a>Using Gson with Gradle/Android
 ```
 dependencies {
-    compile 'com.google.code.gson:gson:2.8.5'
+    implementation 'com.google.code.gson:gson:2.8.5'
 }
 ```
 ## <a name=""TOC-Gson-With-Maven""></a>Using Gson with Maven, ","Fix for issue https://github.com/google/gson/issues/1372.

Summarised here again:
Changed the obsolete 'compile' to 'implementation' in the Gradle dependency section",Change 'compile' to 'implementation'
1376,Jake Wharton,['README.md'],"@@ -1,48 +1,48 @@
-# google-gson
-
-[![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson)
-[![Javadoc](https://javadoc-emblem.rhcloud.com/doc/com.google.code.gson/gson/badge.svg)](http://www.javadoc.io/doc/com.google.code.gson/gson)
+# Gson
 
 Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.
 Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.
 
 There are a few open-source projects that can convert Java objects to JSON. However, most of them require that you place Java annotations in your classes; something that you can not do if you do not have access to the source-code. Most also do not fully support the use of Java Generics. Gson considers both of these as very important design goals.
 
-### Gson Goals
+### Goals
   * Provide simple `toJson()` and `fromJson()` methods to convert Java objects to JSON and vice-versa
   * Allow pre-existing unmodifiable objects to be converted to and from JSON
   * Extensive support of Java Generics
   * Allow custom representations for objects
   * Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)
 
-### Gson Download and Maven
-  * To use Gson in Android
+### Download
+
+Gradle:
 ```gradle
 dependencies {
-    implementation 'com.google.code.gson:gson:2.8.5'
+  implementation 'com.google.code.gson:gson:2.8.5'
 }
 ```
 
-  * [Gson Download](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) downloads at Maven Central
-  * To use Gson with Maven
-  ```xml
+Maven:
+```xml
 <dependency>
-    <groupId>com.google.code.gson</groupId>
-    <artifactId>gson</artifactId>
-    <version>2.8.5</version>
+  <groupId>com.google.code.gson</groupId>
+  <artifactId>gson</artifactId>
+  <version>2.8.5</version>
 </dependency>
 ```
 
-### Gson Documentation
-  * Gson [API](http://www.javadoc.io/doc/com.google.code.gson/gson): Javadocs for the current Gson release
-  * Gson [user guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
-  * Gson [Roadmap](https://github.com/google/gson/blob/master/CHANGELOG.md): Details of changes in the recent versions
-  * Gson [design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
+[Gson jar downloads](https://maven-badges.herokuapp.com/maven-central/com.google.code.gson/gson) are available from Maven Central.
+
+[![Build Status](https://travis-ci.org/google/gson.svg?branch=master)](https://travis-ci.org/google/gson)
+
+### Documentation
+  * [API Javadoc](http://www.javadoc.io/doc/com.google.code.gson/gson): Documentation for the current release
+  * [User guide](https://github.com/google/gson/blob/master/UserGuide.md): This guide contains examples on how to use Gson in your code.
+  * [Change log](https://github.com/google/gson/blob/master/CHANGELOG.md): Changes in the recent versions
+  * [Design document](https://github.com/google/gson/blob/master/GsonDesignDocument.md): This document discusses issues we faced while designing Gson. It also includes a comparison of Gson with other Java libraries that can be used for Json conversion
 
-Please use the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson, or to post questions.
+Please use the 'gson' tag on StackOverflow or the [google-gson Google group](http://groups.google.com/group/google-gson) to discuss Gson or to post questions.
 
-### Gson-related Content Created by Third Parties
+### Related Content Created by Third Parties
   * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
   * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
   * [Gson API Report](https://abi-laboratory.pro/java/tracker/timeline/gson/)
@@ -66,3 +66,7 @@ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 ```
+
+### Disclaimer
+
+This is not an officially supported Google product., ","* Remove a lot of ""Gson"" as it's implied nearly everywhere.
* Remove broken Javadoc badge. Move other badges to be near the content to which they apply
* Not an official Google product
* Make download section more general. People other than Android developers use Gradle, for example.",Clean up the README a bit
1391,Mike Cumings,['gson/src/main/java/com/google/gson/internal/$Gson$Types.java'],"@@ -370,7 +370,7 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        toResolve = componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
         break;
@@ -379,7 +379,7 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        toResolve = componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
         break;
@@ -388,12 +388,12 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
-        boolean changed = newOwnerType != ownerType;
+        boolean changed = !equal(newOwnerType, ownerType);
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
-          if (resolvedTypeArgument != args[t]) {
+          if (!equal(resolvedTypeArgument, args[t])) {
             if (!changed) {
               args = args.clone();
               changed = true;, ","When a type variable is referenced multiple times it needs to resolve to the same value.  Previously, the second attempt would abort resolution early in order to protect against infinite recursion.

NOTE: I could use some scrutiny on this as I don't fully understand the implications of all the code branches.  This commit does resolve the issue but stylistically I'm not really sold on breaking out of the while loop in order to capture the final result for subsequent resolution attempts.

Fixes #1390 ",Fix issue with recursive type variable protections to fix #1390
1400,Samyak Bakliwal,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -104,9 +104,9 @@
  * registered. This protects your application from injection attacks. If you
  * don't supply an explicit type label, the type's simple name will be used.
  * <pre>   {@code
- *   shapeAdapter.registerSubtype(Rectangle.class, ""Rectangle"");
- *   shapeAdapter.registerSubtype(Circle.class, ""Circle"");
- *   shapeAdapter.registerSubtype(Diamond.class, ""Diamond"");
+ *   shapeAdapterFactory.registerSubtype(Rectangle.class, ""Rectangle"");
+ *   shapeAdapterFactory.registerSubtype(Circle.class, ""Circle"");
+ *   shapeAdapterFactory.registerSubtype(Diamond.class, ""Diamond"");
  * }</pre>
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code, ",NaN,Typo in JavaDoc example
1402,Piet van Dongen,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -705,7 +705,9 @@ public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOE
     } catch (IOException e) {
       throw new JsonIOException(e);
     } catch (AssertionError e) {
-      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      AssertionError error = new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -783,7 +785,9 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
     } catch (IOException e) {
       throw new JsonIOException(e);
     } catch (AssertionError e) {
-      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      AssertionError error = new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       writer.setLenient(oldLenient);
       writer.setHtmlSafe(oldHtmlSafe);
@@ -941,7 +945,9 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
       // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
       throw new JsonSyntaxException(e);
     } catch (AssertionError e) {
-      throw new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      AssertionError error = new AssertionError(""AssertionError (GSON "" + GsonBuildConfig.VERSION + ""): "" + e.getMessage());
+      error.initCause(e);
+      throw error;
     } finally {
       reader.setLenient(oldLenient);
     }, ","I've followed the instructions from the Apache Maven Compiler Plugin team here: https://maven.apache.org/plugins/maven-compiler-plugin/examples/module-info.html

This should ensure compatibility with Java 6+ while providing module info for Java 9+.

Also, in `gson/src/main/java/com/google/gson/Gson.java` I've removed calls to a constructor only introduced in Java 1.7, which broke backwards compatibility.",Fix JPMS module setup (fixes #1315)
1413,Jeremy W. Sherman,['UserGuide.md'],"@@ -148,8 +148,8 @@ BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
 * There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.
 * If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.
 * This implementation handles nulls correctly.
-* While serializing, a null field is omitted from the output.
-* While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
+  * While serializing, a null field is omitted from the output.
+  * While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.
 * If a field is _synthetic_, it is ignored and not included in JSON serialization or deserialization.
 * Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.
 , ","Indent the details of null handling.

Comparing against the [old, Google Sites user guide][gsites] shows that the two items following the ""handles nulls correctly"" item are intended as a sublist under that item.

[gsites]: https://sites.google.com/site/gson/gson-user-guide#TOC-Finer-Points-with-Objects",Display null-handling details as sublist
1441,Lyubomyr Shaydariv,['extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java'],"@@ -120,6 +120,18 @@
  *       .registerSubtype(Circle.class)
  *       .registerSubtype(Diamond.class);
  * }</pre>
+ *
+ * <h3>Serialization and deserialization</h3>
+ * In order to serialize and deserialize a polymorphic object,
+ * you must specify the base type explicitly.
+ * <pre>   {@code
+ *   Diamond diamond = new Diamond();
+ *   String json = gson.toJson(diamond, Shape.class);
+ * }</pre>
+ * And then:
+ * <pre>   {@code
+ *   Shape shape = gson.fromJson(json, Shape.class);
+ * }</pre>
  */
 public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
   private final Class<?> baseType;, ","This should fix `RuntimeTypeAdapterFactory` JavaDoc missing information for proper serialization and deserialization, originally raised in #1440.",The JavaDoc is now more accurate about the type adapter serialization and deserialization
1454,Paul Kassianik,['gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java'],"@@ -88,8 +88,9 @@ public void testParsingDatesFormattedWithSystemLocale() throws Exception {
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
       assertParsed(String.format(""1 janvier 1970%s00:00:00 UTC"", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed(JavaVersion.isJava9OrLater() ?
+      assertParsed(JavaVersion.isJava9OrLater() ? (JavaVersion.getMajorJavaVersion() <11 ?
                       ""jeudi 1 janvier 1970 à 00:00:00 Coordinated Universal Time"" :
+                      ""jeudi 1 janvier 1970 à 00:00:00 Temps universel coordonné"") :
                       ""jeudi 1 janvier 1970 00 h 00 UTC"",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {, ",Implemented some fixes suggested by @fridrich in issue #1432.,Implemented Fixes suggested by #1432
1464,Márton Braun,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -832,7 +832,8 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOExce
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
    * </pre>
-   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
    * @throws JsonSyntaxException if json is not a valid representation for an object of type
    */
@@ -965,7 +966,8 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
    * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
    * be deserialized
    * @param classOfT The class of T
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
    * @since 1.3
    */
@@ -988,7 +990,8 @@ private static void assertFullConsumption(Object obj, JsonReader reader) {
    * <pre>
    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
    * </pre>
-   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
+   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
+   * or if {@code json} is empty.
    * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
    * @since 1.3
    */, ","Empty strings result in `null` being returned, but this is only stated for `null` strings in the documentation.",Update Gson.java documentation to explicitly state behavior for empty strings
1472,Lorenz Nickel,['gson/README'],"@@ -1,5 +1,5 @@
-Gson is a Java library that can be used to convert a Java object into its 
-JSON representation. It can also be used to convert a JSON string into an 
+Gson is a Java library that can be used to convert Java Objects into their 
+JSON representation. It can also be used to convert a JSON string to an 
 equivalent Java object. Gson can work with arbitrary Java objects including 
 pre-existing objects that you do not have source-code of.
 , ",Adapt [README](https://github.com/google/gson/blob/master/gson/README) to match exactly with the beginning of [README.md](https://github.com/google/gson/blob/master/README.md),Adapt gson/gson/README to match with gson/README.md
1474,Lorenz Nickel,"['gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java', 'gson/src/test/java/com/google/gson/functional/InheritanceTest.java', 'gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java', 'gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java', 'gson/src/test/java/com/google/gson/metrics/PerformanceTest.java']","@@ -87,20 +87,20 @@ protected void tearDown() throws Exception {
 
   public void testClassSerialization() {
     try {
-      gson.toJson(String.class);  
+      gson.toJson(String.class);
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals(""\""java.lang.String\"""", gson.toJson(String.class));  
+    assertEquals(""\""java.lang.String\"""", gson.toJson(String.class));
   }
 
   public void testClassDeserialization() {
     try {
-      gson.fromJson(""String.class"", String.class.getClass());  
+      gson.fromJson(""String.class"", String.class.getClass());
     } catch (UnsupportedOperationException expected) {}
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
-    assertEquals(String.class, gson.fromJson(""java.lang.String"", Class.class));  
+    assertEquals(String.class, gson.fromJson(""java.lang.String"", Class.class));
   }
 
   public void testUrlSerialization() throws Exception {, @@ -217,7 +217,7 @@ boolean queueContains(long... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     boolean setContains(float... values) {
@@ -235,7 +235,7 @@ boolean sortedSetContains(char... values) {
           return false;
         }
       }
-      return true;      
+      return true;
     }
     
     public String getExpectedJson() {, @@ -163,7 +163,7 @@ public void testAbsentJsonElementsAreSetToNull() {
     assertFalse(target.bool2); // test the default value of a primitive boolean field per JVM spec
   }
 
-  public static class ClassWithInitializedMembers  {
+  public static class ClassWithInitializedMembers {
     // Using a mix of no-args constructor and field initializers
     // Also, some fields are intialized and some are not (so initialized per JVM spec)
     public static final String MY_STRING_DEFAULT = ""string"";
@@ -204,7 +204,7 @@ public void testExplicitNullSetsFieldToNullDuringDeserialization() {
     Gson gson = new Gson();
     String json = ""{value:null}"";
     ObjectWithField obj = gson.fromJson(json, ObjectWithField.class);
-    assertNull(obj.value);    
+    assertNull(obj.value);
   }
 
   public void testCustomTypeAdapterPassesNullSerialization() {, @@ -472,11 +472,11 @@ public boolean equals(Object obj) {
     @SuppressWarnings(""unused"")
     int q2 = 20;
   }
-  private interface Measurable<T> {    
+  private interface Measurable<T> {
   }
-  private interface Field<T> {    
+  private interface Field<T> {
   }
-  private interface Immutable {    
+  private interface Immutable {
   }
   
   public static final class Amount<Q extends Quantity> 
@@ -490,12 +490,12 @@ public void testDeepParameterizedTypeSerialization() {
     Amount<MyQuantity> amount = new Amount<MyQuantity>();
     String json = gson.toJson(amount);
     assertTrue(json.contains(""value""));
-    assertTrue(json.contains(""30""));    
+    assertTrue(json.contains(""30""));
   }
   
   public void testDeepParameterizedTypeDeserialization() {
     String json = ""{value:30}"";
-    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();    
+    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();
     Amount<MyQuantity> amount = gson.fromJson(json, type);
     assertEquals(30, amount.value);
   }, @@ -50,11 +50,11 @@ protected void setUp() throws Exception {
     gson = new Gson();
   }
   
-  public void testDummy() {    
+  public void testDummy() {
     // This is here to prevent Junit for complaining when we disable all tests.
-  }  
+  }
 
-  public void disabled_testStringDeserialization() {    
+  public void disabled_testStringDeserialization() {
     StringBuilder sb = new StringBuilder(8096);
     sb.append(""Error Yippie"");
 
@@ -138,8 +138,8 @@ public void disabled_testLargeCollectionDeserialization() {
     }    
     sb.append(']');
     String json = sb.toString();
-    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();    
-    List<CollectionEntry> list = gson.fromJson(json, collectionType);       
+    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();
+    List<CollectionEntry> list = gson.fromJson(json, collectionType);
     assertEquals(count, list.size());
   }
 
@@ -203,7 +203,7 @@ public void disabled_testSerializeClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf(""Serialize classes avg time: %d ms\n"", avg);     
+    System.out.printf(""Serialize classes avg time: %d ms\n"", avg);
   }
 
   public void disabled_testDeserializeClasses() {
@@ -215,7 +215,7 @@ public void disabled_testDeserializeClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf(""Deserialize classes avg time: %d ms\n"", avg);     
+    System.out.printf(""Deserialize classes avg time: %d ms\n"", avg);
   }
   
   public void disable_testLargeObjectSerializationAndDeserialization() {
@@ -249,7 +249,7 @@ public void disabled_testSerializeExposedClasses() {
     } 
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf(""Serialize exposed classes avg time: %d ms\n"", avg);     
+    System.out.printf(""Serialize exposed classes avg time: %d ms\n"", avg);
   }
 
   public void disabled_testDeserializeExposedClasses() {
@@ -261,7 +261,7 @@ public void disabled_testDeserializeExposedClasses() {
     }
     long t2 = System.currentTimeMillis(); 
     long avg = (t2 - t1) / NUM_ITERATIONS;
-    System.out.printf(""Deserialize exposed classes avg time: %d ms\n"", avg);     
+    System.out.printf(""Deserialize exposed classes avg time: %d ms\n"", avg);
   }
 
   public void disabled_testLargeGsonMapRoundTrip() throws Exception {, ","I removed one space in many comments, where double spaces were used improperly, unified comments and removed spaces in code where they were more confusing than helpful.",Code cleanup (Removed spaces)
1482,Tomy Jaya,['UserGuide.md'],"@@ -510,12 +510,12 @@ public class VersionedClass {
 
 VersionedClass versionedObject = new VersionedClass();
 Gson gson = new GsonBuilder().setVersion(1.0).create();
-String jsonOutput = gson.toJson(someObject);
+String jsonOutput = gson.toJson(versionedObject);
 System.out.println(jsonOutput);
 System.out.println();
 
 gson = new Gson();
-jsonOutput = gson.toJson(someObject);
+jsonOutput = gson.toJson(versionedObject);
 System.out.println(jsonOutput);
 ```
 , ",Just a minor fix of wrong object being referenced. ,Fix wrong reference in Versioning Support example
1495,YOUNG HO CHA (aka ganachoco),['gson/src/test/java/com/google/gson/functional/EnumWithObfuscatedTest.java'],"@@ -45,11 +45,11 @@ protected void setUp() throws Exception {
 
   public void testEnumClassWithObfuscated() {
     for (Gender enumConstant: Gender.class.getEnumConstants()) {
-        try {
-            Gender.class.getField(enumConstant.name());
-            fail(""Enum is not obfuscated"");
-        } catch (NoSuchFieldException ignore) {
-        }
+      try {
+        Gender.class.getField(enumConstant.name());
+        fail(""Enum is not obfuscated"");
+      } catch (NoSuchFieldException ignore) {
+      }
     }
 
     assertEquals(Gender.MALE, gson.fromJson(""\""MAIL\"""", Gender.class));, ","When enum value was obfuscated by proguard, EnumTypeAdapter raise NoSuchFieldException, even if apply SerializedName annotation.
Because EnumTypeAdapter cannot find obfuscated enum constant field with its name.
But without this workaround, there is no way to obfuscate enum name.",Make EnumTypeAdapter friendly with obfuscation
1500,Degubi,['gson/src/main/java/module-info.java'],"@@ -4,5 +4,5 @@
 	exports com.google.gson.reflect;
 	exports com.google.gson.stream;
 
-	requires java.sql;
+	requires transitive java.sql;
 }, ","Make the ""java.sql"" dependency transitive in the module-info.java file. It's not transitive, so every module that requires the ""gson"" module also needs to explicitly require the ""java.sql"" module. Without requiring it application startups fails with a ""java.lang.NoClassDefFoundError: java/sql/Time"" exception every time.","Make ""requires java.sql"" transitive"
1501,Manuel Kollus,['gson/src/main/java/com/google/gson/Gson.java'],"@@ -192,8 +192,8 @@ public Gson() {
         Collections.<TypeAdapterFactory>emptyList());
   }
 
-  Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,
-      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
+  Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
+      Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,
       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,
       boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,
       LongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,, ","Hello Dear, Google Developers!

I have removed the 'final' access modifier from the constructor because they are not necessary.

Yours sincerely,
Manuel Kollus",Removing unnecessary 'final' access modifier from constructor
1505,Degubi,['gson/src/main/java/com/google/gson/stream/JsonReader.java'],"@@ -189,8 +189,6 @@
  * @since 1.6
  */
 public class JsonReader implements Closeable {
-  /** The only non-execute prefix this parser permits */
-  private static final char[] NON_EXECUTE_PREFIX = "")]}'\n"".toCharArray();
   private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
 
   private static final int PEEKED_NONE = 0;
@@ -1572,18 +1570,18 @@ private void consumeNonExecutePrefix() throws IOException {
     nextNonWhitespace(true);
     pos--;
 
-    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {
+    int p = pos;
+    if (p + 5 > limit && !fillBuffer(5)) {
       return;
     }
 
-    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {
-      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {
-        return; // not a security token!
-      }
+    char[] buf = buffer;
+    if(buf[p] != ')' || buf[p + 1] != ']' || buf[p + 2] != '}' || buf[p + 3] != '\'' || buf[p + 4] != '\n') {
+      return; // not a security token!
     }
 
     // we consumed a security token!
-    pos += NON_EXECUTE_PREFIX.length;
+    pos += 5;
   }
 
   static {, ","- Remove static array in JsonReader.
- Replace loop if-s with 5 explicit if statements, each checking 1 character at a time.",Refactor JsonReader's consumeNonExecutePrefix method
1512,Degubi,['gson/src/main/java/com/google/gson/JsonPrimitive.java'],"@@ -100,10 +100,9 @@ public boolean isBoolean() {
   public boolean getAsBoolean() {
     if (isBoolean()) {
       return ((Boolean) value).booleanValue();
-    } else {
-      // Check to see if the value as a String is ""true"" in any case.
-      return Boolean.parseBoolean(getAsString());
     }
+	// Check to see if the value as a String is ""true"" in any case.
+    return Boolean.parseBoolean(getAsString());
   }
 
   /**, ","-Remove documentation & code for ""getAsBooleanWrapper"" in JsonElement.
-Remove uses of ""getAsBooleanWrapper"" in JsonPrimitive.
-Inline ""getAsBooleanWrapper"" into methods where it was used.

-Not breaking backwards compatibility, because the methods were package private.",Remove package private helpers in JsonElement & JsonPrimitive
1515,Degubi,"['gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/test/java/com/google/gson/functional/FieldNamingTest.java']","@@ -159,31 +159,20 @@ static String separateCamelCase(String name, String separator) {
    * Ensures the JSON field names begins with an upper case letter.
    */
   static String upperCaseFirstLetter(String name) {
-    StringBuilder fieldNameBuilder = new StringBuilder();
-    int index = 0;
-    char firstCharacter = name.charAt(index);
-    int length = name.length();
+    int firstLetterIndex = 0;
+    int limit = name.length() - 1;
+    for(; !Character.isLetter(name.charAt(firstLetterIndex)) && firstLetterIndex < limit; ++firstLetterIndex);
 
-    while (index < length - 1) {
-      if (Character.isLetter(firstCharacter)) {
-        break;
-      }
-
-      fieldNameBuilder.append(firstCharacter);
-      firstCharacter = name.charAt(++index);
+    char firstLetter = name.charAt(firstLetterIndex);
+    if(Character.isUpperCase(firstLetter)) { //The letter is already uppercased, return the original
+      return name;
     }
 
-    if (!Character.isUpperCase(firstCharacter)) {
-      String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);
-      return fieldNameBuilder.append(modifiedTarget).toString();
-    } else {
-      return name;
+    char uppercased = Character.toUpperCase(firstLetter);
+    if(firstLetterIndex == 0) { //First character in the string is the first letter, saves 1 substring
+      return uppercased + name.substring(1);
     }
-  }
 
-  private static String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {
-    return (indexOfSubstring < srcString.length())
-        ? firstCharacter + srcString.substring(indexOfSubstring)
-        : String.valueOf(firstCharacter);
+    return name.substring(0, firstLetterIndex) + uppercased + name.substring(firstLetterIndex + 1);
   }
 }, @@ -33,39 +33,39 @@ public void testIdentity() {
     Gson gson = getGsonWithNamingPolicy(IDENTITY);
     assertEquals(""{'lowerCamel':1,'UpperCamel':2,'_lowerCamelLeadingUnderscore':3,"" +
         ""'_UpperCamelLeadingUnderscore':4,'lower_words':5,'UPPER_WORDS':6,"" +
-        ""'annotatedName':7,'lowerId':8}"",
+        ""'annotatedName':7,'lowerId':8,'_9':9}"",
         gson.toJson(new TestNames()).replace('\""', '\''));
   }
 
   public void testUpperCamelCase() {
     Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE);
     assertEquals(""{'LowerCamel':1,'UpperCamel':2,'_LowerCamelLeadingUnderscore':3,"" +
         ""'_UpperCamelLeadingUnderscore':4,'Lower_words':5,'UPPER_WORDS':6,"" +
-        ""'annotatedName':7,'LowerId':8}"",
+        ""'annotatedName':7,'LowerId':8,'_9':9}"",
         gson.toJson(new TestNames()).replace('\""', '\''));
   }
 
   public void testUpperCamelCaseWithSpaces() {
     Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);
     assertEquals(""{'Lower Camel':1,'Upper Camel':2,'_Lower Camel Leading Underscore':3,"" +
         ""'_ Upper Camel Leading Underscore':4,'Lower_words':5,'U P P E R_ W O R D S':6,"" +
-        ""'annotatedName':7,'Lower Id':8}"",
+        ""'annotatedName':7,'Lower Id':8,'_9':9}"",
         gson.toJson(new TestNames()).replace('\""', '\''));
   }
 
   public void testLowerCaseWithUnderscores() {
     Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_UNDERSCORES);
     assertEquals(""{'lower_camel':1,'upper_camel':2,'_lower_camel_leading_underscore':3,"" +
         ""'__upper_camel_leading_underscore':4,'lower_words':5,'u_p_p_e_r__w_o_r_d_s':6,"" +
-        ""'annotatedName':7,'lower_id':8}"",
+        ""'annotatedName':7,'lower_id':8,'_9':9}"",
         gson.toJson(new TestNames()).replace('\""', '\''));
   }
 
   public void testLowerCaseWithDashes() {
     Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_DASHES);
     assertEquals(""{'lower-camel':1,'upper-camel':2,'_lower-camel-leading-underscore':3,"" +
         ""'_-upper-camel-leading-underscore':4,'lower_words':5,'u-p-p-e-r_-w-o-r-d-s':6,"" +
-        ""'annotatedName':7,'lower-id':8}"",
+        ""'annotatedName':7,'lower-id':8,'_9':9}"",
         gson.toJson(new TestNames()).replace('\""', '\''));
   }
 
@@ -85,5 +85,6 @@ private Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){
     int UPPER_WORDS = 6;
     @SerializedName(""annotatedName"") int annotated = 7;
     int lowerId = 8;
+    int _9 = 9;
   }
 }, ","-Refactor upperCaseFirstLetter in FieldNamingPolicy.
-Add some comments for special case handling
-Add additional test field to keep 100% coverage (branch in loop for checking to not go out of bounds).
-Shorter, faster. Except for the newly added case. I hope no one writes fields without letters.

Benchmark code: https://pastebin.com/63VJWF03
Benchmark run: https://pastebin.com/su29iePu",Refactor FieldNamingPolicy.upperCaseFirstLetter
1521,,['UserGuide.md'],"@@ -250,7 +250,7 @@ gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
 
 The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
 
-You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](https://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html) class.
+You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html) class.
 
 ```java
 Type fooType = new TypeToken<Foo<Bar>>() {}.getType();
@@ -556,7 +556,7 @@ This feature provides a way where you can mark certain fields of your objects to
 
 #### <a name=""TOC-User-Defined-Exclusion-Strategies""></a>User Defined Exclusion Strategies
 
-If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](https://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
+If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the [`ExclusionStrategy`](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html) JavaDoc for more information.
 
 The following example shows how to exclude fields marked with a specific `@Foo` annotation and excludes top-level types (or declared field type) of class `String`.
 
@@ -615,7 +615,7 @@ The output is:
 
 ### <a name=""TOC-JSON-Field-Naming-Support""></a>JSON Field Naming Support
 
-Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](https://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
+Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case --- `sampleFieldNameInJava`) to a Json field name (i.e., `sample_field_name_in_java` or `SampleFieldNameInJava`). See the [FieldNamingPolicy](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html) class for information on the pre-defined naming policies.
 
 It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise ""Runtime"" exceptions if an invalid field name is provided as the annotation value.
 
@@ -644,7 +644,7 @@ The output is:
 {""custom_naming"":""first"",""SomeOtherField"":""second""}
 ```
 
-If you have a need for custom naming policy ([see this discussion](https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](https://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html) annotation.
+If you have a need for custom naming policy ([see this discussion](https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892)), you can use the [@SerializedName](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html) annotation.
 
 ### <a name=""TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers""></a>Sharing State Across Custom Serializers and Deserializers
 , ",NaN,Change URLs from http to https
1522,Degubi,"['gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java', 'gson/src/test/java/com/google/gson/FieldAttributesTest.java', 'gson/src/test/java/com/google/gson/JsonPrimitiveTest.java', 'gson/src/test/java/com/google/gson/common/MoreAsserts.java', 'gson/src/test/java/com/google/gson/functional/ArrayTest.java', 'gson/src/test/java/com/google/gson/functional/CollectionTest.java', 'gson/src/test/java/com/google/gson/functional/JsonParserTest.java', 'gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java', 'gson/src/test/java/com/google/gson/functional/MapTest.java', 'gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java', 'gson/src/test/java/com/google/gson/functional/PrimitiveTest.java', 'gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java', 'gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java', 'gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java', 'gson/src/test/java/com/google/gson/stream/JsonReaderTest.java', 'gson/src/test/java/com/google/gson/stream/JsonWriterTest.java']","@@ -167,6 +167,7 @@ public void testDatePattern() throws Exception {
     assertEquals(toLiteral(formatter.format(currentDate)), dateString);
   }
 
+  @SuppressWarnings(""unused"")
   public void testInvalidDatePattern() throws Exception {
     try {
       new DefaultDateTypeAdapter(Date.class, ""I am a bad Date pattern...."");, @@ -39,6 +39,7 @@ protected void setUp() throws Exception {
     fieldAttributes = new FieldAttributes(Foo.class.getField(""bar""));
   }
 
+  @SuppressWarnings(""unused"")
   public void testNullField() throws Exception {
     try {
       new FieldAttributes(null);, @@ -30,6 +30,7 @@
  */
 public class JsonPrimitiveTest extends TestCase {
 
+  @SuppressWarnings(""unused"")
   public void testNulls() {
     try {
       new JsonPrimitive((Boolean) null);
@@ -113,8 +114,8 @@ public void testExponential() throws Exception {
     JsonPrimitive json = new JsonPrimitive(""1E+7"");
 
     assertEquals(new BigDecimal(""1E+7""), json.getAsBigDecimal());
-    assertEquals(new Double(""1E+7""), json.getAsDouble(), 0.00001);
-    assertEquals(new Float(""1E+7""), json.getAsDouble(), 0.00001);
+    assertEquals(1E+7, json.getAsDouble(), 0.00001);
+    assertEquals(1E+7, json.getAsDouble(), 0.00001);
 
     try {
       json.getAsInt();
@@ -123,91 +124,91 @@ public void testExponential() throws Exception {
   }
 
   public void testByteEqualsShort() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Short((short)10));
+    JsonPrimitive p1 = new JsonPrimitive(Byte.valueOf((byte)10));
+    JsonPrimitive p2 = new JsonPrimitive(Short.valueOf((short)10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
+    JsonPrimitive p1 = new JsonPrimitive(Byte.valueOf((byte)10));
+    JsonPrimitive p2 = new JsonPrimitive(Integer.valueOf(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
+    JsonPrimitive p1 = new JsonPrimitive(Byte.valueOf((byte)10));
+    JsonPrimitive p2 = new JsonPrimitive(Long.valueOf(10L));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testByteEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Byte((byte)10));
+    JsonPrimitive p1 = new JsonPrimitive(Byte.valueOf((byte)10));
     JsonPrimitive p2 = new JsonPrimitive(new BigInteger(""10""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Integer(10));
+    JsonPrimitive p1 = new JsonPrimitive(Short.valueOf((short)10));
+    JsonPrimitive p2 = new JsonPrimitive(Integer.valueOf(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10));
+    JsonPrimitive p1 = new JsonPrimitive(Short.valueOf((short)10));
+    JsonPrimitive p2 = new JsonPrimitive(Long.valueOf(10));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testShortEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Short((short)10));
+    JsonPrimitive p1 = new JsonPrimitive(Short.valueOf((short)10));
     JsonPrimitive p2 = new JsonPrimitive(new BigInteger(""10""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testIntegerEqualsLong() {
-    JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
-    JsonPrimitive p2 = new JsonPrimitive(new Long(10L));
+    JsonPrimitive p1 = new JsonPrimitive(Integer.valueOf(10));
+    JsonPrimitive p2 = new JsonPrimitive(Long.valueOf(10L));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testIntegerEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Integer(10));
+    JsonPrimitive p1 = new JsonPrimitive(Integer.valueOf(10));
     JsonPrimitive p2 = new JsonPrimitive(new BigInteger(""10""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testLongEqualsBigInteger() {
-    JsonPrimitive p1 = new JsonPrimitive(new Long(10L));
+    JsonPrimitive p1 = new JsonPrimitive(Long.valueOf(10L));
     JsonPrimitive p2 = new JsonPrimitive(new BigInteger(""10""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testFloatEqualsDouble() {
-    JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
-    JsonPrimitive p2 = new JsonPrimitive(new Double(10.25D));
+    JsonPrimitive p1 = new JsonPrimitive(Float.valueOf(10.25F));
+    JsonPrimitive p2 = new JsonPrimitive(Double.valueOf(10.25D));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testFloatEqualsBigDecimal() {
-    JsonPrimitive p1 = new JsonPrimitive(new Float(10.25F));
+    JsonPrimitive p1 = new JsonPrimitive(Float.valueOf(10.25F));
     JsonPrimitive p2 = new JsonPrimitive(new BigDecimal(""10.25""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());
   }
 
   public void testDoubleEqualsBigDecimal() {
-    JsonPrimitive p1 = new JsonPrimitive(new Double(10.25D));
+    JsonPrimitive p1 = new JsonPrimitive(Double.valueOf(10.25D));
     JsonPrimitive p2 = new JsonPrimitive(new BigDecimal(""10.25""));
     assertEquals(p1, p2);
     assertEquals(p1.hashCode(), p2.hashCode());, @@ -16,7 +16,7 @@
 
 package com.google.gson.common;
 
-import junit.framework.Assert;
+import org.junit.Assert;
 
 import java.util.Collection;
 
@@ -28,26 +28,6 @@
  */
 public class MoreAsserts {
 
-  public static void assertEquals(int[] expected, int[] target) {
-    if (expected == null) {
-      Assert.assertNull(target);
-    }
-    Assert.assertEquals(expected.length, target.length);
-    for (int i = 0; i < expected.length; ++i) {
-      Assert.assertEquals(expected[i], target[i]);
-    }
-  }
-
-  public static void assertEquals(Integer[] expected, Integer[] target) {
-    if (expected == null) {
-      Assert.assertNull(target);
-    }
-    Assert.assertEquals(expected.length, target.length);
-    for (int i = 0; i < expected.length; ++i) {
-      Assert.assertEquals(expected[i], target[i]);
-    }
-  }
-
   /**
    * Asserts that the specified {@code value} is not present in {@code collection}
    * @param collection the collection to look into
@@ -69,5 +49,4 @@ public static void assertEqualsAndHashCode(Object a, Object b) {
     Assert.assertFalse(a.equals(null));
     Assert.assertFalse(a.equals(new Object()));
   }
-
 }, @@ -19,12 +19,12 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonParseException;
-import com.google.gson.common.MoreAsserts;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.ClassWithObjects;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
+import static org.junit.Assert.assertArrayEquals;
 
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
@@ -53,7 +53,7 @@ public void testTopLevelArrayOfIntsSerialization() {
   public void testTopLevelArrayOfIntsDeserialization() {
     int[] expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
     int[] actual = gson.fromJson(""[1,2,3,4,5,6,7,8,9]"", int[].class);
-    MoreAsserts.assertEquals(expected, actual);
+    assertArrayEquals(expected, actual);
   }
 
   public void testInvalidArrayDeserialization() {
@@ -173,8 +173,8 @@ public void testArrayOfCollectionDeserialization() throws Exception {
     Collection<Integer>[] target = gson.fromJson(json, type);
 
     assertEquals(2, target.length);
-    MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));
-    MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));
+    assertArrayEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));
+    assertArrayEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));
   }
 
   public void testArrayOfPrimitivesAsObjectsSerialization() throws Exception {, @@ -42,6 +42,7 @@
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
+import static org.junit.Assert.assertArrayEquals;
 
 /**
  * Functional tests for Json serialization and deserialization of collections.
@@ -70,7 +71,7 @@ public void testTopLevelCollectionOfIntegersDeserialization() {
     Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();
     Collection<Integer> target = gson.fromJson(json, collectionType);
     int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    MoreAsserts.assertEquals(expected, toIntArray(target));
+    assertArrayEquals(expected, toIntArray(target));
   }
 
   public void testTopLevelListOfIntegerCollectionsDeserialization() throws Exception {
@@ -86,7 +87,7 @@ public void testTopLevelListOfIntegerCollectionsDeserialization() throws Excepti
     }
 
     for (int i = 0; i < 3; i++) {
-      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));
+      assertArrayEquals(expected[i], toIntArray(target.get(i)));
     }
   }
 , @@ -123,9 +123,9 @@ public void testChangingCustomTreeAndDeserializing() {
 
   public void testExtraCommasInArrays() {
     Type type = new TypeToken<List<String>>() {}.getType();
-    assertEquals(list(""a"", null, ""b"", null, null), gson.fromJson(""[a,,b,,]"", type));
-    assertEquals(list(null, null), gson.fromJson(""[,]"", type));
-    assertEquals(list(""a"", null), gson.fromJson(""[a,]"", type));
+    assertEquals(Arrays.asList(""a"", null, ""b"", null, null), gson.fromJson(""[a,,b,,]"", type));
+    assertEquals(Arrays.asList(null, null), gson.fromJson(""[,]"", type));
+    assertEquals(Arrays.asList(""a"", null), gson.fromJson(""[a,]"", type));
   }
 
   public void testExtraCommasInMaps() {
@@ -136,8 +136,4 @@ public void testExtraCommasInMaps() {
     } catch (JsonSyntaxException expected) {
     }
   }
-
-  private <T> List<T> list(T... elements) {
-    return Arrays.asList(elements);
-  }
 }, @@ -59,8 +59,8 @@ public void disabled_testTwoTypesCollapseToOneSerialize() {
         .create();
 
     Map<Number, String> original = new LinkedHashMap<Number, String>();
-    original.put(new Double(1.0), ""a"");
-    original.put(new Float(1.0), ""b"");
+    original.put(1.0D, ""a"");
+    original.put(1.0F, ""b"");
     try {
       gson.toJson(original, new TypeToken<Map<Number, String>>() {}.getType());
       fail(); // we no longer hash keys at serialization time, @@ -364,7 +364,7 @@ public void testMapDeserializationWithWildcardValues() {
     Type typeOfMap = new TypeToken<Map<String, ? extends Long>>() {}.getType();
     Map<String, ? extends Long> map = gson.fromJson(""{\""test\"":123}"", typeOfMap);
     assertEquals(1, map.size());
-    assertEquals(new Long(123L), map.get(""test""));
+    assertEquals(Long.valueOf(123L), map.get(""test""));
   }
 
 , @@ -121,7 +121,7 @@ public void testParameterizedTypesWithCustomDeserializer() {
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())
         .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""""))
         .registerTypeAdapter(ptIntegerType,
-            new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))
+            new MyParameterizedTypeInstanceCreator<Integer>(0))
         .create();
 
     MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);, @@ -144,12 +144,12 @@ public void testNumberSerialization() {
 
   public void testNumberDeserialization() {
     String json = ""1"";
-    Number expected = new Integer(json);
+    Number expected = Integer.valueOf(json);
     Number actual = gson.fromJson(json, Number.class);
     assertEquals(expected.intValue(), actual.intValue());
 
     json = String.valueOf(Long.MAX_VALUE);
-    expected = new Long(json);
+    expected = Long.valueOf(json);
     actual = gson.fromJson(json, Number.class);
     assertEquals(expected.longValue(), actual.longValue());
 
@@ -164,16 +164,16 @@ public void testNumberAsStringDeserialization() {
   }
 
   public void testPrimitiveDoubleAutoboxedSerialization() {
-    assertEquals(""-122.08234335"", gson.toJson(-122.08234335));
-    assertEquals(""122.08112002"", gson.toJson(new Double(122.08112002)));
+    assertEquals(""-122.08234335"", gson.toJson(-122.08234335D));
+    assertEquals(""122.08112002"", gson.toJson(122.08112002D));
   }
 
   public void testPrimitiveDoubleAutoboxedDeserialization() {
     double actual = gson.fromJson(""-122.08858585"", double.class);
-    assertEquals(-122.08858585, actual);
+    assertEquals(-122.08858585D, actual);
 
     actual = gson.fromJson(""122.023900008000"", Double.class);
-    assertEquals(122.023900008, actual);
+    assertEquals(122.023900008D, actual);
   }
 
   public void testPrimitiveDoubleAutoboxedInASingleElementArraySerialization() {, @@ -157,17 +157,17 @@ public void testStrictBoxedNansAndInfinities() throws IOException {
     writer.setLenient(false);
     writer.beginArray();
     try {
-      writer.value(new Double(Double.NaN));
+      writer.value(Double.valueOf(Double.NaN));
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
-      writer.value(new Double(Double.NEGATIVE_INFINITY));
+      writer.value(Double.valueOf(Double.NEGATIVE_INFINITY));
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
-      writer.value(new Double(Double.POSITIVE_INFINITY));
+      writer.value(Double.valueOf(Double.POSITIVE_INFINITY));
       fail();
     } catch (IllegalArgumentException expected) {
     }, @@ -34,10 +34,11 @@
  */
 public class RecursiveTypesResolveTest extends TestCase {
 
+  @SuppressWarnings(""unused"")
   private static class Foo1<A> {
-    public Foo2<? extends A> foo2;
+	public Foo2<? extends A> foo2;
   }
-
+  @SuppressWarnings(""unused"")
   private static class Foo2<B> {
     public Foo1<? super B> foo1;
   }
@@ -93,10 +94,12 @@ public void testSubSupertype() {
    * Tests for recursion while resolving type variables.
    */
 
+  @SuppressWarnings(""unused"")
   private static class TestType<X> {
     TestType<? super X> superType;
   }
 
+  @SuppressWarnings(""unused"")
   private static class TestType2<X, Y> {
     TestType2<? super Y, ? super X> superReversedType;
   }
@@ -111,6 +114,3 @@ public void testRecursiveTypeVariablesResolve12() throws Exception {
     assertNotNull(adapter);
   }
 }
-
-
-, @@ -48,14 +48,13 @@ public void testNullSafeBugDeserialize() throws Exception {
       // because we use it to return a null type adapter on a recursive call.
       private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();
 
-      @SuppressWarnings({""unchecked"", ""rawtypes""})
       @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {
         if (type.getRawType() != Device.class || recursiveCall.get() != null) {
           recursiveCall.set(null); // clear for subsequent use
           return null;
         }
         recursiveCall.set(Boolean.TRUE);
-        return (TypeAdapter) gson.getDelegateAdapter(this, type);
+        return gson.getDelegateAdapter(this, type);
       }
     }
   }, @@ -27,9 +27,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assume.assumeTrue;
 
+@SuppressWarnings(""resource"")
 @RunWith(Parameterized.class)
 public class JsonReaderPathTest {
   @Parameterized.Parameters(name = ""{0}""), @@ -189,6 +189,7 @@ public void testInvalidJsonInput() throws IOException {
     }
   }
   
+  @SuppressWarnings(""unused"")
   public void testNulls() {
     try {
       new JsonReader(null);, @@ -198,17 +198,17 @@ public void testNonFiniteBoxedDoubles() throws IOException {
     JsonWriter jsonWriter = new JsonWriter(stringWriter);
     jsonWriter.beginArray();
     try {
-      jsonWriter.value(new Double(Double.NaN));
+      jsonWriter.value(Double.valueOf(Double.NaN));
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(new Double(Double.NEGATIVE_INFINITY));
+      jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));
       fail();
     } catch (IllegalArgumentException expected) {
     }
     try {
-      jsonWriter.value(new Double(Double.POSITIVE_INFINITY));
+      jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));
       fail();
     } catch (IllegalArgumentException expected) {
     }, ","- Add some SuppressWarnings(""unused"") to some fields & classes that are used in reflection code.
- Replace MoreAsserts.assertEquals with Assert.assertArrayEquals.
- Replace primitive wrapper constructor calls with autoboxing or explicit valueOf calls. (Wrapper class constructors deprecated after j9)
- Fix wrong assert imports in MoreAsserts & JsonReaderPathTest.
- Noticed that one of the test methods are failing when using newer java versions in DefaultDateTypeAdapterTest.java, there's already a pr for that: #1454
- Was thinking about refactoring all the test methods to use the Junit4 @Test annotations instead of using the TestCase class",Clean up some deprecations & warnings in tests
1527,Farid Forootan Shad,['examples/android-proguard-example/proguard.cfg'],"@@ -19,4 +19,9 @@
 -keep class * implements com.google.gson.JsonSerializer
 -keep class * implements com.google.gson.JsonDeserializer
 
+# Prevent R8 from leaving Data object members always null
+-keepclassmembers,allowobfuscation class * {
+  @com.google.gson.annotations.SerializedName <fields>;
+}
+
 ##---------------End: proguard configuration for Gson  ----------, ",[described here](https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md#member-in-a-data-object-is-always),update proguard to fix R8 compatibility issue
1531,,['examples/android-proguard-example/proguard.cfg'],"@@ -11,7 +11,7 @@
 #-keep class com.google.gson.stream.** { *; }
 
 # Application classes that will be serialized/deserialized over Gson
--keep class com.google.gson.examples.android.model.** { *; }
+-keep class com.google.gson.examples.android.model.** { <fields>; }
 
 # Prevent proguard from stripping interface information from TypeAdapterFactory,
 # JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter), ","GSON only needs to reflect based on fields:
https://github.com/google/gson/blob/4d942db168c593ba86e46e2b26b026ff2b0d1018/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java#L152

There's no reason to disallow optimizing methods.",Update sample ProGuard config to mark fields instead of all members.
1535,Degubi,['gson/src/main/java/module-info.java'],"@@ -1,3 +1,7 @@
+/**
+ * Defines the Gson serialization/deserialization API.
+ * @since 2.8.6
+ */
 module com.google.gson {
 	exports com.google.gson;
 	exports com.google.gson.annotations;, ",- Add javadocs to module-info.java,Add docs to module-info.java
1538,William Collishaw,['.gitignore'],"@@ -18,3 +18,5 @@ local.properties
 build
 
 .DS_Store
+
+examples/android-proguard-example/gen, ","Intellij IDEA generates a few classes during build that should be ignored
<img width=""492"" alt=""Screen Shot 2019-06-02 at 3 04 07 PM"" src=""https://user-images.githubusercontent.com/16943514/58767437-37b10b80-8548-11e9-98b6-7881f7f3a781.png"">",Add IDEA generated classes folder to gitignore
1539,William Collishaw,['metrics/src/main/java/com/google/gson/metrics/BagOfPrimitives.java'],"@@ -66,22 +66,18 @@ public int hashCode() {
 
   @Override
   public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
     BagOfPrimitives other = (BagOfPrimitives) obj;
-    if (booleanValue != other.booleanValue)
-      return false;
-    if (intValue != other.intValue)
-      return false;
-    if (longValue != other.longValue)
-      return false;
+    if (booleanValue != other.booleanValue) return false;
+    if (intValue != other.intValue) return false;
+    if (longValue != other.longValue) return false;
     if (stringValue == null) {
       return other.stringValue == null;
-    } else return stringValue.equals(other.stringValue);
+    } else {
+      return stringValue.equals(other.stringValue);
+    }
   }
 
   @Override, ",Removes some redundant if statements,Simplify BagOfPrimitives if statement
1546,,['examples/android-proguard-example/proguard.cfg'],"@@ -13,8 +13,9 @@
 # Application classes that will be serialized/deserialized over Gson
 -keep class com.google.gson.examples.android.model.** { <fields>; }
 
-# Prevent proguard from stripping interface information from TypeAdapterFactory,
+# Prevent proguard from stripping interface information from TypeAdapter, TypeAdapterFactory,
 # JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
+-keep class * implements com.google.gson.TypeAdapter
 -keep class * implements com.google.gson.TypeAdapterFactory
 -keep class * implements com.google.gson.JsonSerializer
 -keep class * implements com.google.gson.JsonDeserializer, ","`TypeAdapter` implementations used in JsonAdapter annotation sometimes are never instantiated explicitly without reflection, causing R8 to strip their instance methods.",Keep `TypeAdapter`s from being stripped
1572,Prempal Singh,['UserGuide.md'],"@@ -248,7 +248,7 @@ gson.toJson(foo); // May not serialize foo.value correctly
 gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
 ```
 
-The above code fails to interpret value as type Bar because Gson invokes `list.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
+The above code fails to interpret value as type Bar because Gson invokes `foo.getClass()` to get its class information, but this method returns a raw class, `Foo.class`. This means that Gson has no way of knowing that this is an object of type `Foo<Bar>`, and not just plain `Foo`.
 
 You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the [`TypeToken`](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html) class.
 , ",NaN,Fix typo in UserGuide
1576,David Maplesden,['gson/src/main/java/com/google/gson/stream/JsonWriter.java'],"@@ -286,7 +286,7 @@ public final boolean getSerializeNulls() {
    */
   public JsonWriter beginArray() throws IOException {
     writeDeferredName();
-    return open(EMPTY_ARRAY, ""["");
+    return open(EMPTY_ARRAY, '[');
   }
 
   /**
@@ -295,7 +295,7 @@ public JsonWriter beginArray() throws IOException {
    * @return this writer.
    */
   public JsonWriter endArray() throws IOException {
-    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ""]"");
+    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, ']');
   }
 
   /**
@@ -306,7 +306,7 @@ public JsonWriter endArray() throws IOException {
    */
   public JsonWriter beginObject() throws IOException {
     writeDeferredName();
-    return open(EMPTY_OBJECT, ""{"");
+    return open(EMPTY_OBJECT, '{');
   }
 
   /**
@@ -315,14 +315,14 @@ public JsonWriter beginObject() throws IOException {
    * @return this writer.
    */
   public JsonWriter endObject() throws IOException {
-    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, ""}"");
+    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, '}');
   }
 
   /**
    * Enters a new scope by appending any necessary whitespace and the given
    * bracket.
    */
-  private JsonWriter open(int empty, String openBracket) throws IOException {
+  private JsonWriter open(int empty, char openBracket) throws IOException {
     beforeValue();
     push(empty);
     out.write(openBracket);
@@ -333,7 +333,7 @@ private JsonWriter open(int empty, String openBracket) throws IOException {
    * Closes the current scope by appending any necessary whitespace and the
    * given bracket.
    */
-  private JsonWriter close(int empty, int nonempty, String closeBracket)
+  private JsonWriter close(int empty, int nonempty, char closeBracket)
       throws IOException {
     int context = peek();
     if (context != nonempty && context != empty) {
@@ -562,7 +562,7 @@ public void close() throws IOException {
 
   private void string(String value) throws IOException {
     String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;
-    out.write(""\"""");
+    out.write('\""');
     int last = 0;
     int length = value.length();
     for (int i = 0; i < length; i++) {
@@ -589,15 +589,15 @@ private void string(String value) throws IOException {
     if (last < length) {
       out.write(value, last, length - last);
     }
-    out.write(""\"""");
+    out.write('\""');
   }
 
   private void newline() throws IOException {
     if (indent == null) {
       return;
     }
 
-    out.write(""\n"");
+    out.write('\n');
     for (int i = 1, size = stackSize; i < size; i++) {
       out.write(indent);
     }, ","This results in a noticeable performance improvement with most writer
implementations (including BufferedWriter).

The scale of the improvement obviously depends on the exact data being written but in my test cases the improvement in the performance critical `JsonWriter.string()` method when writing to a writer constructed as 
```
final Writer writer = new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(new ByteArrayOutputStream()), ""UTF-8""), 8192);
```
was around 12.5%.  Given that the bulk of the time is spent doing the content compression the relative change in the non-compression is much larger... removing the `GZIPOutputStream` from the test makes the improvement around 30%.

The reason for the improvement is that the `BufferedWriter` code for writing a single char is much more efficient than the code for writing a string (when that string is length 1).",Prefer writing chars instead of strings of length one
1585,Inderjeet Singh,['pom.xml'],"@@ -63,28 +63,14 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.8.0</version>
-          <executions>
-            <execution>
-              <id>default-compile</id>
-              <configuration>
-                <release>9</release>
-              </configuration>
-            </execution>
-            <execution>
-              <id>base-compile</id>
-              <goals>
-                <goal>compile</goal>
-              </goals>
-              <configuration>
-                <excludes>
-                  <exclude>module-info.java</exclude>
-                </excludes>
-              </configuration>
-            </execution>
-          </executions>
+          <version>3.8.1</version>
           <configuration>
-            <release>6</release>
+            <excludes>
+              <release>6</release>
+              <exclude>**/module-info.java</exclude>
+            </excludes>
+            <source>1.6</source>
+            <target>1.6</target>
           </configuration>
         </plugin>
         <plugin>, ",NaN,Made the build work again with JDK 8
1586,Inderjeet Singh,['pom.xml'],"@@ -64,11 +64,32 @@
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.8.1</version>
+          <executions>
+            <execution>
+              <id>default-compile</id>
+              <configuration>
+                <jdkToolchain>
+                  <version>9</version>
+                </jdkToolchain>
+                <release>9</release>
+              </configuration>
+            </execution>
+            <execution>
+              <id>base-compile</id>
+              <goals>
+                <goal>compile</goal>
+              </goals>
+              <configuration>
+                <excludes>
+                  <exclude>module-info.java</exclude>
+                </excludes>
+              </configuration>
+            </execution>
+          </executions>
           <configuration>
-            <excludes>
-              <release>6</release>
-              <exclude>**/module-info.java</exclude>
-            </excludes>
+            <jdkToolchain>
+              <version>[1.5,9)</version>
+            </jdkToolchain>
             <source>1.6</source>
             <target>1.6</target>
           </configuration>, ",NaN,restored Java 9 build
1591,Alireza Afkar,['CHANGELOG.md'],"@@ -3,7 +3,7 @@ Change Log
 
 ## Version 2.8.6
 _2019-10-04_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.5...gson-parent-2.8.6)
- * Added static nethods `JsonParser.parseString` and `JsonParser.parseReader` and deprecated instance method `JsonParser.parse`
+ * Added static methods `JsonParser.parseString` and `JsonParser.parseReader` and deprecated instance method `JsonParser.parse`
  * Java 9 module-info support
 
 ## Version 2.8.5, ",NaN,Update CHANGELOG.md
1603,Brian de Alwis,['gson/bnd.bnd'],"@@ -3,8 +3,8 @@ Bundle-Name: ${project.name}
 Bundle-Description: ${project.description}
 Bundle-Vendor: Google Gson Project
 Bundle-ContactAddress: ${project.parent.url}
-Bundle-RequiredExecutionEnvironment: J2SE-1.5, JavaSE-1.6, JavaSE-1.7, JavaSE-1.8
-Require-Capability: osgi.ee;filter:=""(&(osgi.ee=JavaSE)(version=1.5))""
+Bundle-RequiredExecutionEnvironment: JavaSE-1.6, JavaSE-1.7, JavaSE-1.8
+Require-Capability: osgi.ee;filter:=""(&(osgi.ee=JavaSE)(version=1.6))""
 
 -removeheaders: Private-Package
 , ","Fixes #1601 #1602

  - explicitly specifies `Require-Capability: osgi.ee` for 1.6 or greater to disable `bnd`'s autogeneration which is deceived by the `module-info.class` file
  - drop the JavaSE 1.5 reference since it hasn't been true for years (#790)
  - remove the unused `org.apache.felix:maven-bundle-plugin` plugin reference

Here are the differences in the resulting manifests:
```diff
--- gson-manifest-2.8.6	2019-10-31 12:24:51.000000000 -0400
+++ gson-manifest-2.8.7-SNAPSHOT	2019-10-31 11:49:39.000000000 -0400
@@ -1,23 +1,22 @@
 Manifest-Version: 1.0
 Archiver-Version: Plexus Archiver
-Created-By: 11.0.4 (Oracle Corporation)
-Built-By: inder
+Created-By: 11.0.4 (AdoptOpenJDK)
+Built-By: bsd
 Build-Jdk: 11.0.4
-Bnd-LastModified: 1570215293550
+Bnd-LastModified: 1572539070059
 Bundle-ContactAddress: https://github.com/google/gson
 Bundle-Description: Gson JSON library
 Bundle-ManifestVersion: 2
 Bundle-Name: Gson
-Bundle-RequiredExecutionEnvironment: J2SE-1.5, JavaSE-1.6, JavaSE-1.7, J
- avaSE-1.8
+Bundle-RequiredExecutionEnvironment: JavaSE-1.6, JavaSE-1.7, JavaSE-1.8
 Bundle-SymbolicName: com.google.gson
 Bundle-Vendor: Google Gson Project
-Bundle-Version: 2.8.6
+Bundle-Version: 2.8.7.201910311624
 Export-Package: com.google.gson;uses:=""com.google.gson.reflect,com.googl
- e.gson.stream"";version=""2.8.6"",com.google.gson.annotations;version=""2.8
- .6"",com.google.gson.reflect;version=""2.8.6"",com.google.gson.stream;vers
- ion=""2.8.6""
+ e.gson.stream"";version=""2.8.7"",com.google.gson.annotations;version=""2.8
+ .7"",com.google.gson.reflect;version=""2.8.7"",com.google.gson.stream;vers
+ ion=""2.8.7""
 Import-Package: com.google.gson.annotations
-Require-Capability: osgi.ee;filter:=""(&(osgi.ee=JavaSE)(version=9.0))""
+Require-Capability: osgi.ee;filter:=""(&(osgi.ee=JavaSE)(version=1.6))""
 Tool: Bnd-4.0.0.201805111645
 
```",Fix OSGi metadata generation to work on JavaSE < 9
1607,,['.travis.yml'],"@@ -1,7 +1,7 @@
 language: java
 
 jdk:
-  - oraclejdk9
+  - openjdk11
 
 install: mvn -f gson install -DskipTests=true
 script: mvn -f gson test, ",Fixes #1606 (?),Use OpenJDK 11 for Travis CI
1623,Matthew Lee,['gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java'],"@@ -130,6 +130,9 @@ private void put(JsonElement value) {
   }
 
   @Override public JsonWriter name(String name) throws IOException {
+    if (name == null) {
+      throw new NullPointerException(""name == null"");
+    }
     if (stack.isEmpty() || pendingName != null) {
       throw new IllegalStateException();
     }, ","Condensed #1620. 

As cqjason describes in [issue #1592](https://github.com/google/gson/issues/1592), the behavior of `JsonTreeWriter.name()` is inconsistent with the method it overrides in its parent JsonWriter. When calling `JsonWriter.name(null)`, a NullPointerException is thrown, while calling `JsonTreeWriter.name(null)` does not throw an exception, leading to a potentially misleading IllegalStateException when calling `JsonTreeWriter.value()` later in execution.

To resolve this, I just copied the null check from lines 385-387 of [JsonWriter](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/stream/JsonWriter.java).",Fixing issue #1592
1638,Jiechuan Chen,['gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java'],"@@ -98,4 +98,4 @@ public void testDateParseInvalidTime() throws ParseException {
             Locale.setDefault(defaultLocale);
         }
     }
-}
\ No newline at end of file
+}, ","Improved testcases for JsonPrimitive and JsonTreeWriter
Added testcases for ISO8601Utils",Add new testcases
1640,Gabriel Basilio Brito,['gson/src/main/java/com/google/gson/JsonArray.java'],"@@ -171,6 +171,15 @@ public boolean contains(JsonElement element) {
   public int size() {
     return elements.size();
   }
+  
+  /**
+   * Returns true if the array is empty
+   *
+   * @return true if the array is empty
+   */
+  public boolean isEmpty() {
+    return elements.isEmpty();
+  }
 
   /**
    * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,, ",The method returns true if the array is empty,Add isEmpty method to JsonArray class
1648,Jonathan Leitschuh,['.github/workflows/gradle-wrapper-validation.yml'],"@@ -0,0 +1,10 @@
+name: ""Validate Gradle Wrapper""
+on: [push, pull_request]
+
+jobs:
+  validation:
+    name: ""Validation""
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - uses: gradle/wrapper-validation-action@v1, ",See: https://github.com/gradle/wrapper-validation-action,Official Gradle Wrapper Validation Action
1653,,"['gson/src/main/java/com/google/gson/ExclusionStrategy.java', 'gson/src/main/java/com/google/gson/FieldNamingPolicy.java', 'gson/src/main/java/com/google/gson/annotations/Expose.java', 'gson/src/main/java/com/google/gson/annotations/JsonAdapter.java', 'gson/src/main/java/com/google/gson/annotations/SerializedName.java', 'gson/src/main/java/com/google/gson/annotations/Since.java', 'gson/src/main/java/com/google/gson/annotations/Until.java', 'gson/src/main/java/com/google/gson/stream/JsonReader.java']","@@ -46,11 +46,11 @@
  *
  * <p><strong>Excludes fields and objects based on a particular annotation:</strong>
  * <pre class=""code"">
- * public &#64interface FooAnnotation {
+ * public &#64;interface FooAnnotation {
  *   // some implementation here
  * }
  *
- * // Excludes any field (or class) that is tagged with an ""&#64FooAnnotation""
+ * // Excludes any field (or class) that is tagged with an ""&#64;FooAnnotation""
  * private static class FooAnnotationExclusionStrategy implements ExclusionStrategy {
  *   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {
  *     return clazz.getAnnotation(FooAnnotation.class) != null;, @@ -44,10 +44,10 @@
    * Using this naming policy with Gson will ensure that the first ""letter"" of the Java
    * field name is capitalized when serialized to its JSON form.
    *
-   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <p>Here's a few examples of the form ""Java Field Name"" ---&gt; ""JSON Field Name"":</p>
    * <ul>
-   *   <li>someFieldName ---> SomeFieldName</li>
-   *   <li>_someFieldName ---> _SomeFieldName</li>
+   *   <li>someFieldName ---&gt; SomeFieldName</li>
+   *   <li>_someFieldName ---&gt; _SomeFieldName</li>
    * </ul>
    */
   UPPER_CAMEL_CASE() {
@@ -61,10 +61,10 @@
    * field name is capitalized when serialized to its JSON form and the words will be
    * separated by a space.
    *
-   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <p>Here's a few examples of the form ""Java Field Name"" ---&gt; ""JSON Field Name"":</p>
    * <ul>
-   *   <li>someFieldName ---> Some Field Name</li>
-   *   <li>_someFieldName ---> _Some Field Name</li>
+   *   <li>someFieldName ---&gt; Some Field Name</li>
+   *   <li>_someFieldName ---&gt; _Some Field Name</li>
    * </ul>
    *
    * @since 1.4
@@ -79,12 +79,12 @@
    * Using this naming policy with Gson will modify the Java Field name from its camel cased
    * form to a lower case field name where each word is separated by an underscore (_).
    *
-   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <p>Here's a few examples of the form ""Java Field Name"" ---&gt; ""JSON Field Name"":</p>
    * <ul>
-   *   <li>someFieldName ---> some_field_name</li>
-   *   <li>_someFieldName ---> _some_field_name</li>
-   *   <li>aStringField ---> a_string_field</li>
-   *   <li>aURL ---> a_u_r_l</li>
+   *   <li>someFieldName ---&gt; some_field_name</li>
+   *   <li>_someFieldName ---&gt; _some_field_name</li>
+   *   <li>aStringField ---&gt; a_string_field</li>
+   *   <li>aURL ---&gt; a_u_r_l</li>
    * </ul>
    */
   LOWER_CASE_WITH_UNDERSCORES() {
@@ -97,12 +97,12 @@
    * Using this naming policy with Gson will modify the Java Field name from its camel cased
    * form to a lower case field name where each word is separated by a dash (-).
    *
-   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <p>Here's a few examples of the form ""Java Field Name"" ---&gt; ""JSON Field Name"":</p>
    * <ul>
-   *   <li>someFieldName ---> some-field-name</li>
-   *   <li>_someFieldName ---> _some-field-name</li>
-   *   <li>aStringField ---> a-string-field</li>
-   *   <li>aURL ---> a-u-r-l</li>
+   *   <li>someFieldName ---&gt; some-field-name</li>
+   *   <li>_someFieldName ---&gt; _some-field-name</li>
+   *   <li>aStringField ---&gt; a-string-field</li>
+   *   <li>aURL ---&gt; a-u-r-l</li>
    * </ul>
    * Using dashes in JavaScript is not recommended since dash is also used for a minus sign in
    * expressions. This requires that a field named with dashes is always accessed as a quoted
@@ -120,12 +120,12 @@
    * Using this naming policy with Gson will modify the Java Field name from its camel cased
    * form to a lower case field name where each word is separated by a dot (.).
    *
-   * <p>Here's a few examples of the form ""Java Field Name"" ---> ""JSON Field Name"":</p>
+   * <p>Here's a few examples of the form ""Java Field Name"" ---&gt; ""JSON Field Name"":</p>
    * <ul>
-   *   <li>someFieldName ---> some.field.name</li>
-   *   <li>_someFieldName ---> _some.field.name</li>
-   *   <li>aStringField ---> a.string.field</li>
-   *   <li>aURL ---> a.u.r.l</li>
+   *   <li>someFieldName ---&gt; some.field.name</li>
+   *   <li>_someFieldName ---&gt; _some.field.name</li>
+   *   <li>aStringField ---&gt; a.string.field</li>
+   *   <li>aURL ---&gt; a.u.r.l</li>
    * </ul>
    * Using dots in JavaScript is not recommended since dot is also used for a member sign in
    * expressions. This requires that a field named with dots is always accessed as a quoted, @@ -34,9 +34,9 @@
  * <p>Here is an example of how this annotation is meant to be used:
  * <p><pre>
  * public class User {
- *   &#64Expose private String firstName;
- *   &#64Expose(serialize = false) private String lastName;
- *   &#64Expose (serialize = false, deserialize = false) private String emailAddress;
+ *   &#64;Expose private String firstName;
+ *   &#64;Expose(serialize = false) private String lastName;
+ *   &#64;Expose (serialize = false, deserialize = false) private String emailAddress;
  *   private String password;
  * }
  * </pre></p>, @@ -31,7 +31,7 @@
  *
  * <p>Here is an example of how this annotation is used:</p>
  * <pre>
- * &#64JsonAdapter(UserJsonAdapter.class)
+ * &#64;JsonAdapter(UserJsonAdapter.class)
  * public class User {
  *   public final String firstName, lastName;
  *   private User(String firstName, String lastName) {
@@ -40,15 +40,15 @@
  *   }
  * }
  * public class UserJsonAdapter extends TypeAdapter&lt;User&gt; {
- *   &#64Override public void write(JsonWriter out, User user) throws IOException {
+ *   &#64;Override public void write(JsonWriter out, User user) throws IOException {
  *     // implement write: combine firstName and lastName into name
  *     out.beginObject();
  *     out.name(""name"");
  *     out.value(user.firstName + "" "" + user.lastName);
  *     out.endObject();
  *     // implement the write method
  *   }
- *   &#64Override public User read(JsonReader in) throws IOException {
+ *   &#64;Override public User read(JsonReader in) throws IOException {
  *     // implement read: split name into firstName and lastName
  *     in.beginObject();
  *     in.nextName();
@@ -59,13 +59,13 @@
  * }
  * </pre>
  *
- * Since User class specified UserJsonAdapter.class in &#64JsonAdapter annotation, it
+ * Since User class specified UserJsonAdapter.class in &#64;JsonAdapter annotation, it
  * will automatically be invoked to serialize/deserialize User instances. <br>
  *
  * <p> Here is an example of how to apply this annotation to a field.
  * <pre>
  * private static final class Gadget {
- *   &#64JsonAdapter(UserJsonAdapter2.class)
+ *   &#64;JsonAdapter(UserJsonAdapter2.class)
  *   final User user;
  *   Gadget(User user) {
  *     this.user = user;, @@ -35,8 +35,8 @@
  * <p>Here is an example of how this annotation is meant to be used:</p>
  * <pre>
  * public class MyClass {
- *   &#64SerializedName(""name"") String a;
- *   &#64SerializedName(value=""name1"", alternate={""name2"", ""name3""}) String b;
+ *   &#64;SerializedName(""name"") String a;
+ *   &#64;SerializedName(value=""name1"", alternate={""name2"", ""name3""}) String b;
  *   String c;
  *
  *   public MyClass(String a, String b, String c) {, @@ -36,9 +36,9 @@
  * public class User {
  *   private String firstName;
  *   private String lastName;
- *   &#64Since(1.0) private String emailAddress;
- *   &#64Since(1.0) private String password;
- *   &#64Since(1.1) private Address address;
+ *   &#64;Since(1.0) private String emailAddress;
+ *   &#64;Since(1.0) private String password;
+ *   &#64;Since(1.1) private Address address;
  * }
  * </pre>
  *, @@ -38,8 +38,8 @@
  * public class User {
  *   private String firstName;
  *   private String lastName;
- *   &#64Until(1.1) private String emailAddress;
- *   &#64Until(1.1) private String password;
+ *   &#64;Until(1.1) private String emailAddress;
+ *   &#64;Until(1.1) private String password;
  * }
  * </pre>
  *, @@ -170,7 +170,7 @@
  * precision loss, extremely large values should be written and read as strings
  * in JSON.
  *
- * <a name=""nonexecuteprefix""/><h3>Non-Execute Prefix</h3>
+ * <a id=""nonexecuteprefix""/><h3>Non-Execute Prefix</h3>
  * Web servers that serve private data using JSON may be vulnerable to <a
  * href=""http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery"">Cross-site
  * request forgery</a> attacks. In such an attack, a malicious site gains access, ",NaN,Fix javadoc doclint HTML warnings
1654,,['gson/assembly-descriptor.xml'],"@@ -1,21 +0,0 @@
-<assembly>
-  <id>release</id>
-  <formats>
-    <format>zip</format>
-  </formats>
-  <fileSets>
-    <fileSet>
-      <includes>
-        <include>README*</include>
-        <include>LICENSE*</include>
-      </includes>
-    </fileSet>
-    <fileSet>
-      <directory>target</directory>
-      <outputDirectory></outputDirectory>
-      <includes>
-        <include>gson-*.jar</include>
-      </includes>
-    </fileSet>
-  </fileSets>
-</assembly>
\ No newline at end of file, ","It appears `gson/docs/javadocs` has been generated and its content is not used anymore, but please let me know if this is incorrect.",Remove unused files
1655,,"['README.md', 'gson/pom.xml', 'pom.xml']","@@ -43,7 +43,7 @@ Maven:
 Please use the 'gson' tag on StackOverflow or the [google-gson Google group](https://groups.google.com/group/google-gson) to discuss Gson or to post questions.
 
 ### Related Content Created by Third Parties
-  * [Gson Tutorial](http://www.studytrails.com/java/json/java-google-json-introduction.jsp) by `StudyTrails`
+  * [Gson Tutorial](https://www.studytrails.com/java/json/java-google-json-introduction/) by `StudyTrails`
   * [Gson Tutorial Series](https://futurestud.io/tutorials/gson-getting-started-with-java-json-serialization-deserialization) by `Future Studio`
   * [Gson API Report](https://abi-laboratory.pro/java/tracker/timeline/gson/)
 , @@ -27,7 +27,7 @@
           <includePackageNames>com.google.gson</includePackageNames>
           <excludePackageNames>com.google.gson.internal:com.google.gson.internal.bind</excludePackageNames>
           <links>
-            <link>http://docs.oracle.com/javase/6/docs/api/</link>
+            <link>https://docs.oracle.com/javase/6/docs/api/</link>
           </links>
         </configuration>
       </plugin>, @@ -42,7 +42,7 @@
   <licenses>
     <license>
       <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+      <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>
     </license>
   </licenses>
 , ",NaN,Change links from HTTP to HTTPS
1685,Simon Legner,['UserGuide.md'],"@@ -301,11 +301,12 @@ This approach is practical only if the array appears as a top-level element or i
 
 ### <a name=""TOC-Built-in-Serializers-and-Deserializers""></a>Built-in Serializers and Deserializers
 
-Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
-Here is a list of such classes:
+Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate, for instance
 
-1. `java.net.URL` to match it with strings like `""https://github.com/google/gson/""`
-2. `java.net.URI` to match it with strings like `""/google/gson/""`
+* `java.net.URL` to match it with strings like `""https://github.com/google/gson/""`
+* `java.net.URI` to match it with strings like `""/google/gson/""`
+
+For many more, see the internal class [`TypeAdapters`](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java).
 
 You can also find source code for some commonly used classes such as JodaTime at [this page](https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1).
 , ","In the section Built-in Serializers and Deserializers,
* clarify that URL, URI are only examples
* link to TypeAdapters class",doc(UserGuide): mention TypeAdapters class
1687,,['gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java'],"@@ -15,9 +15,25 @@
     @Rule
     public final ExpectedException exception = ExpectedException.none();
 
+    private static TimeZone utcTimeZone() {
+        return TimeZone.getTimeZone(""UTC"");
+    }
+
+    private static GregorianCalendar createUtcCalendar() {
+        TimeZone utc = utcTimeZone();
+        GregorianCalendar calendar = new GregorianCalendar(utc);
+        // Calendar was created with current time, must clear it
+        calendar.clear();
+        return calendar;
+    }
+
     @Test
     public void testDateFormatString() {
-        Date date = new GregorianCalendar(2018, Calendar.JUNE, 25).getTime();
+        GregorianCalendar calendar = new GregorianCalendar(utcTimeZone(), Locale.US);
+        // Calendar was created with current time, must clear it
+        calendar.clear();
+        calendar.set(2018, Calendar.JUNE, 25);
+        Date date = calendar.getTime();
         String dateStr = ISO8601Utils.format(date);
         String expectedDate = ""2018-06-25"";
         assertEquals(expectedDate, dateStr.substring(0, expectedDate.length()));
@@ -51,51 +67,28 @@ public void testDateParseWithDefaultTimezone() throws ParseException {
 
     @Test
     public void testDateParseWithTimezone() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T00:00:00-03:00"";
-            Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
-            Date expectedDate = new GregorianCalendar(2018, Calendar.JUNE, 25, 3, 0).getTime();
-            assertEquals(expectedDate, date);
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T00:00:00-03:00"";
+        Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
+        GregorianCalendar calendar = createUtcCalendar();
+        calendar.set(2018, Calendar.JUNE, 25, 3, 0);
+        Date expectedDate = calendar.getTime();
+        assertEquals(expectedDate, date);
     }
 
     @Test
     public void testDateParseSpecialTimezone() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T00:02:00-02:58"";
-            Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
-            Date expectedDate = new GregorianCalendar(2018, Calendar.JUNE, 25, 3, 0).getTime();
-            assertEquals(expectedDate, date);
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T00:02:00-02:58"";
+        Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
+        GregorianCalendar calendar = createUtcCalendar();
+        calendar.set(2018, Calendar.JUNE, 25, 3, 0);
+        Date expectedDate = calendar.getTime();
+        assertEquals(expectedDate, date);
     }
 
     @Test
     public void testDateParseInvalidTime() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T61:60:62-03:00"";
-            exception.expect(ParseException.class);
-            ISO8601Utils.parse(dateStr, new ParsePosition(0));
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T61:60:62-03:00"";
+        exception.expect(ParseException.class);
+        ISO8601Utils.parse(dateStr, new ParsePosition(0));
     }
 }, ","Previously `ISO8601UtilsTest.testDateFormatString()` would fail on systems where the time zone is UTC+X because `getTime()` returned ""2018-06-24"" for them.

Additionally the tests which previously changed the system locale and time zone have been rewritten to create a UTC calendar instead. Setting locale seems to not be necessary because `ISO8601Utils.parse(...)` does not do that either.",Fix ISO8601UtilsTest failing on systems with UTC+X
1693,Marius Volkhart,['examples/android-proguard-example/proguard.cfg'],"@@ -15,7 +15,7 @@
 
 # Prevent proguard from stripping interface information from TypeAdapter, TypeAdapterFactory,
 # JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
--keep class * implements com.google.gson.TypeAdapter
+-keep class * extends com.google.gson.TypeAdapter
 -keep class * implements com.google.gson.TypeAdapterFactory
 -keep class * implements com.google.gson.JsonSerializer
 -keep class * implements com.google.gson.JsonDeserializer, ","TypeAdapter is an abstract class, and R8 warns about this during the build.",Update proguard.cfg
1707,,"['.github/dependabot.yml', 'CHANGELOG.md', 'README.md', 'UserGuide.md', 'codegen/pom.xml', 'examples/android-proguard-example/proguard.cfg', 'extras/pom.xml', 'gson/pom.xml', 'gson/src/main/java/com/google/gson/JsonStreamParser.java', 'gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java', 'gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java', 'gson/src/test/java/com/google/gson/JsonArrayTest.java', 'gson/src/test/java/com/google/gson/functional/EnumWithObfuscatedTest.java', 'gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java', 'gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java', 'gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java', 'gson/src/test/resources/testcases-proguard.conf', 'metrics/pom.xml', 'pom.xml', 'proto/pom.xml']","@@ -0,0 +1,6 @@
+version: 2
+updates:
+  - package-ecosystem: ""maven""
+    directory: ""/""
+    schedule:
+      interval: ""daily"", @@ -1,6 +1,22 @@
 Change Log
 ==========
 
+## Version 2.8.8
+
+* Fixed issue with recursive types (#1390).
+* Better behaviour with Java 9+ and `Unsafe` if there is a security manager (#1712).
+* `EnumTypeAdapter` now works better when ProGuard has obfuscated enum fields (#1495).
+
+## Version 2.8.7
+
+* Fixed `ISO8601UtilsTest` failing on systems with UTC+X.
+* Improved javadoc for `JsonStreamParser`.
+* Updated proguard.cfg (#1693).
+* Fixed `IllegalStateException` in `JsonTreeWriter` (#1592).
+* Added `JsonArray.isEmpty()` (#1640).
+* Added new test cases (#1638).
+* Fixed OSGi metadata generation to work on JavaSE < 9 (#1603).
+
 ## Version 2.8.6
 _2019-10-04_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.5...gson-parent-2.8.6)
  * Added static methods `JsonParser.parseString` and `JsonParser.parseReader` and deprecated instance method `JsonParser.parse`, @@ -17,7 +17,7 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
 Gradle:
 ```gradle
 dependencies {
-  implementation 'com.google.code.gson:gson:2.8.6'
+  implementation 'com.google.code.gson:gson:2.8.8'
 }
 ```
 
@@ -26,7 +26,7 @@ Maven:
 <dependency>
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
-  <version>2.8.6</version>
+  <version>2.8.8</version>
 </dependency>
 ```
 , @@ -74,7 +74,7 @@ The Gson instance does not maintain any state while invoking Json operations. So
 ## <a name=""TOC-Gson-With-Gradle""></a>Using Gson with Gradle/Android
 ```
 dependencies {
-    implementation 'com.google.code.gson:gson:2.8.6'
+    implementation 'com.google.code.gson:gson:2.8.8'
 }
 ```
 ## <a name=""TOC-Gson-With-Maven""></a>Using Gson with Maven
@@ -86,7 +86,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.8.6</version>
+      <version>2.8.8</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>, @@ -40,7 +40,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, @@ -15,7 +15,7 @@
 
 # Prevent proguard from stripping interface information from TypeAdapter, TypeAdapterFactory,
 # JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)
--keep class * implements com.google.gson.TypeAdapter
+-keep class * extends com.google.gson.TypeAdapter
 -keep class * implements com.google.gson.TypeAdapterFactory
 -keep class * implements com.google.gson.JsonSerializer
 -keep class * implements com.google.gson.JsonDeserializer
@@ -25,4 +25,8 @@
   @com.google.gson.annotations.SerializedName <fields>;
 }
 
+# Retain generic signatures of TypeToken and its subclasses with R8 version 3.0 and higher.
+-keep,allowobfuscation,allowshrinking class com.google.gson.reflect.TypeToken
+-keep,allowobfuscation,allowshrinking class * extends com.google.gson.reflect.TypeToken
+
 ##---------------End: proguard configuration for Gson  ----------, @@ -51,7 +51,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, @@ -4,7 +4,7 @@
   <parent>
     <groupId>com.google.code.gson</groupId>
     <artifactId>gson-parent</artifactId>
-    <version>2.8.7-SNAPSHOT</version>
+    <version>2.8.9-SNAPSHOT</version>
   </parent>
 
   <artifactId>gson</artifactId>
@@ -16,6 +16,12 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.github.wvengen</groupId>
+      <artifactId>proguard-maven-plugin</artifactId>
+      <version>2.4.0</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
  
   <build>
@@ -34,7 +40,7 @@
       <plugin>
         <groupId>biz.aQute.bnd</groupId>
         <artifactId>bnd-maven-plugin</artifactId>
-        <version>4.0.0</version>
+        <version>5.3.0</version>
         <executions>
           <execution>
             <goals>
@@ -69,6 +75,87 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>com.coderplus.maven.plugins</groupId>
+        <artifactId>copy-rename-maven-plugin</artifactId>
+        <version>1.0.1</version>
+        <executions>
+          <execution>
+            <id>pre-obfuscate-class</id>
+            <phase>process-test-classes</phase>
+            <goals>
+              <goal>rename</goal>
+            </goals>
+            <configuration>
+              <fileSets>
+                <fileSet>
+                  <sourceFile>${project.build.directory}/test-classes/com/google/gson/functional/EnumWithObfuscatedTest.class</sourceFile>
+                  <destinationFile>${project.build.directory}/test-classes-obfuscated-injar/com/google/gson/functional/EnumWithObfuscatedTest.class</destinationFile>
+                </fileSet>
+                <fileSet>
+                  <sourceFile>${project.build.directory}/test-classes/com/google/gson/functional/EnumWithObfuscatedTest$Gender.class</sourceFile>
+                  <destinationFile>${project.build.directory}/test-classes-obfuscated-injar/com/google/gson/functional/EnumWithObfuscatedTest$Gender.class</destinationFile>
+                </fileSet>
+              </fileSets>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>com.github.wvengen</groupId>
+        <artifactId>proguard-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <phase>process-test-classes</phase>
+            <goals><goal>proguard</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <proguardVersion>6.2.2</proguardVersion>
+          <obfuscate>true</obfuscate>
+          <injar>test-classes-obfuscated-injar</injar>
+          <outjar>test-classes-obfuscated-outjar</outjar>
+          <inFilter>**/*.class</inFilter>
+          <proguardInclude>${basedir}/src/test/resources/testcases-proguard.conf</proguardInclude>
+          <libs>
+            <lib>${project.build.directory}/classes</lib>
+            <lib>${java.home}/jmods/java.base.jmod</lib>
+          </libs>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>net.sf.proguard</groupId>
+            <artifactId>proguard-base</artifactId>
+            <version>6.2.2</version>
+            <scope>runtime</scope>
+          </dependency>
+        </dependencies>
+      </plugin>
+      <plugin>
+        <artifactId>maven-resources-plugin</artifactId>
+        <version>3.2.0</version>
+        <executions>
+          <execution>
+            <id>post-obfuscate-class</id>
+            <phase>process-test-classes</phase>
+            <goals>
+              <goal>copy-resources</goal>
+            </goals>
+            <configuration>
+              <outputDirectory>${project.build.directory}/test-classes/com/google/gson/functional</outputDirectory>
+              <resources>
+                <resource>
+                  <directory>${project.build.directory}/test-classes-obfuscated-outjar/com/google/gson/functional</directory>
+                  <includes>
+                    <include>EnumWithObfuscatedTest.class</include>
+                    <include>EnumWithObfuscatedTest$Gender.class</include>
+                  </includes>
+                </resource>
+              </resources>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>, @@ -29,8 +29,9 @@
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
- * asynchronously.
- * 
+ * asynchronously. The JSON data is parsed in lenient mode, see also
+ * {@link JsonReader#setLenient(boolean)}.
+ *
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
  * synchronization. For example:
@@ -72,10 +73,12 @@ public JsonStreamParser(Reader reader) {
   }
   
   /**
-   * Returns the next available {@link JsonElement} on the reader. Null if none available.
-   * 
-   * @return the next available {@link JsonElement} on the reader. Null if none available.
-   * @throws JsonParseException if the incoming stream is malformed JSON.
+   * Returns the next available {@link JsonElement} on the reader. Throws a
+   * {@link NoSuchElementException} if no element is available.
+   *
+   * @return the next available {@code JsonElement} on the reader.
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
+   * @throws NoSuchElementException if no {@code JsonElement} is available.
    * @since 1.4
    */
   public JsonElement next() throws JsonParseException {
@@ -97,6 +100,7 @@ public JsonElement next() throws JsonParseException {
   /**
    * Returns true if a {@link JsonElement} is available on the input for consumption
    * @return true if a {@link JsonElement} is available on the input, false otherwise
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
    * @since 1.4
    */
   public boolean hasNext() {, @@ -25,7 +25,12 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Properties;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
 import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
@@ -334,52 +339,62 @@ public static Type getCollectionElementType(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable<?>>());
+
+    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Collection<TypeVariable<?>> visitedTypeVariables) {
+                              Map<TypeVariable<?>, Type> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
+    TypeVariable<?> resolving = null;
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        if (visitedTypeVariables.contains(typeVariable)) {
+        Type previouslyResolved = visitedTypeVariables.get(typeVariable);
+        if (previouslyResolved != null) {
           // cannot reduce due to infinite recursion
-          return toResolve;
-        } else {
-          visitedTypeVariables.add(typeVariable);
+          return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;
+        }
+
+        // Insert a placeholder to mark the fact that we are in the process of resolving this type
+        visitedTypeVariables.put(typeVariable, Void.TYPE);
+        if (resolving == null) {
+          resolving = typeVariable;
         }
+
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
-          return toResolve;
+          break;
         }
 
       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
+        break;
 
       } else if (toResolve instanceof GenericArrayType) {
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
+        break;
 
       } else if (toResolve instanceof ParameterizedType) {
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
-        boolean changed = newOwnerType != ownerType;
+        boolean changed = !equal(newOwnerType, ownerType);
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
-          if (resolvedTypeArgument != args[t]) {
+          if (!equal(resolvedTypeArgument, args[t])) {
             if (!changed) {
               args = args.clone();
               changed = true;
@@ -388,9 +403,10 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv
           }
         }
 
-        return changed
+        toResolve = changed
             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
             : original;
+        break;
 
       } else if (toResolve instanceof WildcardType) {
         WildcardType original = (WildcardType) toResolve;
@@ -400,20 +416,28 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv
         if (originalLowerBound.length == 1) {
           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
           if (lowerBound != originalLowerBound[0]) {
-            return supertypeOf(lowerBound);
+            toResolve = supertypeOf(lowerBound);
+            break;
           }
         } else if (originalUpperBound.length == 1) {
           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
           if (upperBound != originalUpperBound[0]) {
-            return subtypeOf(upperBound);
+            toResolve = subtypeOf(upperBound);
+            break;
           }
         }
-        return original;
+        toResolve = original;
+        break;
 
       } else {
-        return toResolve;
+        break;
       }
     }
+    // ensure that any in-process resolution gets updated with the final result
+    if (resolving != null) {
+      visitedTypeVariables.put(resolving, toResolve);
+    }
+    return toResolve;
   }
 
   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {, @@ -17,12 +17,15 @@
 package com.google.gson.internal.bind;
 
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Calendar;
@@ -753,9 +756,20 @@ public void write(JsonWriter out, Locale value) throws IOException {
 
     public EnumTypeAdapter(Class<T> classOfT) {
       try {
-        for (T constant : classOfT.getEnumConstants()) {
+        for (final Field field : classOfT.getDeclaredFields()) {
+          if (!field.isEnumConstant()) {
+            continue;
+          }
+          AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            @Override public Void run() {
+              field.setAccessible(true);
+              return null;
+            }
+          });
+          @SuppressWarnings(""unchecked"")
+          T constant = (T)(field.get(null));
           String name = constant.name();
-          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
+          SerializedName annotation = field.getAnnotation(SerializedName.class);
           if (annotation != null) {
             name = annotation.value();
             for (String alternate : annotation.alternate()) {
@@ -765,7 +779,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
           nameToConstant.put(name, constant);
           constantToName.put(constant, name);
         }
-      } catch (NoSuchFieldException e) {
+      } catch (IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }, @@ -79,7 +79,7 @@ private static Object getUnsafeInstance() {
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField(""override"");
-    } catch (NoSuchFieldException e) {
+    } catch (Exception e) {
       return null;
     }
   }, @@ -16,9 +16,8 @@
 
 package com.google.gson;
 
-import junit.framework.TestCase;
-
 import com.google.gson.common.MoreAsserts;
+import junit.framework.TestCase;
 
 /**
  * @author Jesse Wilson
@@ -99,4 +98,68 @@ public void testDeepCopy() {
     assertEquals(1, original.get(0).getAsJsonArray().size());
     assertEquals(0, copy.get(0).getAsJsonArray().size());
   }
+
+  public void testFailedGetArrayValues() {
+    JsonArray jsonArray = new JsonArray();
+    jsonArray.add(JsonParser.parseString(""{"" + ""\""key1\"":\""value1\"","" + ""\""key2\"":\""value2\"","" + ""\""key3\"":\""value3\"","" + ""\""key4\"":\""value4\"""" + ""}""));
+    try {
+      jsonArray.getAsBoolean();
+      fail(""expected getBoolean to fail"");
+    } catch (UnsupportedOperationException e) {
+      assertEquals(""Expected an exception message"",
+              ""JsonObject"", e.getMessage());
+    }
+    try {
+      jsonArray.get(-1);
+      fail(""expected get to fail"");
+    } catch (IndexOutOfBoundsException e) {
+      assertEquals(""Expected an exception message"",
+              ""Index -1 out of bounds for length 1"", e.getMessage());
+    }
+    try {
+      jsonArray.getAsString();
+      fail(""expected getString to fail"");
+    } catch (UnsupportedOperationException e) {
+      assertEquals(""Expected an exception message"",
+              ""JsonObject"", e.getMessage());
+    }
+
+    jsonArray.remove(0);
+    jsonArray.add(""hello"");
+    try {
+      jsonArray.getAsDouble();
+      fail(""expected getDouble to fail"");
+    } catch (NumberFormatException e) {
+      assertEquals(""Expected an exception message"",
+              ""For input string: \""hello\"""", e.getMessage());
+    }
+    try {
+      jsonArray.getAsInt();
+      fail(""expected getInt to fail"");
+    } catch (NumberFormatException e) {
+      assertEquals(""Expected an exception message"",
+              ""For input string: \""hello\"""", e.getMessage());
+    }
+    try {
+      jsonArray.get(0).getAsJsonArray();
+      fail(""expected getJSONArray to fail"");
+    } catch (IllegalStateException e) {
+      assertEquals(""Expected an exception message"",
+              ""Not a JSON Array: \""hello\"""", e.getMessage());
+    }
+    try {
+      jsonArray.getAsJsonObject();
+      fail(""expected getJSONObject to fail"");
+    } catch (IllegalStateException e) {
+      assertEquals(""Expected an exception message"",
+              ""Not a JSON Object: [\""hello\""]"", e.getMessage());
+    }
+    try {
+      jsonArray.getAsLong();
+      fail(""expected getLong to fail"");
+    } catch (NumberFormatException e) {
+      assertEquals(""Expected an exception message"",
+              ""For input string: \""hello\"""", e.getMessage());
+    }
+  }
 }, @@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.functional;
+
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+
+import junit.framework.TestCase;
+
+/**
+ * Functional tests for enums with Proguard.
+ *
+ * @author Young Cha
+ */
+public class EnumWithObfuscatedTest extends TestCase {
+  private Gson gson;
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    gson = new Gson();
+  }
+
+  public enum Gender {
+    @SerializedName(""MAIL"")
+    MALE,
+
+    @SerializedName(""FEMAIL"")
+    FEMALE
+  }
+
+  public void testEnumClassWithObfuscated() {
+    for (Gender enumConstant: Gender.class.getEnumConstants()) {
+      try {
+        Gender.class.getField(enumConstant.name());
+        fail(""Enum is not obfuscated"");
+      } catch (NoSuchFieldException ignore) {
+      }
+    }
+
+    assertEquals(Gender.MALE, gson.fromJson(""\""MAIL\"""", Gender.class));
+    assertEquals(""\""MAIL\"""", gson.toJson(Gender.MALE, Gender.class));
+  }
+}, @@ -0,0 +1,55 @@
+package com.google.gson.functional;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import org.junit.Before;
+import org.junit.Test;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
+
+/**
+ * This test covers the scenario described in #1390 where a type variable needs to be used
+ * by a type definition multiple times.  Both type variable references should resolve to the
+ * same underlying concrete type.
+ */
+public class ReusedTypeVariablesFullyResolveTest {
+
+  private Gson gson;
+
+  @Before
+  public void setUp() {
+    gson = new GsonBuilder().create();
+  }
+
+  @SuppressWarnings(""ConstantConditions"") // The instances were being unmarshaled as Strings instead of TestEnums
+  @Test
+  public void testGenericsPreservation() {
+    TestEnumSetCollection withSet = gson.fromJson(""{\""collection\"":[\""ONE\"",\""THREE\""]}"", TestEnumSetCollection.class);
+    Iterator<TestEnum> iterator = withSet.collection.iterator();
+    assertNotNull(withSet);
+    assertNotNull(withSet.collection);
+    assertEquals(2, withSet.collection.size());
+    TestEnum first = iterator.next();
+    TestEnum second = iterator.next();
+
+    assertTrue(first instanceof TestEnum);
+    assertTrue(second instanceof TestEnum);
+  }
+
+  enum TestEnum { ONE, TWO, THREE }
+
+  private static class TestEnumSetCollection extends SetCollection<TestEnum> {}
+
+  private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}
+
+  private static class BaseCollection<U, C extends Collection<U>>
+  {
+    public C collection;
+  }
+
+}, @@ -15,9 +15,25 @@
     @Rule
     public final ExpectedException exception = ExpectedException.none();
 
+    private static TimeZone utcTimeZone() {
+        return TimeZone.getTimeZone(""UTC"");
+    }
+
+    private static GregorianCalendar createUtcCalendar() {
+        TimeZone utc = utcTimeZone();
+        GregorianCalendar calendar = new GregorianCalendar(utc);
+        // Calendar was created with current time, must clear it
+        calendar.clear();
+        return calendar;
+    }
+
     @Test
     public void testDateFormatString() {
-        Date date = new GregorianCalendar(2018, Calendar.JUNE, 25).getTime();
+        GregorianCalendar calendar = new GregorianCalendar(utcTimeZone(), Locale.US);
+        // Calendar was created with current time, must clear it
+        calendar.clear();
+        calendar.set(2018, Calendar.JUNE, 25);
+        Date date = calendar.getTime();
         String dateStr = ISO8601Utils.format(date);
         String expectedDate = ""2018-06-25"";
         assertEquals(expectedDate, dateStr.substring(0, expectedDate.length()));
@@ -51,51 +67,28 @@ public void testDateParseWithDefaultTimezone() throws ParseException {
 
     @Test
     public void testDateParseWithTimezone() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T00:00:00-03:00"";
-            Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
-            Date expectedDate = new GregorianCalendar(2018, Calendar.JUNE, 25, 3, 0).getTime();
-            assertEquals(expectedDate, date);
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T00:00:00-03:00"";
+        Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
+        GregorianCalendar calendar = createUtcCalendar();
+        calendar.set(2018, Calendar.JUNE, 25, 3, 0);
+        Date expectedDate = calendar.getTime();
+        assertEquals(expectedDate, date);
     }
 
     @Test
     public void testDateParseSpecialTimezone() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T00:02:00-02:58"";
-            Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
-            Date expectedDate = new GregorianCalendar(2018, Calendar.JUNE, 25, 3, 0).getTime();
-            assertEquals(expectedDate, date);
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T00:02:00-02:58"";
+        Date date = ISO8601Utils.parse(dateStr, new ParsePosition(0));
+        GregorianCalendar calendar = createUtcCalendar();
+        calendar.set(2018, Calendar.JUNE, 25, 3, 0);
+        Date expectedDate = calendar.getTime();
+        assertEquals(expectedDate, date);
     }
 
     @Test
     public void testDateParseInvalidTime() throws ParseException {
-        TimeZone defaultTimeZone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone(""UTC""));
-        Locale defaultLocale = Locale.getDefault();
-        Locale.setDefault(Locale.US);
-        try {
-            String dateStr = ""2018-06-25T61:60:62-03:00"";
-            exception.expect(ParseException.class);
-            ISO8601Utils.parse(dateStr, new ParsePosition(0));
-        } finally {
-            TimeZone.setDefault(defaultTimeZone);
-            Locale.setDefault(defaultLocale);
-        }
+        String dateStr = ""2018-06-25T61:60:62-03:00"";
+        exception.expect(ParseException.class);
+        ISO8601Utils.parse(dateStr, new ParsePosition(0));
     }
 }, @@ -15,10 +15,12 @@
  */
 package com.google.gson.internal.reflect;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.lang.reflect.Field;
+import java.security.Permission;
 
 import org.junit.Test;
 
@@ -41,6 +43,30 @@ public void testMakeAccessibleWithUnsafe() throws Exception {
     }
   }
 
+  @Test
+  public void testMakeAccessibleWithRestrictiveSecurityManager() throws Exception {
+    final Permission accessDeclaredMembers = new RuntimePermission(""accessDeclaredMembers"");
+    final SecurityManager original = System.getSecurityManager();
+    SecurityManager restrictiveManager = new SecurityManager() {
+      @Override
+      public void checkPermission(Permission perm) {
+        if (accessDeclaredMembers.equals(perm)) {
+          throw new SecurityException(""nope"");
+        }
+      }
+    };
+    System.setSecurityManager(restrictiveManager);
+
+    try {
+      UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+      Field field = ClassWithPrivateFinalFields.class.getDeclaredField(""a"");
+      assertFalse(""override field should have been inaccessible"", accessor.makeAccessibleWithUnsafe(field));
+      accessor.makeAccessible(field);
+    } finally {
+      System.setSecurityManager(original);
+    }
+  }
+
   @SuppressWarnings(""unused"")
   private static final class ClassWithPrivateFinalFields {
     private final String a;, @@ -0,0 +1,20 @@
+# Options from Android Gradle Plugins
+# https://android.googlesource.com/platform/tools/base/+/refs/heads/studio-master-dev/build-system/gradle-core/src/main/resources/com/android/build/gradle
+-optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/*
+-optimizationpasses 5
+-allowaccessmodification
+-keepattributes *Annotation*,Signature,InnerClasses,EnclosingMethod
+-keepclassmembers enum * {
+  public static **[] values();
+  public static ** valueOf(java.lang.String);
+}
+
+-keep enum com.google.gson.functional.EnumWithObfuscatedTest$Gender
+-keep class com.google.gson.functional.EnumWithObfuscatedTest {
+  public void test*();
+  protected void setUp();
+}
+
+-dontwarn com.google.gson.functional.EnumWithObfuscatedTest
+-dontwarn junit.framework.TestCase
+, @@ -51,7 +51,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, @@ -11,7 +11,7 @@
 
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson-parent</artifactId>
-  <version>2.8.7-SNAPSHOT</version>
+  <version>2.8.9-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Gson Parent</name>
@@ -51,7 +51,7 @@
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>4.12</version>
+        <version>4.13.2</version>
         <scope>test</scope>
       </dependency>
     </dependencies>
@@ -97,7 +97,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
+          <version>3.3.0</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
@@ -106,7 +106,7 @@
         <plugin>
           <groupId>org.apache.felix</groupId>
           <artifactId>maven-bundle-plugin</artifactId>
-          <version>3.3.0</version>
+          <version>5.1.2</version>
           <inherited>true</inherited>
         </plugin>
       </plugins>
@@ -117,10 +117,15 @@
         <artifactId>maven-release-plugin</artifactId>
         <version>2.5.3</version>
         <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-api</artifactId>
+            <version>1.11.3</version>
+          </dependency>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9.5</version>
+            <version>1.11.3</version>
           </dependency>
         </dependencies>
         <configuration>, @@ -76,7 +76,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>4.12</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
     , ","Note: This is based on #1656
Fixes #1629

Makes the dependency on the `java.sql` module optional. If its classes are present at runtime, the respective type adapters will be used, otherwise Gson will not try to load the classes and will therefore not fail with a `ClassNotFoundException` anymore. The entry point for all SQL type adapters is now `SqlTypesSupport`.

I am however, not that familiar with the module system so it would be good if others who are more familiar with it can check if this is a sane implementation.

Especially #1500 (@Degubi) is confusing me because from what I understood about the JPMS `requires transitive` is only so modules depending on Gson would also be ""reading"" `java.sql`, which however makes no sense because Gson does not expose these types publicly anywhere, so it should not provide them transitively. To my understanding `requires` should have been enough to require `java.sql` being present at runtime, however based on the `ClassNotFoundException` reports this was not the case?
Or are they using tools (as it is the case [here](https://stackoverflow.com/q/57222110) which break the module system)? Though that would be a rather common issue then, see the question [""java.sql.Time exception""](https://stackoverflow.com/q/50877484).

Also pinging @nicolaiparlog, if you have any spare time, any hints regarding the JPMS would be appreciated :)
Sorry to pester you in case you don't have any time.",Make dependency on java.sql optional
1712,richard hernandez,"['gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java', 'gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java']","@@ -79,7 +79,7 @@ private static Object getUnsafeInstance() {
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField(""override"");
-    } catch (NoSuchFieldException e) {
+    } catch (Exception e) {
       return null;
     }
   }, @@ -15,10 +15,12 @@
  */
 package com.google.gson.internal.reflect;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.lang.reflect.Field;
+import java.security.Permission;
 
 import org.junit.Test;
 
@@ -41,6 +43,30 @@ public void testMakeAccessibleWithUnsafe() throws Exception {
     }
   }
 
+  @Test
+  public void testMakeAccessibleWithRestrictiveSecurityManager() throws Exception {
+    final Permission accessDeclaredMembers = new RuntimePermission(""accessDeclaredMembers"");
+    final SecurityManager original = System.getSecurityManager();
+    SecurityManager restrictiveManager = new SecurityManager() {
+      @Override
+      public void checkPermission(Permission perm) {
+        if (accessDeclaredMembers.equals(perm)) {
+          throw new SecurityException(""nope"");
+        }
+      }
+    };
+    System.setSecurityManager(restrictiveManager);
+
+    try {
+      UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+      Field field = ClassWithPrivateFinalFields.class.getDeclaredField(""a"");
+      assertFalse(""override field should have been inaccessible"", accessor.makeAccessibleWithUnsafe(field));
+      accessor.makeAccessible(field);
+    } finally {
+      System.setSecurityManager(original);
+    }
+  }
+
   @SuppressWarnings(""unused"")
   private static final class ClassWithPrivateFinalFields {
     private final String a;, ","I'm the lucky owner of a post-jigsaw Java platform that has restrictive security manager installed. Failing to catch the `SecurityException` thrown by a cross-classloader `getDeclaredField` call in `UnsafeReflectionAllocator::getOverrideField` prevents any Gson instances from being created.

I'm hoping the fallback behavior in this class will be enough for us to use Gson without having to loosen our security policy.",Fix fallback behavior of UnsafeReflectionAllocator when AccessibleObject isn't so accessible
1786,,['gson/src/main/java/com/google/gson/JsonStreamParser.java'],"@@ -29,8 +29,9 @@
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
- * asynchronously.
- * 
+ * asynchronously. The JSON data is parsed in lenient mode, see also
+ * {@link JsonReader#setLenient(boolean)}.
+ *
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
  * synchronization. For example:
@@ -72,10 +73,12 @@ public JsonStreamParser(Reader reader) {
   }
   
   /**
-   * Returns the next available {@link JsonElement} on the reader. Null if none available.
-   * 
-   * @return the next available {@link JsonElement} on the reader. Null if none available.
-   * @throws JsonParseException if the incoming stream is malformed JSON.
+   * Returns the next available {@link JsonElement} on the reader. Throws a
+   * {@link NoSuchElementException} if no element is available.
+   *
+   * @return the next available {@code JsonElement} on the reader.
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
+   * @throws NoSuchElementException if no {@code JsonElement} is available.
    * @since 1.4
    */
   public JsonElement next() throws JsonParseException {
@@ -97,6 +100,7 @@ public JsonElement next() throws JsonParseException {
   /**
    * Returns true if a {@link JsonElement} is available on the input for consumption
    * @return true if a {@link JsonElement} is available on the input, false otherwise
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
    * @since 1.4
    */
   public boolean hasNext() {, ",NaN,Improve incorrect JsonStreamParser doc
1800,,['extras/pom.xml'],"@@ -51,7 +51,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, ","Bumps [junit](https://github.com/junit-team/junit4) from 3.8.2 to 4.13.1.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/releases"">junit's releases</a>.</em></p>
<blockquote>
<h2>JUnit 4.13.1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.1.md"">release notes</a> for details.</p>
<h2>JUnit 4.13</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.md"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.12</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 2</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.12 Beta 1</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.11</h2>
<p>No release notes provided.</p>
</blockquote>
</details>
<details>
<summary>Changelog</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.13.1.md"">junit's changelog</a>.</em></p>
<blockquote>
<h2>Summary of changes in version 4.13.1</h2>
<h1>Rules</h1>
<h3>Security fix: <code>TemporaryFolder</code> now limits access to temporary folders on Java 1.7 or later</h3>
<p>A local information disclosure vulnerability in <code>TemporaryFolder</code> has been fixed. See the published <a href=""https://github.com/junit-team/junit4/security/advisories/GHSA-269g-pwp5-87pp"">security advisory</a> for details.</p>
<h1>Test Runners</h1>
<h3>[Pull request <a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1669"">#1669</a>:](<a href=""https://github-redirect.dependabot.com/junit-team/junit/pull/1669"">junit-team/junit#1669</a>) Make <code>FrameworkField</code> constructor public</h3>
<p>Prior to this change, custom runners could make <code>FrameworkMethod</code> instances, but not <code>FrameworkField</code> instances. This small change allows for both now, because <code>FrameworkField</code>'s constructor has been promoted from package-private to public.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/junit-team/junit4/commit/1b683f4ec07bcfa40149f086d32240f805487e66""><code>1b683f4</code></a> [maven-release-plugin] prepare release r4.13.1</li>
<li><a href=""https://github.com/junit-team/junit4/commit/ce6ce3aadc070db2902698fe0d3dc6729cd631f2""><code>ce6ce3a</code></a> Draft 4.13.1 release notes</li>
<li><a href=""https://github.com/junit-team/junit4/commit/c29dd8239d6b353e699397eb090a1fd27411fa24""><code>c29dd82</code></a> Change version to 4.13.1-SNAPSHOT</li>
<li><a href=""https://github.com/junit-team/junit4/commit/1d174861f0b64f97ab0722bb324a760bfb02f567""><code>1d17486</code></a> Add a link to assertThrows in exception testing</li>
<li><a href=""https://github.com/junit-team/junit4/commit/543905df72ff10364b94dda27552efebf3dd04e9""><code>543905d</code></a> Use separate line for annotation in Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/510e906b391e7e46a346e1c852416dc7be934944""><code>510e906</code></a> Add sub headlines to class Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae""><code>610155b</code></a> Merge pull request from GHSA-269g-pwp5-87pp</li>
<li><a href=""https://github.com/junit-team/junit4/commit/b6cfd1e3d736cc2106242a8be799615b472c7fec""><code>b6cfd1e</code></a> Explicitly wrap float parameter for consistency (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1671"">#1671</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/a5d205c7956dbed302b3bb5ecde5ba4299f0b646""><code>a5d205c</code></a> Fix GitHub link in FAQ (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1672"">#1672</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/3a5c6b4d08f408c8ca6a8e0bae71a9bc5a8f97e8""><code>3a5c6b4</code></a> Deprecated since jdk9 replacing constructor instance of Double and Float (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1660"">#1660</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/junit-team/junit4/compare/r3.8.2...r4.13.1"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=3.8.2&new-version=4.13.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-github-dependabot-security-updates)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)
- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language
- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language
- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language
- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language

You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/google/gson/network/alerts).

</details>",Bump junit from 3.8.2 to 4.13.1 in /extras
1801,,['proto/pom.xml'],"@@ -76,7 +76,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>4.12</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
     , ","Bumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.1.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/releases"">junit's releases</a>.</em></p>
<blockquote>
<h2>JUnit 4.13.1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.1.md"">release notes</a> for details.</p>
<h2>JUnit 4.13</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.md"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/junit-team/junit4/commit/1b683f4ec07bcfa40149f086d32240f805487e66""><code>1b683f4</code></a> [maven-release-plugin] prepare release r4.13.1</li>
<li><a href=""https://github.com/junit-team/junit4/commit/ce6ce3aadc070db2902698fe0d3dc6729cd631f2""><code>ce6ce3a</code></a> Draft 4.13.1 release notes</li>
<li><a href=""https://github.com/junit-team/junit4/commit/c29dd8239d6b353e699397eb090a1fd27411fa24""><code>c29dd82</code></a> Change version to 4.13.1-SNAPSHOT</li>
<li><a href=""https://github.com/junit-team/junit4/commit/1d174861f0b64f97ab0722bb324a760bfb02f567""><code>1d17486</code></a> Add a link to assertThrows in exception testing</li>
<li><a href=""https://github.com/junit-team/junit4/commit/543905df72ff10364b94dda27552efebf3dd04e9""><code>543905d</code></a> Use separate line for annotation in Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/510e906b391e7e46a346e1c852416dc7be934944""><code>510e906</code></a> Add sub headlines to class Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae""><code>610155b</code></a> Merge pull request from GHSA-269g-pwp5-87pp</li>
<li><a href=""https://github.com/junit-team/junit4/commit/b6cfd1e3d736cc2106242a8be799615b472c7fec""><code>b6cfd1e</code></a> Explicitly wrap float parameter for consistency (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1671"">#1671</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/a5d205c7956dbed302b3bb5ecde5ba4299f0b646""><code>a5d205c</code></a> Fix GitHub link in FAQ (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1672"">#1672</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/3a5c6b4d08f408c8ca6a8e0bae71a9bc5a8f97e8""><code>3a5c6b4</code></a> Deprecated since jdk9 replacing constructor instance of Double and Float (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1660"">#1660</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/junit-team/junit4/compare/r4.12...r4.13.1"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=4.12&new-version=4.13.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-github-dependabot-security-updates)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)
- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language
- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language
- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language
- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language

You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/google/gson/network/alerts).

</details>",Bump junit from 4.12 to 4.13.1 in /proto
1802,,['codegen/pom.xml'],"@@ -40,7 +40,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, ","Bumps [junit](https://github.com/junit-team/junit4) from 3.8.2 to 4.13.1.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/releases"">junit's releases</a>.</em></p>
<blockquote>
<h2>JUnit 4.13.1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.1.md"">release notes</a> for details.</p>
<h2>JUnit 4.13</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.md"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.12</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 2</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.12 Beta 1</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.11</h2>
<p>No release notes provided.</p>
</blockquote>
</details>
<details>
<summary>Changelog</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.13.1.md"">junit's changelog</a>.</em></p>
<blockquote>
<h2>Summary of changes in version 4.13.1</h2>
<h1>Rules</h1>
<h3>Security fix: <code>TemporaryFolder</code> now limits access to temporary folders on Java 1.7 or later</h3>
<p>A local information disclosure vulnerability in <code>TemporaryFolder</code> has been fixed. See the published <a href=""https://github.com/junit-team/junit4/security/advisories/GHSA-269g-pwp5-87pp"">security advisory</a> for details.</p>
<h1>Test Runners</h1>
<h3>[Pull request <a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1669"">#1669</a>:](<a href=""https://github-redirect.dependabot.com/junit-team/junit/pull/1669"">junit-team/junit#1669</a>) Make <code>FrameworkField</code> constructor public</h3>
<p>Prior to this change, custom runners could make <code>FrameworkMethod</code> instances, but not <code>FrameworkField</code> instances. This small change allows for both now, because <code>FrameworkField</code>'s constructor has been promoted from package-private to public.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/junit-team/junit4/commit/1b683f4ec07bcfa40149f086d32240f805487e66""><code>1b683f4</code></a> [maven-release-plugin] prepare release r4.13.1</li>
<li><a href=""https://github.com/junit-team/junit4/commit/ce6ce3aadc070db2902698fe0d3dc6729cd631f2""><code>ce6ce3a</code></a> Draft 4.13.1 release notes</li>
<li><a href=""https://github.com/junit-team/junit4/commit/c29dd8239d6b353e699397eb090a1fd27411fa24""><code>c29dd82</code></a> Change version to 4.13.1-SNAPSHOT</li>
<li><a href=""https://github.com/junit-team/junit4/commit/1d174861f0b64f97ab0722bb324a760bfb02f567""><code>1d17486</code></a> Add a link to assertThrows in exception testing</li>
<li><a href=""https://github.com/junit-team/junit4/commit/543905df72ff10364b94dda27552efebf3dd04e9""><code>543905d</code></a> Use separate line for annotation in Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/510e906b391e7e46a346e1c852416dc7be934944""><code>510e906</code></a> Add sub headlines to class Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae""><code>610155b</code></a> Merge pull request from GHSA-269g-pwp5-87pp</li>
<li><a href=""https://github.com/junit-team/junit4/commit/b6cfd1e3d736cc2106242a8be799615b472c7fec""><code>b6cfd1e</code></a> Explicitly wrap float parameter for consistency (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1671"">#1671</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/a5d205c7956dbed302b3bb5ecde5ba4299f0b646""><code>a5d205c</code></a> Fix GitHub link in FAQ (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1672"">#1672</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/3a5c6b4d08f408c8ca6a8e0bae71a9bc5a8f97e8""><code>3a5c6b4</code></a> Deprecated since jdk9 replacing constructor instance of Double and Float (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1660"">#1660</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/junit-team/junit4/compare/r3.8.2...r4.13.1"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=3.8.2&new-version=4.13.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-github-dependabot-security-updates)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)
- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language
- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language
- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language
- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language

You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/google/gson/network/alerts).

</details>",Bump junit from 3.8.2 to 4.13.1 in /codegen
1804,,['metrics/pom.xml'],"@@ -51,7 +51,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <version>3.8.2</version>
+      <version>4.13.1</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, ","Bumps [junit](https://github.com/junit-team/junit4) from 3.8.2 to 4.13.1.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/releases"">junit's releases</a>.</em></p>
<blockquote>
<h2>JUnit 4.13.1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.1.md"">release notes</a> for details.</p>
<h2>JUnit 4.13</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.md"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.12</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.12.md"">release notes</a> for details.</p>
<h2>JUnit 4.12 Beta 2</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.12 Beta 1</h2>
<p>No release notes provided.</p>
<h2>JUnit 4.11</h2>
<p>No release notes provided.</p>
</blockquote>
</details>
<details>
<summary>Changelog</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.13.1.md"">junit's changelog</a>.</em></p>
<blockquote>
<h2>Summary of changes in version 4.13.1</h2>
<h1>Rules</h1>
<h3>Security fix: <code>TemporaryFolder</code> now limits access to temporary folders on Java 1.7 or later</h3>
<p>A local information disclosure vulnerability in <code>TemporaryFolder</code> has been fixed. See the published <a href=""https://github.com/junit-team/junit4/security/advisories/GHSA-269g-pwp5-87pp"">security advisory</a> for details.</p>
<h1>Test Runners</h1>
<h3>[Pull request <a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1669"">#1669</a>:](<a href=""https://github-redirect.dependabot.com/junit-team/junit/pull/1669"">junit-team/junit#1669</a>) Make <code>FrameworkField</code> constructor public</h3>
<p>Prior to this change, custom runners could make <code>FrameworkMethod</code> instances, but not <code>FrameworkField</code> instances. This small change allows for both now, because <code>FrameworkField</code>'s constructor has been promoted from package-private to public.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/junit-team/junit4/commit/1b683f4ec07bcfa40149f086d32240f805487e66""><code>1b683f4</code></a> [maven-release-plugin] prepare release r4.13.1</li>
<li><a href=""https://github.com/junit-team/junit4/commit/ce6ce3aadc070db2902698fe0d3dc6729cd631f2""><code>ce6ce3a</code></a> Draft 4.13.1 release notes</li>
<li><a href=""https://github.com/junit-team/junit4/commit/c29dd8239d6b353e699397eb090a1fd27411fa24""><code>c29dd82</code></a> Change version to 4.13.1-SNAPSHOT</li>
<li><a href=""https://github.com/junit-team/junit4/commit/1d174861f0b64f97ab0722bb324a760bfb02f567""><code>1d17486</code></a> Add a link to assertThrows in exception testing</li>
<li><a href=""https://github.com/junit-team/junit4/commit/543905df72ff10364b94dda27552efebf3dd04e9""><code>543905d</code></a> Use separate line for annotation in Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/510e906b391e7e46a346e1c852416dc7be934944""><code>510e906</code></a> Add sub headlines to class Javadoc</li>
<li><a href=""https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae""><code>610155b</code></a> Merge pull request from GHSA-269g-pwp5-87pp</li>
<li><a href=""https://github.com/junit-team/junit4/commit/b6cfd1e3d736cc2106242a8be799615b472c7fec""><code>b6cfd1e</code></a> Explicitly wrap float parameter for consistency (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1671"">#1671</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/a5d205c7956dbed302b3bb5ecde5ba4299f0b646""><code>a5d205c</code></a> Fix GitHub link in FAQ (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1672"">#1672</a>)</li>
<li><a href=""https://github.com/junit-team/junit4/commit/3a5c6b4d08f408c8ca6a8e0bae71a9bc5a8f97e8""><code>3a5c6b4</code></a> Deprecated since jdk9 replacing constructor instance of Double and Float (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1660"">#1660</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/junit-team/junit4/compare/r3.8.2...r4.13.1"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=3.8.2&new-version=4.13.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-github-dependabot-security-updates)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)
- `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language
- `@dependabot use these reviewers` will set the current reviewers as the default for future PRs for this repo and language
- `@dependabot use these assignees` will set the current assignees as the default for future PRs for this repo and language
- `@dependabot use this milestone` will set the current milestone as the default for future PRs for this repo and language

You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/google/gson/network/alerts).

</details>",Bump junit from 3.8.2 to 4.13.1 in /metrics
1888,,['pom.xml'],"@@ -106,7 +106,7 @@
         <plugin>
           <groupId>org.apache.felix</groupId>
           <artifactId>maven-bundle-plugin</artifactId>
-          <version>3.3.0</version>
+          <version>5.1.2</version>
           <inherited>true</inherited>
         </plugin>
       </plugins>, ","Bumps maven-bundle-plugin from 3.3.0 to 5.1.2.


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.felix:maven-bundle-plugin&package-manager=maven&previous-version=3.3.0&new-version=5.1.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-bundle-plugin from 3.3.0 to 5.1.2
1889,,['pom.xml'],"@@ -97,7 +97,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
+          <version>3.2.0</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>, ","Bumps [maven-javadoc-plugin](https://github.com/apache/maven-javadoc-plugin) from 2.10.4 to 3.2.0.
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/d3b77d6e1bbd079a0d5d0659a183871b3f638c53""><code>d3b77d6</code></a> [maven-release-plugin] prepare release maven-javadoc-plugin-3.2.0</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/41bc516c85cdd832a521f3acc64128533139e0af""><code>41bc516</code></a> back to 3.2.0-SNAPSHOT</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/819cf1eb954952c3a194d3973e5d416b592db1bc""><code>819cf1e</code></a> [maven-release-plugin] prepare for next development iteration</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/45f4b3e6b501ac05d99e529fc1abdaa4edf32b1b""><code>45f4b3e</code></a> [maven-release-plugin] prepare release maven-javadoc-plugin-3.2.0</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/d772fce836c44fb64bd67b103cb839c2de213bb4""><code>d772fce</code></a> MJAVADOC-610 Add IT test for multirelease jar</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/37d0ef59000410a0e33e0cd3fc48fe727ab76108""><code>37d0ef5</code></a> [MJAVADOC-638] upgrade Doxia Sitetools to 1.9.2 to remove dependency on Strut...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/528ce30dae9932c153f11b834f1e3450a06c14c6""><code>528ce30</code></a> [MJAVADOC-639] Switch to Oracle OpenJDK 11 compatible jar, see MJAVADOC-610</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/405b16dc1de312d31f8a4f31c1cf8a07db3220eb""><code>405b16d</code></a> [MJAVADOC-639] include requires static from external dependencies for all mod...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/aaa200709beef93a57af399a7247410f027c6962""><code>aaa2007</code></a> [MJAVADOC-637] make build Reproducible</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/7bfa76d3b9bdf61cb78152292420843a15b7bd76""><code>7bfa76d</code></a> [MJAVADOC-636] exclude some modules from aggregated javadoc</li>
<li>Additional commits viewable in <a href=""https://github.com/apache/maven-javadoc-plugin/compare/maven-javadoc-plugin-2.10.4...maven-javadoc-plugin-3.2.0"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.plugins:maven-javadoc-plugin&package-manager=maven&previous-version=2.10.4&new-version=3.2.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-javadoc-plugin from 2.10.4 to 3.2.0
1890,,['gson/pom.xml'],"@@ -34,7 +34,7 @@
       <plugin>
         <groupId>biz.aQute.bnd</groupId>
         <artifactId>bnd-maven-plugin</artifactId>
-        <version>4.0.0</version>
+        <version>5.3.0</version>
         <executions>
           <execution>
             <goals>, ","Bumps [bnd-maven-plugin](https://github.com/bndtools/bnd) from 4.0.0 to 5.3.0.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/bndtools/bnd/releases"">bnd-maven-plugin's releases</a>.</em></p>
<blockquote>
<h2>Bnd/Bndtools 5.3.0</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.3.0"">Release Notes</a>.</p>
<h2>Bnd/Bndtools 5.2.0</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.2.0"">Release Notes</a>.</p>
<h2>Bnd/Bndtools 5.1.2</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.1.2"">Release Notes</a>.</p>
<h2>Bnd/Bndtools 5.1.1</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.1.1"">Release Notes</a>.</p>
<h2>Bnd/Bndtools 5.1.0</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.1.0"">Release Notes</a>.</p>
<h2>Bnd/Bndtools 5.0.1</h2>
<p>Maintenance release.</p>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.0.1"">Release Notes</a>.</p>
<h2>5.0.1.RC2</h2>
<p>No release notes provided.</p>
<h2>5.0.1.RC1</h2>
<p>No release notes provided.</p>
<h2>Bnd/Bndtools 5.0.0</h2>
<p>See <a href=""https://github.com/bndtools/bnd/wiki/Changes-in-5.0.0"">Release Notes</a>.</p>
<h2>4.4.0.DEV</h2>
<p>No release notes provided.</p>
<h2>4.3.1</h2>
<p>Maintenance fix release for 4.3.0</p>
<h2>4.3.1.DEV</h2>
<p>No release notes provided.</p>
<h2>4.3.1.RC1</h2>
<p>No release notes provided.</p>
<h2>4.3.0.REL</h2>
<p>No release notes provided.</p>
<h2>4.2.0.REL</h2>
<p>No release notes provided.</p>
<h2>4.1.0.REL</h2>
<p>No release notes provided.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li>See full diff in <a href=""https://github.com/bndtools/bnd/commits"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=biz.aQute.bnd:bnd-maven-plugin&package-manager=maven&previous-version=4.0.0&new-version=5.3.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump bnd-maven-plugin from 4.0.0 to 5.3.0
1891,,['pom.xml'],"@@ -120,7 +120,7 @@
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9.5</version>
+            <version>1.11.2</version>
           </dependency>
         </dependencies>
         <configuration>, ","Bumps maven-scm-provider-gitexe from 1.9.5 to 1.11.2.


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.scm:maven-scm-provider-gitexe&package-manager=maven&previous-version=1.9.5&new-version=1.11.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-scm-provider-gitexe from 1.9.5 to 1.11.2
1892,,['pom.xml'],"@@ -51,7 +51,7 @@
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>4.12</version>
+        <version>4.13.2</version>
         <scope>test</scope>
       </dependency>
     </dependencies>, ","Bumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.2.
<details>
<summary>Release notes</summary>
<p><em>Sourced from <a href=""https://github.com/junit-team/junit4/releases"">junit's releases</a>.</em></p>
<blockquote>
<h2>JUnit 4.13.2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.2.md"">release notes</a> for details.</p>
<h2>JUnit 4.13.1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.1.md"">release notes</a> for details.</p>
<h2>JUnit 4.13</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit/blob/HEAD/doc/ReleaseNotes4.13.md"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 RC 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 3</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 2</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
<h2>JUnit 4.13 Beta 1</h2>
<p>Please refer to the <a href=""https://github.com/junit-team/junit4/wiki/4.13-Release-Notes"">release notes</a> for details.</p>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/junit-team/junit4/commit/05fe2a64f59127c02135be22f416e91260d6ede6""><code>05fe2a6</code></a> [maven-release-plugin] prepare release r4.13.2</li>
<li><a href=""https://github.com/junit-team/junit4/commit/ff57344f7171ea8b0935c4f842cacf1097266592""><code>ff57344</code></a> Add build for JDK 17-ea</li>
<li><a href=""https://github.com/junit-team/junit4/commit/02aaa01b8f74c0eb496d76685ec49fddeb311087""><code>02aaa01</code></a> Improve check that thread is stopped</li>
<li><a href=""https://github.com/junit-team/junit4/commit/e9a75f4be71a4d5a794ccd063522eea4b0f3194f""><code>e9a75f4</code></a> Merge test for exception type and message</li>
<li><a href=""https://github.com/junit-team/junit4/commit/d27ad5259228e84c235dac24cd62f974ac0a8e1d""><code>d27ad52</code></a> Rename DelegateStatement to DelegatingStatement</li>
<li><a href=""https://github.com/junit-team/junit4/commit/b83dc2e8c4ff06cf233cd347f1280bb417482985""><code>b83dc2e</code></a> Better name for test that stops statement</li>
<li><a href=""https://github.com/junit-team/junit4/commit/527f3a3d0d71ad6dc66ede6f68f6fc316904ed2a""><code>527f3a3</code></a> Replace InfiniteLoop with RunForASecond</li>
<li><a href=""https://github.com/junit-team/junit4/commit/2db63942882d91020b46d7333285e5c94f1d1e52""><code>2db6394</code></a> Tidy up FailOnTimeoutTest</li>
<li><a href=""https://github.com/junit-team/junit4/commit/64634e1c3e357251a84278c26b73b04fc3450ea3""><code>64634e1</code></a> Update 4.13.2 release notes to document pull 1654</li>
<li><a href=""https://github.com/junit-team/junit4/commit/f8ee412316b1a94d3dc35498359cc2f0ca273216""><code>f8ee412</code></a> Fix serialization of AssumptionViolatedException (<a href=""https://github-redirect.dependabot.com/junit-team/junit4/issues/1654"">#1654</a>)</li>
<li>Additional commits viewable in <a href=""https://github.com/junit-team/junit4/compare/r4.12...r4.13.2"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=junit:junit&package-manager=maven&previous-version=4.12&new-version=4.13.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump junit from 4.12 to 4.13.2
1894,,['pom.xml'],"@@ -97,7 +97,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>3.2.0</version>
+          <version>3.3.0</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>, ","Bumps [maven-javadoc-plugin](https://github.com/apache/maven-javadoc-plugin) from 3.2.0 to 3.3.0.
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/aa3e12c52f0845f0561f3b4db719c0e8ede1aada""><code>aa3e12c</code></a> [maven-release-plugin] prepare release maven-javadoc-plugin-3.3.0</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/55982df63f8de5bfbb48aee353bc29b35b1c6a2c""><code>55982df</code></a> [MJAVADOC-584] excludePackageNames is not working as documented anymore</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/e9729cecf01bd1962b5fd4cbff14996bad8f92a6""><code>e9729ce</code></a> [MJAVADOC-453] Using Alternate Doclet documentation example snippet is out of...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/9f98af73ec59629415926374cfe4f6ff3b198e45""><code>9f98af7</code></a> [MJAVADOC-592] detectJavaApiLink should also respect maven.compiler.source pr...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/1028afcf24ba35eedf1ebbbe62bd9418e06fb7f6""><code>1028afc</code></a> [MJAVADOC-592] Prepare integration tests</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/1963ee882e6eb0e4f6c15d5eb6205c31d9f73740""><code>1963ee8</code></a> Bump actions/checkout from 2 to 2.3.4</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/f27c99dcf35a27ab06b00ad1e2b30336de39fdf8""><code>f27c99d</code></a> [MJAVADOC-590] Setting nooverview option always causes a build failure</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/d5b80c06c9d243a3e267c5dbb5961fd9d514ab87""><code>d5b80c0</code></a> Revert &quot;(doc) enable streamLogsOnFailure&quot;</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/3926bd4cadaa6e4c49c7f973f04927602e384d40""><code>3926bd4</code></a> [MJAVADOC-619] Maven Javadoc bottom claims copyright for future years</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/15a02d6f7928681be6d11a7866ccc09d73a9c869""><code>15a02d6</code></a> (doc) enable streamLogsOnFailure</li>
<li>Additional commits viewable in <a href=""https://github.com/apache/maven-javadoc-plugin/compare/maven-javadoc-plugin-3.2.0...maven-javadoc-plugin-3.3.0"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.plugins:maven-javadoc-plugin&package-manager=maven&previous-version=3.2.0&new-version=3.3.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-javadoc-plugin from 3.2.0 to 3.3.0
1895,Éamonn McManus,"['CHANGELOG.md', 'UserGuide.md']","@@ -1,6 +1,16 @@
 Change Log
 ==========
 
+## Version 2.8.7
+
+* Fixed `ISO8601UtilsTest` failing on systems with UTC+X.
+* Improved javadoc for `JsonStreamParser`.
+* Updated proguard.cfg (#1693).
+* Fixed `IllegalStateException` in `JsonTreeWriter` (#1592).
+* Added `JsonArray.isEmpty()` (#1640).
+* Added new test cases (#1638).
+* Fixed OSGi metadata generation to work on JavaSE < 9 (#1603).
+
 ## Version 2.8.6
 _2019-10-04_  [GitHub Diff](https://github.com/google/gson/compare/gson-parent-2.8.5...gson-parent-2.8.6)
  * Added static methods `JsonParser.parseString` and `JsonParser.parseReader` and deprecated instance method `JsonParser.parse`, @@ -74,7 +74,7 @@ The Gson instance does not maintain any state while invoking Json operations. So
 ## <a name=""TOC-Gson-With-Gradle""></a>Using Gson with Gradle/Android
 ```
 dependencies {
-    implementation 'com.google.code.gson:gson:2.8.6'
+    implementation 'com.google.code.gson:gson:2.8.7'
 }
 ```
 ## <a name=""TOC-Gson-With-Maven""></a>Using Gson with Maven
@@ -86,7 +86,7 @@ To use Gson with Maven2/3, you can use the Gson version available in Maven Centr
     <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
-      <version>2.8.6</version>
+      <version>2.8.7</version>
       <scope>compile</scope>
     </dependency>
 </dependencies>, ",NaN,Update user guide and change log to reflect 2.8.7 release.
1897,,['README.md'],"@@ -17,7 +17,7 @@ There are a few open-source projects that can convert Java objects to JSON. Howe
 Gradle:
 ```gradle
 dependencies {
-  implementation 'com.google.code.gson:gson:2.8.6'
+  implementation 'com.google.code.gson:gson:2.8.7'
 }
 ```
 
@@ -26,7 +26,7 @@ Maven:
 <dependency>
   <groupId>com.google.code.gson</groupId>
   <artifactId>gson</artifactId>
-  <version>2.8.6</version>
+  <version>2.8.7</version>
 </dependency>
 ```
 , ",version 2.8.6 -> 2.8.7 for gradle and maven dependencies block,Update README.md version 2.8.6 -> 2.8.7
1909,Ajay Kumar Jha,['gson/src/test/java/com/google/gson/JsonArrayTest.java'],"@@ -16,12 +16,8 @@
 
 package com.google.gson;
 
-import junit.framework.TestCase;
-
 import com.google.gson.common.MoreAsserts;
-
-import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
+import junit.framework.TestCase;
 
 /**
  * @author Jesse Wilson, ","Test cases for testing the exceptional behavior of `get`, `getAsBoolean`, `getAsDouble`, `getAsInt`, `getAsJsonArray`, `getAsJsonObject`, `getAsLong`, and `getAsString` methods of `JsonArray` class. These test cases, which we wrote according to the specified behavior of each method, that helped us in identifying the documentation bugs in `JsonArray` and `JsonElement` classes, which we submitted issues for (Issue #1908). Note that we have adapted these test cases based on similar tests from the [JSON-java](https://github.com/stleary/JSON-java) project.",Test cases for testing the exceptional behavior of JsonArray get... methods
1924,Éamonn McManus,"['gson/src/main/java/com/google/gson/internal/$Gson$Types.java', 'gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java']","@@ -339,13 +339,13 @@ public static Type getCollectionElementType(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable, Type>());
+    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Map<TypeVariable, Type> visitedTypeVariables) {
+                              Map<TypeVariable<?>, Type> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
-    TypeVariable resolving = null;
+    TypeVariable<?> resolving = null;
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;, @@ -1,54 +1,55 @@
 package com.google.gson.functional;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import org.junit.Before;
 import org.junit.Test;
-
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 
-import static org.junit.Assert.*;
-
 /**
  * This test covers the scenario described in #1390 where a type variable needs to be used
  * by a type definition multiple times.  Both type variable references should resolve to the
  * same underlying concrete type.
  */
 public class ReusedTypeVariablesFullyResolveTest {
 
-    private Gson gson;
+  private Gson gson;
 
-    @Before
-    public void setUp() {
-        gson = new GsonBuilder().create();
-    }
+  @Before
+  public void setUp() {
+    gson = new GsonBuilder().create();
+  }
 
-    @SuppressWarnings(""ConstantConditions"") // The instances were being unmarshaled as Strings instead of TestEnums
-    @Test
-    public void testGenericsPreservation() {
-        TestEnumSetCollection withSet = gson.fromJson(""{\""collection\"":[\""ONE\"",\""THREE\""]}"", TestEnumSetCollection.class);
-        Iterator<TestEnum> iterator = withSet.collection.iterator();
-        assertNotNull(withSet);
-        assertNotNull(withSet.collection);
-        assertEquals(2, withSet.collection.size());
-        TestEnum first = iterator.next();
-        TestEnum second = iterator.next();
+  @SuppressWarnings(""ConstantConditions"") // The instances were being unmarshaled as Strings instead of TestEnums
+  @Test
+  public void testGenericsPreservation() {
+    TestEnumSetCollection withSet = gson.fromJson(""{\""collection\"":[\""ONE\"",\""THREE\""]}"", TestEnumSetCollection.class);
+    Iterator<TestEnum> iterator = withSet.collection.iterator();
+    assertNotNull(withSet);
+    assertNotNull(withSet.collection);
+    assertEquals(2, withSet.collection.size());
+    TestEnum first = iterator.next();
+    TestEnum second = iterator.next();
 
-        assertTrue(first instanceof TestEnum);
-        assertTrue(second instanceof TestEnum);
-    }
+    assertTrue(first instanceof TestEnum);
+    assertTrue(second instanceof TestEnum);
+  }
 
-    enum TestEnum { ONE, TWO, THREE }
+  enum TestEnum { ONE, TWO, THREE }
 
-    private static class TestEnumSetCollection extends SetCollection<TestEnum> {}
+  private static class TestEnumSetCollection extends SetCollection<TestEnum> {}
 
-    private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}
+  private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}
 
-    private static class BaseCollection<U, C extends Collection<U>>
-    {
-        public C collection;
-    }
+  private static class BaseCollection<U, C extends Collection<U>>
+  {
+    public C collection;
+  }
 
 }, ","Use two-space indentation for the new test.
Use standard Google import style.
Supply missing type argument for `TypeVariable`.",Adjust some minor details of #1391.
1925,,['gson/pom.xml'],"@@ -133,7 +133,7 @@
       </plugin>
       <plugin>
         <artifactId>maven-resources-plugin</artifactId>
-        <version>2.7</version>
+        <version>3.2.0</version>
         <executions>
           <execution>
             <id>post-obfuscate-class</id>, ","Bumps [maven-resources-plugin](https://github.com/apache/maven-resources-plugin) from 2.7 to 3.2.0.
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/61096d9200bc226311d92effc3de3cbe8086d1ad""><code>61096d9</code></a> [maven-release-plugin] prepare release maven-resources-plugin-3.2.0</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/fa28224811262ae045bd96cdff7540f993a0ba17""><code>fa28224</code></a> Rollback to make a new release attempt.</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/22120e9eae074ef29a1ed61de8a2e9829010682d""><code>22120e9</code></a> [maven-release-plugin] prepare for next development iteration</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/6bf362e05843eef5fb05c4e1654ccfb6042d65a9""><code>6bf362e</code></a> [maven-release-plugin] prepare release maven-resources-plugin-3.2.0</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/0f26239591eace68def9d0045a437ef256936570""><code>0f26239</code></a> [MRESOURCES-263] Update to maven-filtering 3.2.0</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/6624e45411b02b1c31694042e9b5f9b386422904""><code>6624e45</code></a> future proof method that is marked for incompatible change (<a href=""https://github-redirect.dependabot.com/apache/maven-resources-plugin/issues/6"">#6</a>)</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/b974fb27221a78c41c8cc70a2530da722a939184""><code>b974fb2</code></a> try with resources (<a href=""https://github-redirect.dependabot.com/apache/maven-resources-plugin/issues/5"">#5</a>)</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/b42cd5a1f66e87b7466373e2d1415c7044fc3f2a""><code>b42cd5a</code></a> [MRESOURCES-232] Resource copy filtering should use different encoding for so...</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/4b468985e02465f9991a2d14ce7f3e4b2e611091""><code>4b46898</code></a> [MRESOURCES-257] property from list element in pom model</li>
<li><a href=""https://github.com/apache/maven-resources-plugin/commit/a2fb8d421f62f354b69c227f06280cc30eadbeea""><code>a2fb8d4</code></a> Bump version to a new minor version, since we have added functionality.</li>
<li>Additional commits viewable in <a href=""https://github.com/apache/maven-resources-plugin/compare/maven-resources-plugin-2.7...maven-resources-plugin-3.2.0"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.plugins:maven-resources-plugin&package-manager=maven&previous-version=2.7&new-version=3.2.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-resources-plugin from 2.7 to 3.2.0
1926,,['gson/pom.xml'],"@@ -19,7 +19,7 @@
     <dependency>
       <groupId>com.github.wvengen</groupId>
       <artifactId>proguard-maven-plugin</artifactId>
-      <version>2.3.1</version>
+      <version>2.4.0</version>
       <scope>test</scope>
     </dependency>
   </dependencies>, ","Bumps [proguard-maven-plugin](https://github.com/wvengen/proguard-maven-plugin) from 2.3.1 to 2.4.0.
<details>
<summary>Changelog</summary>
<p><em>Sourced from <a href=""https://github.com/wvengen/proguard-maven-plugin/blob/master/CHANGELOG.md"">proguard-maven-plugin's changelog</a>.</em></p>
<blockquote>
<h1>Changelog</h1>
<h2>Unreleased</h2>
<ul>
<li>Minimum Java version bumped to 1.8 (<a href=""https://github-redirect.dependabot.com/wvengen/proguard-maven-plugin/pull/127"">127</a>)</li>
<li>Support workaround for long command line problems (<a href=""https://github-redirect.dependabot.com/wvengen/proguard-maven-plugin/pull/113"">113</a>)</li>
</ul>
</blockquote>
</details>
<details>
<summary>Commits</summary>
<ul>
<li>See full diff in <a href=""https://github.com/wvengen/proguard-maven-plugin/commits"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.github.wvengen:proguard-maven-plugin&package-manager=maven&previous-version=2.3.1&new-version=2.4.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump proguard-maven-plugin from 2.3.1 to 2.4.0
1927,,['gson/pom.xml'],"@@ -78,7 +78,7 @@
       <plugin>
         <groupId>com.coderplus.maven.plugins</groupId>
         <artifactId>copy-rename-maven-plugin</artifactId>
-        <version>1.0</version>
+        <version>1.0.1</version>
         <executions>
           <execution>
             <id>pre-obfuscate-class</id>, ","Bumps [copy-rename-maven-plugin](https://github.com/coderplus/copy-rename-maven-plugin) from 1.0 to 1.0.1.
<details>
<summary>Commits</summary>
<ul>
<li>See full diff in <a href=""https://github.com/coderplus/copy-rename-maven-plugin/commits"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=com.coderplus.maven.plugins:copy-rename-maven-plugin&package-manager=maven&previous-version=1.0&new-version=1.0.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump copy-rename-maven-plugin from 1.0 to 1.0.1
1930,Christoffer Quist Adamsen,['examples/android-proguard-example/proguard.cfg'],"@@ -25,4 +25,8 @@
   @com.google.gson.annotations.SerializedName <fields>;
 }
 
+# Retain generic signatures of TypeToken and its subclasses with R8 version 3.0 and higher.
+-keep,allowobfuscation,allowshrinking class com.google.gson.reflect.TypeToken
+-keep,allowobfuscation,allowshrinking class * extends com.google.gson.reflect.TypeToken
+
 ##---------------End: proguard configuration for Gson  ----------, ","R8 version 3.0 started to remove generic signatures from items that are not matched by a -keep rule in full mode (see also https://r8.googlesource.com/r8/+/744d742137a82656b8ee27513f975e0528aecd78). The motivation for this change is to avoid that all generic signatures are retained in programs, when only a few are typically required for reflection.

This change adds a rule that causes the generic signatures of com.google.gson.reflect.TypeToken and its subclasses to be retained. This is needed because [com.google.gson.reflect.TypeToken reflectively accesses its own generic signature](https://github.com/google/gson/blob/ceae88bd6667f4263bbe02e6b3710b8a683906a2/gson/src/main/java/com/google/gson/reflect/TypeToken.java#L62).

References:
* http://issuetracker.google.com/issues/188703877#comment28",Retain generic signature of TypeToken with R8 version 3.0 and higher
1935,,['pom.xml'],"@@ -120,7 +120,7 @@
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-api</artifactId>
-            <version>1.11.2</version>
+            <version>1.11.3</version>
           </dependency>
           <dependency>
             <groupId>org.apache.maven.scm</groupId>, ","Bumps [maven-scm-api](https://github.com/apache/maven-scm) from 1.11.2 to 1.11.3.
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/apache/maven-scm/commit/f5a162b06b4e1f4080b7846812848e6ce64e1727""><code>f5a162b</code></a> [maven-release-plugin] prepare release maven-scm-1.11.3</li>
<li><a href=""https://github.com/apache/maven-scm/commit/c53157e2d386ff55487f92d2b65936ad9dfac684""><code>c53157e</code></a> [maven-release-plugin] rollback the release of maven-scm-1.11.3</li>
<li><a href=""https://github.com/apache/maven-scm/commit/156294efda49fc12d399a901cc6f5e948e02e87b""><code>156294e</code></a> [maven-release-plugin] prepare for next development iteration</li>
<li><a href=""https://github.com/apache/maven-scm/commit/77c9f77ed67a445ee36e1d6e9c076de7cb3e08aa""><code>77c9f77</code></a> [maven-release-plugin] prepare release maven-scm-1.11.3</li>
<li><a href=""https://github.com/apache/maven-scm/commit/f21ca5a8c55f05130db98400d85506a383628138""><code>f21ca5a</code></a> [SCM-947] Improve ChangeLogMojo by using ChangeLogRequest</li>
<li><a href=""https://github.com/apache/maven-scm/commit/4cafe0f5031f7ca0be79f2e4944b535a8c812ac5""><code>4cafe0f</code></a> [SCM-948] Make limit parameter work for svnexe and gitexe changelog goal</li>
<li><a href=""https://github.com/apache/maven-scm/commit/a434fe6fffe110dc78e4c84f6c0d41e72a932e33""><code>a434fe6</code></a> [SCM-955] gitexe and svnexe provider TCK tests fail when path is absolute</li>
<li><a href=""https://github.com/apache/maven-scm/commit/3a10d0f52b1e564b8bdad71161d7c74ac1dd3d99""><code>3a10d0f</code></a> [SCM-954] Always use --internal-diff for SvnDiffCommand in svnexe provider</li>
<li><a href=""https://github.com/apache/maven-scm/commit/e58ccd65fd11e427b89bdede8a6b2b8c3a059d93""><code>e58ccd6</code></a> update CI url</li>
<li><a href=""https://github.com/apache/maven-scm/commit/541c8a4c68e55805a45f2ba5370ffee46268ee0c""><code>541c8a4</code></a> Bump mockito-core from 1.10.19 to 2.28.2</li>
<li>Additional commits viewable in <a href=""https://github.com/apache/maven-scm/compare/maven-scm-1.11.2...maven-scm-1.11.3"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.scm:maven-scm-api&package-manager=maven&previous-version=1.11.2&new-version=1.11.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-scm-api from 1.11.2 to 1.11.3
1936,,['pom.xml'],"@@ -125,7 +125,7 @@
           <dependency>
             <groupId>org.apache.maven.scm</groupId>
             <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.11.2</version>
+            <version>1.11.3</version>
           </dependency>
         </dependencies>
         <configuration>, ","Bumps maven-scm-provider-gitexe from 1.11.2 to 1.11.3.


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.scm:maven-scm-provider-gitexe&package-manager=maven&previous-version=1.11.2&new-version=1.11.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-scm-provider-gitexe from 1.11.2 to 1.11.3
1943,Simon GUEROUT,['gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java'],"@@ -251,12 +251,10 @@ private void expect(JsonToken expected) throws IOException {
 
   JsonElement nextJsonElement() throws IOException {
     final JsonToken peeked = peek();
-    if (
-      peeked == JsonToken.NAME
-      || peeked == JsonToken.END_ARRAY
-      || peeked == JsonToken.END_OBJECT
-      || peeked == JsonToken.END_DOCUMENT
-    ) {
+    if (peeked == JsonToken.NAME
+        || peeked == JsonToken.END_ARRAY
+        || peeked == JsonToken.END_OBJECT
+        || peeked == JsonToken.END_DOCUMENT) {
       throw new IllegalStateException(""Unexpected "" + peeked + "" when reading a JsonElement."");
     }
     final JsonElement element = (JsonElement) peekStack();, ","Following up th #1942 conversation, here is a small change, which improves the speed of processing a lot in cases where accessing the `JsonElement` is required.

Note - I'm working on providing flame graphs and examples without company-specific data.",Improve the speed of the JSON_ELEMENT TypeAdapter when the object graph has already been turned into a JsonElement
1947,Éamonn McManus,['gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java'],"@@ -39,7 +39,6 @@
 import java.net.InetAddress;
 import java.net.URI;
 import java.net.URL;
-import java.sql.Time;
 import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.util.ArrayList;, ",NaN,Remove an unused import.
1948,Éamonn McManus,['gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java'],"@@ -90,7 +90,9 @@ protected void tearDown() throws Exception {
   public void testClassSerialization() {
     try {
       gson.toJson(String.class);
-    } catch (UnsupportedOperationException expected) {}
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
     assertEquals(""\""java.lang.String\"""", gson.toJson(String.class));
@@ -99,7 +101,9 @@ public void testClassSerialization() {
   public void testClassDeserialization() {
     try {
       gson.fromJson(""String.class"", String.class.getClass());
-    } catch (UnsupportedOperationException expected) {}
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
     // Override with a custom type adapter for class.
     gson = new GsonBuilder().registerTypeAdapter(Class.class, new MyClassTypeAdapter()).create();
     assertEquals(String.class, gson.fromJson(""java.lang.String"", Class.class));, ",NaN,Add missing  calls when testing for exceptions.
1949,Éamonn McManus,"['proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithAnnotationsTest.java', 'proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java', 'proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java']","@@ -30,8 +30,7 @@
 import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage;
 import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Data;
 import com.google.gson.protobuf.generated.Bag.ProtoWithAnnotations.InnerMessage.Type;
-import com.google.protobuf.GeneratedMessage;
-
+import com.google.protobuf.GeneratedMessageV3;
 import junit.framework.TestCase;
 
 /**
@@ -52,15 +51,15 @@ protected void setUp() throws Exception {
         .addSerializedNameExtension(Annotations.serializedName)
         .addSerializedEnumValueExtension(Annotations.serializedValue);
     gson = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter.build())
+        .registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter.build())
         .create();
     gsonWithEnumNumbers = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
+        .registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter
             .setEnumSerialization(EnumSerialization.NUMBER)
             .build())
         .create();
     gsonWithLowerHyphen = new GsonBuilder()
-        .registerTypeHierarchyAdapter(GeneratedMessage.class, protoTypeAdapter
+        .registerTypeHierarchyAdapter(GeneratedMessageV3.class, protoTypeAdapter
             .setFieldNameSerializationFormat(CaseFormat.LOWER_UNDERSCORE, CaseFormat.LOWER_HYPHEN)
             .build())
         .create();, @@ -24,8 +24,7 @@
 import com.google.gson.protobuf.generated.Bag.ProtoWithDifferentCaseFormat;
 import com.google.gson.protobuf.generated.Bag.ProtoWithRepeatedFields;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
-import com.google.protobuf.GeneratedMessage;
-
+import com.google.protobuf.GeneratedMessageV3;
 import junit.framework.TestCase;
 
 /**
@@ -42,15 +41,15 @@ protected void setUp() throws Exception {
     super.setUp();
     gson =
         new GsonBuilder()
-            .registerTypeHierarchyAdapter(GeneratedMessage.class,
+            .registerTypeHierarchyAdapter(GeneratedMessageV3.class,
                 ProtoTypeAdapter.newBuilder()
                     .setEnumSerialization(EnumSerialization.NUMBER)
                     .build())
             .create();
     upperCamelGson =
         new GsonBuilder()
             .registerTypeHierarchyAdapter(
-                GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+                GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder()
                     .setFieldNameSerializationFormat(
                         CaseFormat.LOWER_UNDERSCORE, CaseFormat.UPPER_CAMEL)
                     .build()), @@ -21,8 +21,7 @@
 import com.google.gson.protobuf.ProtoTypeAdapter.EnumSerialization;
 import com.google.gson.protobuf.generated.Bag.SimpleProto;
 import com.google.protobuf.Descriptors.Descriptor;
-import com.google.protobuf.GeneratedMessage;
-
+import com.google.protobuf.GeneratedMessageV3;
 import junit.framework.TestCase;
 
 public class ProtosWithPrimitiveTypesTest extends TestCase {
@@ -32,7 +31,7 @@
   protected void setUp() throws Exception {
     super.setUp();
     gson = new GsonBuilder().registerTypeHierarchyAdapter(
-      GeneratedMessage.class, ProtoTypeAdapter.newBuilder()
+      GeneratedMessageV3.class, ProtoTypeAdapter.newBuilder()
           .setEnumSerialization(EnumSerialization.NUMBER)
           .build())
       .create();, ","Also use `GeneratedMessageV3` rather than `GeneratedMessage`, consistent with recent versions of `protoc`.

Closes #1797.",Update dependencies in proto/pom.xml.
1951,Nikita Novik,['gson/pom.xml'],"@@ -12,7 +12,7 @@
 
   <licenses>
     <license>
-      <name>Apache 2.0</name>
+      <name>Apache-2.0</name>
       <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>
     </license>
   </licenses>, ","I use [gradle-license-plugin](https://github.com/jaredsburrows/gradle-license-plugin) to keep information about licenses for my project's dependencies up-to-date. This Gradle plugin heavily relies on POM file to get information about license for `.jar` or `.aar` artifacts.

Unfortunately, for the latest GSON artifact from Maven Central it is impossible to retrieve information about license from [POM file](https://repo1.maven.org/maven2/com/google/code/gson/gson/2.8.8/gson-2.8.8.pom). This PR adds such information to GSON POM file.",Add license note to GSON POM file.
1953,Z,['extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java'],"@@ -45,8 +45,7 @@ public static void main(String[] args) {
     collection.add(new Event(""GREETINGS"", ""guest""));
     String json = gson.toJson(collection);
     System.out.println(""Using Gson.toJson() on a raw collection: "" + json);
-    JsonParser parser = new JsonParser();
-    JsonArray array = parser.parse(json).getAsJsonArray();
+    JsonArray array = JsonParser.parseString(json).getAsJsonArray();
     String message = gson.fromJson(array.get(0), String.class);
     int number = gson.fromJson(array.get(1), int.class);
     Event event = gson.fromJson(array.get(2), Event.class);, ",use static method instead deprecated method,update RawCollectionsExample.java
1954,Z,['UserGuide.md'],"@@ -429,7 +429,7 @@ class IdInstanceCreator implements InstanceCreator<Id<?>> {
   public Id<?> createInstance(Type type) {
     Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments();
     Type idType = typeParameters[0]; // Id has only one parameterized type T
-    return Id.get((Class)idType, 0L);
+    return new Id((Class)idType, 0L);
   }
 }
 ```, ","Id Class does not have get method, we should new a instance.",update UserGuide.md
1956,,['pom.xml'],"@@ -97,7 +97,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>3.3.0</version>
+          <version>3.3.1</version>
         </plugin>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>, ","Bumps [maven-javadoc-plugin](https://github.com/apache/maven-javadoc-plugin) from 3.3.0 to 3.3.1.
<details>
<summary>Commits</summary>
<ul>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/2d22ccadffc2f22f18e19c2cc6d42fd863b4535d""><code>2d22cca</code></a> [maven-release-plugin] prepare release maven-javadoc-plugin-3.3.1</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/7b7813e5ee6ba59ba75701c4d689337865bdc1f1""><code>7b7813e</code></a> [MJAVADOC-450] Artifacts with a classifier are ignored when looking for resou...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/0d0e0cc7325fc27b89b7bde0ba2cbe322ff6a040""><code>0d0e0cc</code></a> [MJAVADOC-618] Goal javadoc:aggregate fails with submodules packaged as war</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/a2acaa28f1534b31429589808b630ebe2f08e3d0""><code>a2acaa2</code></a> [MJAVADOC-137] transform verify script from bsh to groovy</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/16ca1192632f2bfc4e10faa4aa24d319957008dc""><code>16ca119</code></a> Clean up slf4j-simple</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/87dbfb209e5b75ead8443d70a0c748d02a4f729b""><code>87dbfb2</code></a> [MJAVADOC-677] Using &quot;requires static transitive&quot; makes javadoc goal fail</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/d770460b765d2a3ccb9594a1a016c6700501861f""><code>d770460</code></a> [MJAVADOC-680] JDK 16+: Error fetching link: ...\target\javadoc-bundle-option...</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/292ebb7eca37a0cebbff8a40a7d85ea915f211ac""><code>292ebb7</code></a> Bump slf4j-simple from 1.7.30 to 1.7.32</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/fe6d738c2f95a3f5a361f0c4ab2eef49d37ae566""><code>fe6d738</code></a> Bump mockito-core from 3.9.0 to 3.12.0</li>
<li><a href=""https://github.com/apache/maven-javadoc-plugin/commit/d2dd5321dc02e793d87c722224c40d94a607cb51""><code>d2dd532</code></a> [MJAVADOC-679] &quot;Unable to compute stale date&quot; in a directory with accent char...</li>
<li>Additional commits viewable in <a href=""https://github.com/apache/maven-javadoc-plugin/compare/maven-javadoc-plugin-3.3.0...maven-javadoc-plugin-3.3.1"">compare view</a></li>
</ul>
</details>
<br />


[![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=org.apache.maven.plugins:maven-javadoc-plugin&package-manager=maven&previous-version=3.3.0&new-version=3.3.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores)

Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.

[//]: # (dependabot-automerge-start)
[//]: # (dependabot-automerge-end)

---

<details>
<summary>Dependabot commands and options</summary>
<br />

You can trigger Dependabot actions by commenting on this PR:
- `@dependabot rebase` will rebase this PR
- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it
- `@dependabot merge` will merge this PR after your CI passes on it
- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it
- `@dependabot cancel merge` will cancel a previously requested merge and block automerging
- `@dependabot reopen` will reopen this PR if it is closed
- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually
- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)
- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)


</details>",Bump maven-javadoc-plugin from 3.3.0 to 3.3.1
